{"survey_id": "2011.06801v1", "survey_title": "A Comprehensive Survey on Deep Music Generation: Multi-level Representations, Algorithms, Evaluations, and Future Directions", "section_title": "Datasets::MIDI", "section_text_in_survey": " As introduced in Section 3, MIDI is a descriptive \u201cmusic language\", which describes the music information to be performed in bytes, such as what instrument to use, what note to start with, and what note to end at a certain time. MIDI can be employed to listen or input into the analysis program that only requires the basic music description of music score. The MIDI file itself does not contain waveform data, so the file is very small. The pretty_midi Python toolkit contains practical functions/classes for parsing, modifying and processing MIDI data, through which users can easily read various note information contained in MIDI.   Music21 is an object-oriented toolkit for analyzing, searching and converting music in symbolic form. J. S. Bach four-part chorus dataset can be directly obtained from music21 Python package, which contains 402 choruses. The four parts in the dataset are soprano, alto, tenor and bass. However, this data set is very small and lacks expressive information.   Ferreira et al. created a new music dataset VGMIDI with sentiment notation in symbolic format, which contains 95 MIDI labelled piano pieces (966 phrases of 4 bars) from video game soundtracks and 728 non-labelled pieces, all of them vary in length from 26 seconds to 3 minutes. MIDI labelled music pieces is annotated by 30 human subjects according to a valence-arousal (dimensional) model of emotion. The sentiment of each piece is then extracted by summarizing the 30 annotations and mapping the valence axis to sentiment. For the concrete operation of emotion annotation extraction, please refer to literature .   The Lakh MIDI Dataset (LMD) is the largest symbolic music corpus to date, including 176,581 unique MIDI files created by Colin Raffel, of which 45,129 files have been matched and aligned with the items in the Million Song Dataset (MSD) BIBREF356 . However, the dataset has unlimited polyphonic, inconsistent expressive characteristics and contains various genres, instruments and time periods. LMD includes the following formats: 1) 176,581 MIDI files with duplicate data removed, and each file is named according to its MD5 checksum (called \u201cLMD full\"); 2) subset of 45,129 files (called \u201cLMD matched\") that match items in the MSD; 3) All LMD-matched files are aligned with the 7Digital preview MP3s in the MSD (called \u201cLMD aligned\").  5pt |m50pt|m80pt|m27pt|m30pt|m27pt|m55pt|m120pt|m110pt|  Dataset summary 2* Format 2* Name 3c| Modality 2*   2* Size 2* Access   Score   Audio  8rContinued table 2 2* Format 2* Name 3c| Modality 2*   2* Size 2* Access   Score   Audio  10*MIDI JSB Chorus Polyphonic 402 Bach four parts chorus Music21toolkit BIBREF312   VGMIDI Polyphonic with sentiment 823 piano video game soundtracks Derived from BIBREF306   Lakh MIDI Dataset Multi-instrumental 176,581MIDI files http://colinraffel.com/pro-jects/lmd/  Projective Orchestral Database Orchestral 392 MIDI files grouped in pairs containing a piano score and its orchestral version https://qsdfo.github.io/LOP-/database  e-Piano Competition Dataset Polyphonic & Performance \\sim 1400 MIDI files of piano performance http://www.piano-e-competition.com  BitMidi Polyphonic 113,244 MIDI files curated by volunteers around the world https://bitmidi.com/  Classical Archives Polyphonic Maximum number of MIDI files of free classical music https://www.classical-archives.com/  The largest MIDI dataset on the Internet Polyphonic & Style About 130,000 pieces of music from 8 distinct genres (classical, metal, folk, etc.) http://stoneyroads.com/20-15/06/behold-the-worlds-biggest-midicollection-on-the-internet/  ADL Piano MIDI Polyphonic 11,086 unique piano MIDI files https://github.com/lucasnfe/-adl-piano-midi  GiantMIDI-Piano Polyphonic 10,854 MIDI files of classical piano, 1,237 hours in total https://github.com/byte-dance/GiantMIDI-Piano 4*MusicXML TheoryTab Database Polyphonic 16K lead sheet segments https://www.hooktheory.-com/theorytab  Hooktheory Lead Sheet dataset Polyphonic 11,329 lead sheet segments Derived from BIBREF179   Wikifonia Polyphonic 2,252 western music lead sheets http://marg.snu.ac.kr/chord_-generation/(CSV format)  MuseScore lead sheet dataset Performance lead sheet corresponding to Yamaha e-Competitions MIDI dataset https://musescore.com Pianoroll Lakh Pianoroll Dataset Multi-instrumental Approximately equal to the size of LMD https://salu133445.github.-io/musegan/ 4*Text Nottingham Music Dataset Monophonic About 1,000 folk songs abc.sourceforge.net/NMD/  ABC tune book of Henrik Norbeck Monophonic More than 2,800 scores and lyrics in ABC format, mainly Irish and Swiss traditional music http://www.norbeck.nu/abc/  ABC version of FolkDB Monophonic Unknown https://thesession.org/  KernScores Polyphonic Over 700 million notes in 108,703 files http://kern.humdrum.org 6*Audio NSynth Dataset Music audio 306,043 notes https://magenta.tensorflow.-org/datasets/nsynth  FMA dataset Music audio 106,574 tracks of 917GiB Derived from cite212  Minist musical sound dataset Music audio 50,912 notes https://github.com/ejhum-phrey/minst-dataset/  GTZAN Dataset Music audio 1,000 30s music audios http://marsyas.info/down-load/data_sets  Studio On-Line (SOL) Music audio 120,000 sounds Derived from BIBREF315   NUS Sung and Spoken Lyrics(NUS-48E) Corpus Sing Voice 169 minutes recordings of 48 English songs Derived from BIBREF316  9*  MusicNet Dataset Fusion 330 recordings of classical music https://homes.cs.washing-ton.edu/\\sim thickstn/musicnet-.html  MAESTRO Dataset Fusion 172 hours of virtuosic piano performances https://g.co/magenta/-maestrodataset  NES Music Database Multi-instrumental thousands of Derived from BIBREF199   Piano-Midi Polyphonic & performance 332 classical piano pieces www.piano-midi.de/  Groove MIDI Dataset Drum 13.6 hours recordings, 1,150 MIDI files and over 22,000 measures of tempo-aligned expressive drumming https://magenta.tensorflow-.org/datasets/groove  POP909 Polyphonic multiple versions of the piano arrangements of 909 popular songs https://github.com/music-x-lab/POP909-Dataset  ASAP Polyphonic Performance& Fusion 222 digital musical scores aligned with 1,068 performances https://github.com/fosfrance-sco/asap-dataset  Aligned lyrics-melody music dataset Fusion 13,937 20-note sequences with 278,740 syllable-note pairs https://github.com/yy1lab/-Lyrics-Conditioned-Neural-Melody-Generation  MTM Dataset Fusion Unknown https://github.com/Morning-Books/MTM-Dataset  The Projective Orchestral Database (POD) is devoted to the study of the relationship between piano scores and corresponding orchestral arrangements. It contains 392 MIDI files, which are grouped in pairs containing a piano score and its orchestral version. In order to facilitate the research work, crestel et al. BIBREF357 provided a pre-computed pianoroll representation. In addition, they also proposed a method to automatically align piano scores and their corresponding orchestral arrangements, resulting in a new version of MIDI database. They provide all MIDI files as well as preprocessed pianoroll representations of alignment and misalignment for free on the following website https://qsdfo.github.io/LOP/index.html.   The e-piano junior competition is an international classical piano competition. The e-piano junior competition dataset is a collection of professional pianists' solo piano performances. It is the largest public dataset that provides a substantial amount of expressive performance MIDI ( 1400) of professional pianists. Most of them are late romantic works, such as Chopin and Liszt, as well as some Mozart sonatas. Since this dataset provides high-quality piano performance data in MIDI, including the fine control of timing and dynamics by different performers, the dataset is widely used in the research of performance generation, but it does not contain the corresponding music score of the pieces BIBREF354 .   The ADL piano MIDI dataset is based on LMD. In LMD, there are many versions of the same song, and only one version is reserved for each song in the ADL dataset. Later, Ferreira et al. BIBREF355 extracted from the LMD only the tracks with instruments from the \u201cpiano family\" (MIDI program number 1-8). This process generated a total of 9,021 unique piano MIDI files. These files are mainly rock and classical music, so in order to increase the genres diversity (as jazz, etc.) of the dataset, they have added another 2,065 files obtained from public resources on the Internet FOOTREF78 . All the files in the collection are de-duped according to MD5 checksums, and the final dataset has 11,086 pieces.   Recently, ByteDance released GiantMIDI-Piano BIBREF358, the world's largest classical piano dataset, including MIDI files from 10,854 music works of 2,784 composers, with a total duration of 1,237 hours. In terms of data scale, the total duration of different music pieces in the dataset is 14 times that of Google\u2019s MAESTRO dataset. In order to construct the dataset, researchers have developed and open-sourced a high-resolution piano transcription system, which is used to convert all audio into MIDI files. MIDI files include the onset, dynamics and pedal information of notes.   In addition, BitMidi FOOTREF79 provides 113,244 MIDI files curated by volunteers around the world; Classical Archives FOOTREF80 is the largest classical music website, including the largest collection of free classical music MIDI files; the largest MIDI dataset FOOTREF81 on the Internet contains about 130,000 music from eight different genres (classical, metal, folk, etc.); FreeMidi FOOTREF82 comprises more than 25,860 MIDI files of assorted genres. ", "citations": {"bibrefs": ["BIBREF199", "BIBREF315", "BIBREF312", "BIBREF306", "BIBREF179", "BIBREF316", "BIBREF354", "BIBREF355", "BIBREF356", "BIBREF357", "BIBREF358"], "BIBREF199": {"title": "The nes music database: A multi-instrumental dataset with expressive performance attributes", "authors": [{"first": "Chris", "middle": [], "last": "Donahue", "suffix": ""}, {"first": "Huanru", "middle": [], "last": "Henry Mao", "suffix": ""}, {"first": "Julian", "middle": [], "last": "Mcauley", "suffix": ""}], "venue": "ISMIR", "volume": "", "issue": "", "pages": "475--482", "text_pymu": "THE NES MUSIC DATABASE: A MULTI-INSTRUMENTAL DATASET\nWITH EXPRESSIVE PERFORMANCE ATTRIBUTES\nChris Donahue\nUC San Diego\ncdonahue@ucsd.edu\nHuanru Henry Mao\nUC San Diego\nhhmao@ucsd.edu\nJulian McAuley\nUC San Diego\njmcauley@ucsd.edu\nABSTRACT\nExisting research on music generation focuses on composition, but often ignores the expressive performance characteristics required for plausible renditions of resultant\npieces. In this paper, we introduce the Nintendo Entertainment System Music Database (NES-MDB), a large corpus\nallowing for separate examination of the tasks of composition and performance. NES-MDB contains thousands of\nmulti-instrumental songs composed for playback by the\ncompositionally-constrained NES audio synthesizer. For\neach song, the dataset contains a musical score for four\ninstrument voices as well as expressive attributes for the\ndynamics and timbre of each voice. Unlike datasets comprised of General MIDI files, NES-MDB includes all of the\ninformation needed to render exact acoustic performances\nof the original compositions. Alongside the dataset, we\nprovide a tool that renders generated compositions as NESstyle audio by emulating the device\u2019s audio processor. Additionally, we establish baselines for the tasks of composition, which consists of learning the semantics of composing for the NES synthesizer, and performance, which\ninvolves finding a mapping between a composition and realistic expressive attributes.\n1. INTRODUCTION\nThe problem of automating music composition is a challenging pursuit with the potential for substantial cultural\nimpact. While early systems were hand-crafted by musicians to encode musical rules and structure [25], recent attempts view composition as a statistical modeling problem\nusing machine learning [3]. A major challenge to casting\nthis problem in terms of modern machine learning methods is building representative datasets for training. So far,\nmost datasets only contain information necessary to model\nthe semantics of music composition, and lack details about\nhow to translate these pieces into nuanced performances.\nAs a result, demonstrations of machine learning systems\ntrained on these datasets sound rigid and deadpan. The\ndatasets that do contain expressive performance character-\nc\u20dd Chris Donahue, Huanru Henry Mao, Julian McAuley.\nLicensed under a Creative Commons Attribution 4.0 International License (CC BY 4.0).\nAttribution:\nChris Donahue, Huanru Henry\nMao, Julian McAuley. \u201cThe NES Music Database: A multi-instrumental\ndataset with expressive performance attributes\u201d, 19th International Society for Music Information Retrieval Conference, Paris, France, 2018.\nistics predominantly focus on solo piano [10,27,32] rather\nthan multi-instrumental music.\nA promising source of multi-instrumental music that\ncontains both compositional and expressive characteristics is music from early videogames.\nThere are nearly\n1400 1 unique games licensed for the Nintendo Entertainment System (NES), all of which include a musical soundtrack. The technical constraints of the system\u2019s audio processing unit (APU) impose a maximum of four simultaneous monophonic instruments.\nThe machine code for\nthe games preserves the exact expressive characteristics\nneeded to perform each piece of music as intended by the\ncomposer. All of the music was composed in a limited time\nperiod and, as a result, is more stylistically cohesive than\nother large datasets of multi-instrumental music. Moreover, NES music is celebrated by enthusiasts who continue\nto listen to and compose music for the system [6], appreciating the creativity that arises from resource limitations.\nIn this work, we introduce NES-MDB, and formalize\ntwo primary tasks for which the dataset serves as a large\ntest bed. The first task consists of learning the semantics of\ncomposition on a separated score, where individual instrument voices are explicitly represented. This is in contrast\nto the common blended score approach for modeling polyphonic music, which examines reductions of full scores.\nThe second task consists of mapping compositions onto\nsets of expressive performance characteristics. Combining\nstrategies for separated composition and expressive performance yields an effective pipeline for generating NES music de novo. We establish baseline results and reproducible\nevaluation methodology for both tasks. A further contribution of this work is a library that converts between NES\nmachine code (allowing for realistic playback) and representations suitable for machine learning. 2\n2. BACKGROUND AND TASK DESCRIPTIONS\nStatistical modeling of music seeks to learn the distribution\nP(music) from human compositions c\n\u223c\nP(music) in\na dataset M. If this distribution could be estimated accurately, a new piece could be composed simply by sampling.\nSince the space of potential compositions is exponentially\nlarge, to make sampling tractable, one usually assumes a\nfactorized distribution. For monophonic sequences, which\nconsist of no more than one note at a time, the probability\n1 Including games released only on the Japanese version of the console\n2 https://github.com/chrisdonahue/nesmdb\narXiv:1806.04278v1  [cs.SD]  12 Jun 2018\n\f(a) Blended score (degenerate)\n(b) Separated score (melodic voices top, percussive voice bottom)\n(c) Expressive score (includes dynamics and timbral changes)\nFigure 1: Three representations (rendered as piano rolls)\nfor a segment of Ending Theme from Abadox (1989) by\ncomposer Kiyohiro Sada.\nThe blended score (Fig. 1a),\nused in prior polyphonic composition research, is degenerate when multiple voices play the same note.\nof a sequence c (length T) might be factorized as\nP(c) = P(n1) \u00b7 P(n2 | n1) \u00b7 . . . \u00b7 P(nT | nt<T ).\n(1)\n2.1 Blended composition\nWhile Eq. 1 may be appropriate for modeling compositions\nfor monophonic instruments, in this work we are interested\nin the problem of multi-instrumental polyphonic composition, where multiple monophonic instrument voices may\nbe sounding simultaneously. Much of the prior research\non this topic [2,5,17] represents music in a blended score\nrepresentation. A blended score B is a sparse binary matrix of size N \u00d7 T, where N is the number of possible\nnote values, and B[n, t] = 1 if any voice is playing note\nn at timestep t or 0 otherwise (Fig. 1a). Often, N is constrained to the 88 keys on a piano keyboard, and T is determined by some subdivision of the meter, such as sixteenth\nnotes. When polyphonic composition c is represented by\nB, statistical models often factorize the distribution as a\nsequence of chords, the columns Bt:\nP(c) = P(B1) \u00b7 P(B2 | B1) \u00b7 . . . \u00b7 P(BT | Bt<T ). (2)\nThis representation simplifies the probabilistic framework of the task, but it is problematic for music with multiple instruments (such as the music in NES-MDB). Resultant systems must provide an additional mechanism for\nassigning notes of a blended score to instrument voices,\nor otherwise render the music on polyphonic instruments\nsuch as the piano.\n2.2 Separated composition\nGiven the shortcomings of the blended score, we might\nprefer models which operate on a separated score representation (Fig. 1b). A separated score S is a matrix of size\nV \u00d7 T, where V is the number of instrument voices, and\nS[v, t] = n, the note n played by voice v at timestep t. In\nother words, the format encodes a monophonic sequence\nfor each instrument voice. Statistical approaches to this\nrepresentation can explicitly model the relationships between various instrument voices by\nP(c) =\nT\n\ufffd\nt=1\nV\ufffd\nv=1\nP(Sv,t | Sv,\u02c6t\u0338=t, S\u02c6v\u0338=v,\u2200\u02c6t).\n(3)\nThis formulation explicitly models the dependencies\nbetween Sv,t, voice v at time t, and every other note in\nthe score.\nFor this reason, Eq. 3 more closely resembles the process by which human composers write multiinstrumental music, incorporating temporal and contrapuntal information. Another benefit is that resultant models\ncan be used to harmonize with existing musical material,\nadding voices conditioned on existing ones. However, any\nnon-trivial amount of temporal context introduces highdimensional interdependencies, meaning that such a formulation would be challenging to sample from. As a consequence, solutions are often restricted to only take past\ntemporal context into account, allowing for simple and efficient ancestral sampling (though Gibbs sampling can also\nbe used to sample from Eq. 3 [13,16]).\nMost existing datasets of multi-instrumental music have\nuninhibited polyphony, causing a separated score representation to be inappropriate. However, the hardware constraints of the NES APU impose a strict limit on the number of voices, making the format ideal for NES-MDB.\n2.3 Expressive performance\nGiven a piece of a music, a skilled performer will embellish the piece with expressive characteristics, altering\nthe timing and dynamics to deliver a compelling rendition.\nWhile a few instruments have been augmented to capture\nthis type of information symbolically (e.g. a Disklavier),\nit is rarely available for examination in datasets of multiinstrumental music. Because NES music is comprised of\ninstructions that recreate an exact rendition of each piece,\nexpressive characteristics controlling the velocity and timbre of each voice are available in NES-MDB (details in\nSection 3.1). Thus, each piece can be represented as an\nexpressive score (Fig. 1c), the union of its separated score\nand expressive characteristics.\nWe consider the task of mapping a composition c onto\nexpressive characteristics e.\nHence, we would like to\nmodel P(e | c), and the probability of a piece of music\nP(m) can be expressed as P(e | c) \u00b7 P(c), where P(c) is\nfrom Eq. 3. This allows for a convenient pipeline for music\ngeneration where a piece of music is first composed with\nbinary amplitudes and then mapped to realistic dynamics,\nas if interpreted by a performer.\n\f# Games\n397\n# Composers\n296\n# Songs\n5, 278\n# Songs w/ length > 10s\n3, 513\n# Notes\n2, 325, 636\nDataset length\n46.1 hours\nP(Pulse 1 On)\n0.861\nP(Pulse 2 On)\n0.838\nP(Triangle On)\n0.701\nP(Noise On)\n0.390\nAverage polyphony\n2.789\nTable 1: Basic dataset information for NES-MDB.\n2.4 Task summary\nIn summary, we propose three tasks for which NES-MDB\nserves as a large test bed. A pairing of two models that\naddress the second and third tasks can be used to generate\nnovel NES music.\n1. The blended composition task (Eq. 2) models the\nsemantics of blended scores (Fig. 1a). This task is\nmore useful for benchmarking new algorithms than\nfor NES composition.\n2. The separated composition task consists of modeling the semantics of separated scores (Fig. 1b) using\nthe factorization from Eq. 3.\n3. The expressive performance task seeks to map separated scores to expressive characteristics needed to\ngenerate an expressive score (Fig. 1c).\n3. DATASET DESCRIPTION\nThe NES APU consists of five monophonic instruments:\ntwo pulse wave generators (P1/P2), a triangle wave generator (TR), a noise generator (NO), and a sampler which\nallows for playback of audio waveforms stored in memory. Because the sampler may be used to play melodic or\npercussive sounds, its usage is compositionally ambiguous\nand we exclude it from our dataset.\nIn raw form, music for NES games exists as machine\ncode living in the read-only memory of cartridges, entangled with the rest of the game logic. An effective method\nfor extracting a musical transcript is to emulate the game\nand log the timing and values of writes to the APU registers. The video game music (VGM) format 3 was designed\nfor precisely this purpose, and consists of an ordered list\nof writes to APU registers with 44.1 kHz timing resolution. An online repository 4 contains over 400 NES games\nlogged in this format. After removing duplicates, we split\nthese games into distinct training, validation and test subsets with an 8:1:1 ratio, ensuring that no composer appears\nin two of the subsets. Basic statistics of the dataset appear\nin Table 1.\n3 http://vgmrips.net/wiki/VGM_Specification\n4 http://vgmrips.net/packs/chip/nes-apu\n3.1 Extracting expressive scores\nGiven the VGM files, we emulate the functionality of the\nAPU to yield an expressive score (Fig. 1c) at a temporal discretization of 44.1 kHz. This rate is unnecessarily\nhigh for symbolic music, so we subsequently downsample the scores. 5 Because the music has no explicit tempo\nmarkings, we accommodate a variety of implicit tempos by\nchoosing a permissive downsampling rate of 24 Hz. By removing dynamics, timbre, and voicing at each timestep, we\nderive separated score (Fig. 1b) and blended score (Fig. 1a)\nversions of the dataset.\nInstrument\nNote\nVelocity\nTimbre\nPulse 1 (P1)\n{0, 32, . . . , 108}\n[0, 15]\n[0, 3]\nPulse 2 (P2)\n{0, 32, . . . , 108}\n[0, 15]\n[0, 3]\nTriangle (TR)\n{0, 21, . . . , 108}\nNoise (NO)\n{0, 1, . . . , 16}\n[0, 15]\n[0, 1]\nTable 2: Dimensionality for each timestep of the expressive score representation (Fig. 1c) in NES-MDB.\nIn Table 2, we show the dimensionality of the instrument states at each timestep of an expressive score in NESMDB. We constrain the frequency ranges of the melodic\nvoices (pulse and triangle generators) to the MIDI notes\non an 88-key piano keyboard (21 through 108 inclusive,\nthough the pulse generators cannot produce pitches below\nMIDI note 32). The percussive noise voice has 16 possible\n\u201cnotes\u201d (these do not correspond to MIDI note numbers)\nwhere higher values have more high-frequency noise. For\nall instruments, a note value of 0 indicates that the instrument is not sounding (and the corresponding velocity will\nbe 0). When sounding, the pulse and noise generators have\n15 non-linear velocity values, while the triangle generator\nhas no velocity control beyond on or off.\nAdditionally, the pulse wave generators have 4 possible duty cycles (affecting timbre), and the noise generator\nhas a rarely-used mode where it instead produces metallic\ntones. Unlike for velocity, a timbre value of 0 corresponds\nto an actual timbre setting and does not indicate that an instrument is muted. In total, the pulse, triangle and noise\ngenerators have state spaces of sizes 4621, 89, and 481\nrespectively\u2014around 40 bits of information per timestep\nfor the full ensemble.\n4. EXPERIMENTS AND DISCUSSION\nBelow, we describe our evaluation criteria for experiments\nin separated composition and expressive performance. We\npresent these results only as statistical baselines for comparison; results do not necessarily reflect a model\u2019s ability\nto generate compelling musical examples.\nNegative log-likelihood and Accuracy Negative loglikelihood (NLL) is the (log of the) likelihood that a model\nassigns to unseen real data (as per Eq. 3). A low NLL averaged across unseen data may indicate that a model captures\n5 We also release NES-MDB in MIDI format with no downsampling\n\fsemantics of the data distribution. Accuracy is defined as\nthe proportion of timesteps where a model\u2019s prediction is\nequal to the actual composition. We report both measures\nfor each voice, as well as aggregations across all voices by\nsumming (for NLL) and averaging (for accuracy).\nPoints of Interest (POI). Unlike other datasets of symbolic music, NES-MDB is temporally-discretized at a\nhigh, fixed rate (24 Hz), rather than at a variable rate depending on the tempo of the music. As a consequence,\nany given voice has around an 83% chance of playing the\nsame note as that voice at the previous timestep. Accordingly, our primary evaluation criteria focuses on musicallysalient points of interest (POIs), timesteps at which a voice\ndeviates from the previous timestep (the beginning or end\nof a note). This evaluation criterion is mostly invariant to\nthe rate of temporal discretization.\n4.1 Separated composition experiments\nFor separated composition, we evaluate the performance\nof several baselines and compare them to a cutting edge\nmethod. Our simplest baselines are unigram and additivesmoothed bigram distributions for each instrument. The\npredictions of such models are trivial; the unigram model\nalways predicts \u201cno note\u201d and the bigram model always\npredicts \u201clast note\u201d. The respective accuracy of these models, 37% and 83%, reflect the proportion of the timesteps\nthat are silent (unigram) or identical to the last timestep (bigram). However, if we evaluate these models only at POIs,\ntheir performance is substantially worse (4% and 0%).\nWe also measure performance of recurrent neural networks (RNNs) at modeling the voices independently. We\ntrain a separate RNN (either a basic RNN cell or an\nLSTM cell [15]) on each voice to form our RNN Soloists\nand LSTM Soloists baselines.\nWe compare these to\nLSTM Quartet, a model consisting of a single LSTM that\nprocesses all four voices and outputs an independent softmax over each note category, giving the model full context of the composition in progress.\nAll RNNs have 2\nlayers and 256 units, except for soloists which have 64\nunits each, and we train them with 512 steps of unrolling\nfor backpropagation through time. We train all models to\nminimize NLL using the Adam optimizer [19] and employ\nearly stopping based on the NLL of the validation set.\nWhile the DeepBach model [13] was designed for modeling the chorales of J.S. Bach, the four-voice structure of\nthose chorales is shared by NES-MDB, making the model\nappropriate for evaluation in our setting. DeepBach embeds each timestep of the four-voice score and then processes these embeddings with a bidirectional LSTM to aggregate past and future musical context. For each voice,\nthe activations of the bidirectional LSTM are concatenated\nwith an embedding of all of the other voices, providing\nthe model with a mechanism to alter its predictions for any\nvoice in context of the others at that timestep. Finally, these\nmerged representations are concatenated to an independent\nsoftmax for each of the four voices. Results for DeepBach\nand our baselines appear in Table 3.\nAs expected, the performance of all models at POIs is\nworse than the global performance. DeepBach achieves\nsubstantially better performance at POIs than the other\nmodels, likely due to its bidirectional processing which allows the model to \u201cpeek\u201d at future notes. The LSTM Quartet model is attractive because, unlike DeepBach, it permits\nefficient ancestral sampling. However, we observe qualitatively that samples from this model are musically unsatisfying. While the performance of the soloists is worse than\nthe models which examine all voices, the superior performance of the LSTM Soloists to the RNN Soloists suggests\nthat LSTMs may be beneficial in this context.\nWe also experimented with artificially emphasizing\nPOIs during training, however we found that resultant\nmodels produced unrealistically sporadic music.\nBased\non this observation, we recommend that researchers who\nstudy NES-MDB always train models with unbiased emphasis, in order to effectively capture the semantics of the\nparticular temporal discretization.\n4.2 Expressive performance experiments\nThe expressive performance task consists of learning a\nmapping from a separated score to suitable expressive\ncharacteristics. Each timestep of a separated score in NESMDB has note information (random variable N) for the\nfour instrument voices.\nAn expressive score additionally has velocity (V ) and timbre (T) information for P1,\nP2, and NO but not TR. We can express the distribution\nof performance characteristics given the composition as\nP(V, T | N). Some of our proposed solutions factorize\nthis further into a conditional autoregressive formulation\n\ufffdT\nt=1 P(Vt, Tt | N, V\u02c6t<t, T\u02c6t<t), where the model has explicit knowledge of its decisions for velocity and timbre at\nearlier timesteps.\nNotes\nLast velocity\nLast timbre\nLSTM\nBidirectional\nLSTM\nDense\nConcatenate\nConcatenate\nFigure 2:\nLSTM Note+Auto expressive performance\nmodel that observes both the score and its prior output.\nUnlike for separated composition, there are no wellestablished baselines for multi-instrumental expressive\nperformance, and thus we design several approaches.\nFor the autoregressive formulation, our most-sophisticated\nmodel (Fig. 2) uses a bidirectional LSTM to process the\nseparated score, and a forward-directional LSTM for the\nautoregressive expressive characteristics.\nThe represen-\n\fNegative log-likelihood\nAccuracy\nSingle voice\nAggregate\nSingle voice\nAggregate\nModel\nP1\nP2\nTR\nNO\nPOI\nAll\nP1\nP2\nTR\nNO\nPOI\nAll\nRandom\n4.36\n4.36\n4.49\n2.83\n16.04\n16.04\n.013\n.013\n.011\n.059\n.024\n.024\nUnigram\n4.00\n3.77\n3.01\n2.50\n13.27\n11.53\n.020\n.022\n.057\n.061\n.040\n.369\nBigram\n4.91\n4.93\n4.15\n3.52\n17.50\n3.63\n.000\n.000\n.000\n.000\n.000\n.831\nRNN Soloists\n4.92\n4.90\n3.59\n2.23\n15.64\n3.11\n.000\n.000\n.004\n.183\n.047\n.830\nLSTM Soloists\n4.60\n4.30\n3.01\n1.91\n13.82\n2.70\n.014\n.008\n.125\n.246\n.098\n.838\nLSTM Quartet\n3.87\n3.71\n2.45\n1.62\n11.65\n2.21\n.028\n.031\n.294\n.449\n.201\n.854\nDeepBach [13]\n0.82\n1.01\n0.63\n0.83\n3.28\n0.75\n.781\n.729\n.784\n.748\n.761\n.943\nTable 3: Results for separated composition experiments. For each instrument, negative log-likelihood and accuracy are calculated at points of interest (POIs). We also calculate aggregate statistics at POIs and globally (All). While DeepBach [13]\nachieves the best statistical performance, it uses future context and hence is more expensive to sample from.\nNegative log-likelihood\nAccuracy\nSingle voice\nAggregate\nSingle voice\nAggregate\nModel\nVP1\nVP2\nVNO\nTP1\nTP2\nPOI\nAll\nVP1\nVP2\nVNO\nTP1\nTP2\nPOI\nAll\nRandom\n2.77\n2.77\n2.77\n1.39\n1.39\n11.09\n11.09\n.062\n.062\n.062\n.250\n.250\n.138\n.138\nUnigram\n2.87\n2.89\n3.04\n1.35\n1.33\n11.47\n9.65\n.020\n.022\n.061\n.006\n.004\n.023\n.309\nBigram\n2.82\n2.85\n2.78\n4.27\n4.27\n17.00\n4.57\n.000\n.000\n.000\n.000\n.000\n.000\n.741\nMultiReg Note\n2.74\n2.72\n2.23\n1.27\n1.18\n10.13\n8.49\n.106\n.122\n.292\n.406\n.507\n.287\n.359\nMultiReg Note+Auto\n2.58\n2.56\n2.04\n2.90\n2.48\n12.56\n4.32\n.073\n.100\n.345\n.071\n.096\n.137\n.752\nLSTM Note\n2.68\n2.63\n2.09\n1.32\n1.21\n9.94\n8.28\n.115\n.134\n.305\n.456\n.532\n.308\n.365\nLSTM Note+Auto\n1.93\n1.89\n1.99\n2.23\n1.89\n9.93\n3.42\n.305\n.321\n.386\n.241\n.432\n.337\n.774\nTable 4: Results for expressive performance experiments evaluated at points of interest (POI). Results are broken down by\nexpression category (e.g. VNO is noise velocity, TP1 is pulse 1 timbre) and aggregated at POIs and globally (All).\ntations from the composition and autoregressive modules\nare merged and processed by an additional dense layer before projecting to six softmaxes, one for each of VP1, VP2,\nVNO, TP1, TP2, and TNO. We compare this model (LSTM\nNote+Auto) to a version which removes the autoregressive\nmodule and only sees the separated score (LSTM Note).\nWe also measure performance of simple multinomial\nregression baselines.\nThe non-autoregressive baseline\n(MultiReg Note) maps the concatenation of NP1, NP2,\nNTR, and NNO directly to the six categorical outputs representing velocity and timbre (no temporal context). An autoregressive version of this model (MultiReg Note+Auto)\ntakes additional inputs consisting of the previous timestep\nfor the six velocity and timbre categories. Additionally, we\nshow results for simple baselines (per-category unigram\nand bigram distributions) which do not consider N. Because the noise timbre field TNO is so rarely used (less than\n0.2% of all timesteps), we exclude it from our quantitative\nevaluation. Results are shown in Table 4.\nSimilarly to the musical notes in the separated composition task (Section 4.1), the high rate of NES-MDB results in substantial redundancy across timesteps. Averaged\nacross all velocity and timbre categories, any of these categories at a given timestep has a 74% chance of having the\nsame value as the previous timestep.\nThe performance of the LSTM Note model is comparable to that of the LSTM Note+Auto model at POIs,\nhowever the global performance of the LSTM Note+Auto\nmodel is substantially better. Intuitively, this suggests that\nthe score is useful for knowing when to change, while\nthe past velocity and timbre values are useful for knowing\nModel\nNES-MDB\nPM\nNH\nMD\nBC\nRandom\n61.00\n61.00\n61.00\n61.00\n61.00\nNote 1-gram [2]\n8.71\n11.05\n10.25\n11.51\n11.06\nChord 1-gram [2]\n8.76\n27.64\n5.94\n19.03\n12.22\nGMM [2]\n12.86\n15.84\n7.87\n12.20\n11.90\nNADE [2]\n8.53\n10.28\n5.48\n10.06\n7.19\nRNN [2]\n3.04\n8.37\n4.46\n8.13\n8.71\nRNN-NADE [2]\n2.62\n7.48\n2.91\n6.74\n5.83\nLSTM\n2.54\n8.31\n3.49\n6.35\n8.72\nLSTM-NADE [17]\n2.48\n7.36\n2.02\n5.02\n6.00\nTable 5: Negative log-likelihoods for various models on\nthe blended score format (Fig. 1a, Eq. 2) of NES-MDB.\nWe also show results for Piano-midi.de (PM), Nottingham\n(NH), MuseData (MD), and the chorales of J.S. Bach (BC).\nwhat value to output next. Interestingly, the MultiReg Note\nmodel has better performance at POIs than the MultiReg\nNote+Auto model. The latter overfit more quickly which\nmay explain its inferior performance despite the fact that it\nsees strictly more information than the note-only model.\n4.3 Blended composition experiments\nIn Table 5, we report the performance of several models\non the blended composition task (Eq. 2). In NES-MDB,\nblended scores consist of 88 possible notes with a maximum of three simultaneous voices (noise generator is discarded). This task, standardized in [2], does not preserve\nthe voicing of the score, and thus it is not immediately\nuseful for generating NES music. Nevertheless, modeling\nblended scores of polyphonic music has become a standard\nbenchmark for sequential models [5, 18], and NES-MDB\n\fmay be useful as a larger dataset in the same format.\nIn general, models assign higher likelihood to NESMDB than the four other datasets after training. As with\nour other two tasks, this is likely due to the fact that NESMDB is sampled at a higher temporal rate, and thus the average deviation across timesteps is lower. Due to its large\nsize, a benefit of examining NES-MDB in this context is\nthat sequential models tend to take longer to overfit the\ndataset than they do for the other four. We note that our implementations of these models may deviate slightly from\nthose of the original authors, though our models achieve\ncomparable results to those reported in [2,17] when trained\non the original datasets.\n5. RELATED WORK\nThere are several popular datasets commonly used in statistical music composition. A dataset consisting of the entirety of J.S. Bach\u2019s four-voice chorales has been extensively studied under the lenses of algorithmic composition\nand reharmonization [1, 2, 13, 14]. Like NES-MDB, this\ndataset has a fixed number of voices and can be represented as a separated score (Fig. 1b), however it is small in\nsize (389 chorales) and lacks expressive information. Another popular dataset is Piano-midi.de, a corpus of classical piano from various composers [27].\nThis dataset\nhas expressive timing and dynamics information but has\nheterogeneous time periods and only features solo piano\nmusic. Alongside Bach\u2019s chorales and the Piano-midi.de\ndataset, Boulanger-Lewandowski et al. (2012) standardized the Nottingham collection of folk tunes and MuseData\nlibrary of orchestral and piano classical music into blended\nscore format (Fig. 1a).\nSeveral other symbolic datasets exist containing both\ncompositional and expressive characteristics. The Magaloff Corpus [10] consists of Disklavier recordings of a\nprofessional pianist playing the entirety of Chopin\u2019s solo\npiano works. The Lakh MIDI dataset [28] is the largest\ncorpus of symbolic music assembled to date with nearly\n200k songs. While substantially larger than NES-MDB,\nthe dataset has unconstrained polyphony, inconsistent expressive characteristics, and encompasses a wide variety of\ngenres, instruments and time periods. Another paper trains\nneural networks on transcriptions of video game music [9],\nthough their dataset only includes a handful of songs.\n5.1 Statistical composition\nWhile most of the early research in algorithmic music\ncomposition focused on expert systems [25], statistical approaches have since become the predominant approach.\nMozer (1994) trained RNNs on monophonic melodies using a formulation similar to Eq. 1, finding the composed results to compare favorably to those from a trigram model.\nOthers have also explored monophonic melody generation\nwith RNNs [8,26]. Boulanger-Lewandowski et al. (2012)\nstandardize the polyphonic prediction task for blended\nscores (Eq. 2), measuring performance of a multitude of\nclassical baselines against RNNs [30], restricted Boltz-\nmann machines [34], and NADEs [21] on polyphonic music datasets. Several papers [5,17,35] directly compare to\ntheir results. Statistical models of music have also been\nemployed as symbolic priors to assist music transcription\nalgorithms [2,4,24].\nProgressing towards models that assist humans in composition, many researchers study models to create new\nharmonizations for existing musical material. Allan and\nWilliams (2005) train HMMs to create new harmonizations\nfor Bach chorales [1]. Hadjeres et al. (2017) train a bidirectional RNN model to consider past and future temporal\ncontext (Eq. 3) [13]. Along with [16, 31], they advocate\nfor the usage of Gibbs sampling to generate music from\ncomplex graphical models.\n5.2 Statistical performance\nMusicians perform music expressively by interpreting a\nperformance with appropriate dynamics, timing and articulation.\nComputational models of expressive music\nperformance seek to automatically assign such attributes\nto a score [36].\nWe point to several extensive surveys\nfor information about the long history of rule-based systems [7,12,20,36].\nSeveral statistical models of expressive performance\nhave also been proposed. Raphael (2010) learns a graphical model that automates an accompanying orchestra for\na soloist, operating on acoustic features rather than symbolic [29]. Flossmann et al. (2013) build a system to control velocity, articulation and timing of piano performances\nby learning a graphical model from a large symbolic corpus of human performances [11]. Xia et al. (2015) model\nthe expressive timing and dynamics of piano duet performances using spectral methods [37]. Two end-to-end systems attempt to jointly learn the semantics of composition\nand expressive performance using RNNs [23, 33]. Malik\nand Ek (2017) train an RNN to generate velocity information given a musical score [22]. These approaches differ\nfrom our own in that they focus on piano performances\nrather than multi-instrumental music.\n6. CONCLUSION\nThe NES Music Database is a large corpus for examining\nmulti-instrumental polyphonic composition and expressive\nperformance generation. Compared to existing datasets,\nNES-MDB allows for examination of the \u201cfull pipeline\u201d\nof music composition and performance.\nWe parse the\nmachine code of NES music into familiar formats (e.g.\nMIDI), eliminating the need for researchers to understand\nlow-level details of the game system.\nWe also provide\nan open-source tool which converts between the simpler\nformats and machine code, allowing researchers to audition their generated results as waveforms rendered by\nthe NES. We hope that this dataset will facilitate a new\nparadigm of research on music generation\u2014one that emphasizes the importance of expressive performance. To this\nend, we establish several baselines with reproducible evaluation methodology to encourage further investigation.\n\f7. ACKNOWLEDGEMENTS\nWe would like to thank Louis Pisha for invaluable advice\non the technical details of this project. Additionally, we\nwould like to thank Nicolas Boulanger-Lewandowski, Eunjeong Stella Koh, Steven Merity, Miller Puckette, and\nCheng-i Wang for helpful conversations throughout this\nwork. This work was supported by UC San Diego\u2019s Chancellors Research Excellence Scholarship program. GPUs\nused in this research were donated by NVIDIA.\n8. REFERENCES\n[1] Moray Allan and Christopher Williams. Harmonising chorales by probabilistic inference. In Proc. NIPS,\n2005.\n[2] Nicolas Boulanger-Lewandowski, Yoshua Bengio, and\nPascal Vincent. Modeling temporal dependencies in\nhigh-dimensional sequences:\nApplication to polyphonic music generation and transcription. In Proc.\nICML, 2012.\n[3] Jean-Pierre Briot, Ga\u00a8etan Hadjeres, and Franc\u00b8ois Pachet. Deep learning techniques for music generation-a\nsurvey. arXiv:1709.01620, 2017.\n[4] Ali Taylan Cemgil. Bayesian music transcription. PhD\nthesis, Radboud University Nijmegen, 2004.\n[5] Junyoung Chung, Caglar Gulcehre, KyungHyun Cho,\nand Yoshua Bengio. Empirical evaluation of gated\nrecurrent neural networks on sequence modeling. In\nNIPS Workshops, 2014.\n[6] Karen Collins. Game sound: an introduction to the\nhistory, theory, and practice of video game music and\nsound design. MIT Press, 2008.\n[7] Miguel Delgado, Waldo Fajardo, and Miguel MolinaSolana. A state of the art on computational music performance. Expert systems with applications, 2011.\n[8] Douglas Eck and J\u00a8urgen Schmidhuber. Finding temporal structure in music: Blues improvisation with LSTM\nrecurrent networks. In Proc. Neural Networks for Signal Processing, 2002.\n[9] Otto Fabius and Joost R van Amersfoort. Variational\nrecurrent auto-encoders. In ICLR Workshops, 2015.\n[10] Sebastian\nFlossmann,\nWerner\nGoebl,\nMaarten\nGrachten, Bernhard Niedermayer, and Gerhard Widmer. The Magaloff project: An interim report. Journal\nof New Music Research, 2010.\n[11] Sebastian Flossmann, Maarten Grachten, and Gerhard\nWidmer. Expressive performance rendering with probabilistic models. In Guide to Computing for Expressive\nMusic Performance. 2013.\n[12] Werner Goebl, Simon Dixon, Giovanni De Poli, Anders Friberg, Roberto Bresin, and Gerhard Widmer.\nSense in expressive music performance: Data acquisition, computational studies, and models. 2008.\n[13] Ga\u00a8etan Hadjeres and Franc\u00b8ois Pachet. DeepBach: A\nsteerable model for Bach chorales generation. In Proc.\nICML, 2017.\n[14] Hermann Hild, Johannes Feulner, and Wolfram Menzel. Harmonet: A neural net for harmonizing chorales\nin the style of JS Bach. In NIPS, 1992.\n[15] Sepp Hochreiter and J\u00a8urgen Schmidhuber. Long shortterm memory. Neural Computation, 1997.\n[16] Cheng-Zhi Anna Huang,\nTim Cooijmans,\nAdam\nRoberts, Aaron Courville, and Douglas Eck. Counterpoint by convolution. In Proc. ISMIR, 2017.\n[17] Daniel D Johnson. Generating polyphonic music using\ntied parallel networks. In Proc. International Conference on Evolutionary and Biologically Inspired Music\nand Art, 2017.\n[18] Rafal\nJozefowicz,\nWojciech\nZaremba,\nand\nIlya\nSutskever. An empirical exploration of recurrent network architectures. In Proc. ICML, 2015.\n[19] Diederik P Kingma and Jimmy Ba. Adam: A method\nfor stochastic optimization. arXiv:1412.6980, 2014.\n[20] Alexis Kirke and Eduardo R Miranda. An overview of\ncomputer systems for expressive music performance.\nIn Guide to computing for expressive music performance. 2013.\n[21] Hugo Larochelle and Iain Murray. The neural autoregressive distribution estimator. In Proc. AISTATS,\n2011.\n[22] Iman Malik and Carl Henrik Ek. Neural translation of\nmusical style. arXiv:1708.03535, 2017.\n[23] Huanru Henry Mao, Taylor Shin, and Garrison W.\nCottrell. DeepJ: Style-specific music generation. In\nProc. International Conference on Semantic Computing, 2018.\n[24] Juhan Nam, Jiquan Ngiam, Honglak Lee, and Malcolm Slaney. A classification-based polyphonic piano\ntranscription approach using learned feature representations. In Proc. ISMIR, 2011.\n[25] Gerhard\nNierhaus.\nAlgorithmic\ncomposition:\nparadigms of automated music generation. Springer\nScience & Business Media, 2009.\n[26] Jean-Francois Paiement, Samy Bengio, and Douglas\nEck. Probabilistic models for melodic prediction. Artificial Intelligence, 2009.\n\f[27] Graham E Poliner and Daniel PW Ellis. A discriminative model for polyphonic piano transcription.\nEURASIP Journal on Advances in Signal Processing,\n2006.\n[28] Colin Raffel. Learning-based methods for comparing\nsequences, with applications to audio-to-midi alignment and matching. Columbia University, 2016.\n[29] Christopher Raphael. Music Plus One and machine\nlearning. In Proc. ICML, 2010.\n[30] David E Rumelhart, Geoffrey E Hinton, and Ronald J\nWilliams. Learning internal representations by error\npropagation. Technical report, DTIC Document, 1985.\n[31] Jason Sakellariou, Francesca Tria, Vittorio Loreto, and\nFranc\u00b8ois Pachet. Maximum entropy model for melodic\npatterns. In ICML Workshops, 2015.\n[32] Craig Stuart Sapp. Comparative analysis of multiple\nmusical performances. In Proc. ISMIR, 2007.\n[33] Ian Simon and Sageev Oore. Performance RNN: Generating music with expressive timing and dynamics,\n2017.\n[34] Paul Smolensky. Information processing in dynamical\nsystems: Foundations of harmony theory. Technical report, DTIC Document, 1986.\n[35] Raunaq Vohra, Kratarth Goel, and JK Sahoo. Modeling\ntemporal dependencies in data using a DBN-LSTM. In\nProc. IEEE Conference on Data Science and Advanced\nAnalytics, 2015.\n[36] Gerhard Widmer and Werner Goebl. Computational\nmodels of expressive music performance: The state of\nthe art. Journal of New Music Research, 2004.\n[37] Guangyu Xia, Yun Wang, Roger B Dannenberg, and\nGeoffrey Gordon. Spectral learning for expressive interactive ensemble music performance. In Proc. ISMIR, 2015.\n\f", "text_mmd": "[MISSING_PAGE_FAIL:1]\n\nof a sequence \\(\\mathbf{c}\\) (length \\(T\\)) might be factorized as\n\n\\[P(\\mathbf{c})=P(n_{1})\\cdot P(n_{2}\\mid n_{1})\\cdot\\ldots\\cdot P(n_{T}\\mid n_{t<T}). \\tag{1}\\]\n\n### Blended composition\n\nWhile Eq. 1 may be appropriate for modeling compositions for monophonic instruments, in this work we are interested in the problem of multi-instrumental _polynohonic_ composition, where multiple monophonic instrument _voices_ may be sounding simultaneously. Much of the prior research on this topic [17, 2, 5] represents music in a blended score representation. A blended score \\(B\\) is a sparse binary matrix of size \\(N\\times T\\), where \\(N\\) is the number of possible note values, and \\(B[n,t]=1\\) if any voice is playing note \\(n\\) at timestep \\(t\\) or \\(0\\) otherwise (Fig. 0(a)). Often, \\(N\\) is constrained to the \\(88\\) keys on a piano keyboard, and \\(T\\) is determined by some subdivision of the meter, such as sixteenth notes. When polyphonic composition \\(\\mathbf{c}\\) is represented by \\(B\\), statistical models often factorize the distribution as a sequence of _chords_, the columns \\(B_{t}\\):\n\n\\[P(\\mathbf{c})=P(B_{1})\\cdot P(B_{2}\\mid B_{1})\\cdot\\ldots\\cdot P(B_{T}\\mid B_{t<T}). \\tag{2}\\]\n\nThis representation simplifies the probabilistic framework of the task, but it is problematic for music with multiple instruments (such as the music in NES-MDB). Resultant systems must provide an additional mechanism for assigning notes of a blended score to instrument voices, or otherwise render the music on polyphonic instruments such as the piano.\n\n### Separated composition\n\nGiven the shortcomings of the blended score, we might prefer models which operate on a separated score representation (Fig. 0(b)). A separated score \\(S\\) is a matrix of size \\(V\\times T\\), where \\(V\\) is the number of instrument voices, and \\(S[v,t]=n\\), the note \\(n\\) played by voice \\(v\\) at timestep \\(t\\). In other words, the format encodes a monophonic sequence for each instrument voice. Statistical approaches to this representation can explicitly model the relationships between various instrument voices by\n\n\\[P(\\mathbf{c})=\\prod_{t=1}^{T}\\prod_{v=1}^{V}P(S_{v,t}\\mid S_{v,t\\neq t},S_{\\phi \\neq v,\\forall t}). \\tag{3}\\]\n\nThis formulation explicitly models the dependencies between \\(S_{v,t}\\), voice \\(v\\) at time \\(t\\), and every other note in the score. For this reason, Eq. 3 more closely resembles the process by which human composers write multi-instrumental music, incorporating temporal and contrapuntal information. Another benefit is that resultant models can be used to harmonize with existing musical material, adding voices conditioned on existing ones. However, any non-trivial amount of temporal context introduces high-dimensional interdependencies, meaning that such a formulation would be challenging to sample from. As a consequence, solutions are often restricted to only take past temporal context into account, allowing for simple and efficient ancestral sampling (though Gibbs sampling can also be used to sample from Eq. 3[13, 16]).\n\nMost existing datasets of multi-instrumental music have uninhibited polyphony, causing a separated score representation to be inappropriate. However, the hardware constraints of the NES APU impose a strict limit on the number of voices, making the format ideal for NES-MDB.\n\n### Expressive performance\n\nGiven a piece of a music, a skilled performer will embellish the piece with _expressive characteristics_, altering the timing and dynamics to deliver a compelling rendition. While a few instruments have been augmented to capture this type of information symbolically (e.g. a Disklavier), it is rarely available for examination in datasets of multi-instrumental music. Because NES music is comprised of instructions that recreate an exact rendition of each piece, expressive characteristics controlling the velocity and timbre of each voice are available in NES-MDB (details in Section 3.1). Thus, each piece can be represented as an _expressive score_ (Fig. 0(c)), the union of its separated score and expressive characteristics.\n\nWe consider the task of mapping a composition \\(\\mathbf{c}\\) onto expressive characteristics \\(\\mathbf{e}\\). Hence, we would like to model \\(P(\\mathbf{e}\\mid\\mathbf{c})\\), and the probability of a piece of music \\(P(\\mathbf{m})\\) can be expressed as \\(P(\\mathbf{e}\\mid\\mathbf{c})\\cdot P(\\mathbf{c})\\), where \\(P(\\mathbf{c})\\) is from Eq. 3. This allows for a convenient pipeline for music generation where a piece of music is first composed with binary amplitudes and then mapped to realistic dynamics, as if interpreted by a performer.\n\nFigure 1: Three representations (rendered as piano rolls) for a segment of _Ending Theme_ from _Abadox_ (1989) by composer Kiyohiro Sada. The blended score (Fig. 0(a)), used in prior polyphonic composition research, is degenerate when multiple voices play the same note.\n\n### Task summary\n\nIn summary, we propose three tasks for which NES-MDB serves as a large test bed. A pairing of two models that address the second and third tasks can be used to generate novel NES music.\n\n1. The _blended composition_ task (Eq. 2) models the semantics of blended scores (Fig. 1a). This task is more useful for benchmarking new algorithms than for NES composition.\n2. The _separated composition_ task consists of modeling the semantics of separated scores (Fig. 1b) using the factorization from Eq. 3.\n3. The _expressive performance_ task seeks to map separated scores to expressive characteristics needed to generate an expressive score (Fig. 1c).\n\n## 3 Dataset description\n\nThe NES APU consists of five monophonic instruments: two pulse wave generators (P1/P2), a triangle wave generator (TR), a noise generator (NO), and a sampler which allows for playback of audio waveforms stored in memory. Because the sampler may be used to play melodic or percussive sounds, its usage is compositionally ambiguous and we exclude it from our dataset.\n\nIn raw form, music for NES games exists as machine code living in the read-only memory of cartridges, entangled with the rest of the game logic. An effective method for extracting a musical transcript is to emulate the game and log the timing and values of writes to the APU registers. The video game music (VGM) format 3 was designed for precisely this purpose, and consists of an ordered list of writes to APU registers with \\(44.1\\,\\mathrm{kHz}\\) timing resolution. An online repository 4 contains over \\(400\\) NES games logged in this format. After removing duplicates, we split these games into distinct training, validation and test subsets with an \\(8\\):\\(1\\):\\(1\\) ratio, ensuring that no composer appears in two of the subsets. Basic statistics of the dataset appear in Table 1.\n\nFootnote 3: [http://vgmrips.net/wiki/VGM_Specification](http://vgmrips.net/wiki/VGM_Specification)\n\nFootnote 4: [http://vgmrips.net/packs/chip/nes-apu](http://vgmrips.net/packs/chip/nes-apu)\n\n### Extracting expressive scores\n\nGiven the VGM files, we emulate the functionality of the APU to yield an expressive score (Fig. 1c) at a temporal discretization of \\(44.1\\,\\mathrm{kHz}\\). This rate is unnecessarily high for symbolic music, so we subsequently downsample the scores.5 Because the music has no explicit tempo markings, we accommodate a variety of implicit tempos by choosing a permissive downsampling rate of \\(24\\,\\mathrm{Hz}\\). By removing dynamics, timbre, and voicing at each timestep, we derive separated score (Fig. 1b) and blended score (Fig. 1a) versions of the dataset.\n\nFootnote 5: We also release NES-MDB in MIDI format with no downsampling\n\nIn Table 2, we show the dimensionality of the instrument states at each timestep of an expressive score in NES-MDB. We constrain the frequency ranges of the _melodic_ voices (pulse and triangle generators) to the MIDI notes on an \\(88\\)-key piano keyboard (\\(21\\) through \\(108\\) inclusive, though the pulse generators cannot produce pitches below MIDI note \\(32\\)). The _percussive_ noise voice has \\(16\\) possible \"notes\" (these do not correspond to MIDI note numbers) where higher values have more high-frequency noise. For all instruments, a note value of \\(0\\) indicates that the instrument is not sounding (and the corresponding velocity will be \\(0\\)). When sounding, the pulse and noise generators have \\(15\\) non-linear velocity values, while the triangle generator has no velocity control beyond on or off.\n\nAdditionally, the pulse wave generators have \\(4\\) possible duty cycles (affecting timbre), and the noise generator has a rarely-used mode where it instead produces metallic tones. Unlike for velocity, a timbre value of \\(0\\) corresponds to an actual timbre setting and does not indicate that an instrument is muted. In total, the pulse, triangle and noise generators have state spaces of sizes \\(4621\\), \\(89\\), and \\(481\\) respectively--around \\(40\\) bits of information per timestep for the full ensemble.\n\n## 4 Experiments and discussion\n\nBelow, we describe our evaluation criteria for experiments in separated composition and expressive performance. We present these results only as statistical baselines for comparison; results do not necessarily reflect a model's ability to generate compelling musical examples.\n\n**Negative log-likelihood and Accuracy** Negative log-likelihood (NLL) is the (log of the) likelihood that a model assigns to unseen real data (as per Eq. 3). A low NLL averaged across unseen data may indicate that a model captures\n\n\\begin{table}\n\\begin{tabular}{l|r} \\hline \\hline \\# Games & \\(397\\) \\\\ \\# Composers & \\(296\\) \\\\ \\# Songs & \\(5,278\\) \\\\ \\# Songs w/ length \\(>10\\)s & \\(3,513\\) \\\\ \\# Notes & \\(2,325,636\\) \\\\ Dataset length & \\(46.1\\) hours \\\\ \\(P(\\)Pulse 1 On\\()\\) & \\(0.861\\) \\\\ \\(P(\\)Pulse 2 On\\()\\) & \\(0.838\\) \\\\ \\(P(\\)Triangle On\\()\\) & \\(0.701\\) \\\\ \\(P(\\)Noise On\\()\\) & \\(0.390\\) \\\\ Average polyphony & \\(2.789\\) \\\\ \\hline \\hline \\end{tabular}\n\\end{table}\nTable 1: Basic dataset information for NES-MDB.\n\n\\begin{table}\n\\begin{tabular}{c|c c c} \\hline \\hline Instrument & Note & Velocity & Timbre \\\\ \\hline Pulse \\(1\\) (P1) & \\(\\{0,32,\\ldots,108\\}\\) & \\([0,15]\\) & \\([0,3]\\) \\\\ Pulse \\(2\\) (P2) & \\(\\{0,32,\\ldots,108\\}\\) & \\([0,15]\\) & \\([0,3]\\) \\\\ Triangle (TR) & \\(\\{0,21,\\ldots,108\\}\\) & & \\\\ Noise (NO) & \\(\\{0,1,\\ldots,16\\}\\) & \\([0,15]\\) & \\([0,1]\\) \\\\ \\hline \\hline \\end{tabular}\n\\end{table}\nTable 2: Dimensionality for each timestep of the expressive score representation (Fig. 1c) in NES-MDB.\n\nsemantics of the data distribution. Accuracy is defined as the proportion of timesteps where a model's prediction is equal to the actual composition. We report both measures for each voice, as well as aggregations across all voices by summing (for NLL) and averaging (for accuracy).\n\n**Points of Interest (POI).** Unlike other datasets of symbolic music, NES-MDB is temporally-discretized at a high, fixed rate (\\(24\\,\\mathrm{Hz}\\)), rather than at a variable rate depending on the tempo of the music. As a consequence, any given voice has around an \\(83\\%\\) chance of playing the same note as that voice at the previous timestep. Accordingly, our primary evaluation criteria focuses on musically-salient _points of interest_ (POIs), timesteps at which a voice deviates from the previous timestep (the beginning or end of a note). This evaluation criterion is mostly invariant to the rate of temporal discretization.\n\n### Separated composition experiments\n\nFor separated composition, we evaluate the performance of several baselines and compare them to a cutting edge method. Our simplest baselines are unigram and additive-smoothed bigram distributions for each instrument. The predictions of such models are trivial; the unigram model always predicts \"no note\" and the bigram model always predicts \"last note\". The respective accuracy of these models, \\(37\\%\\) and \\(83\\%\\), reflect the proportion of the timesteps that are silent (unigram) or identical to the last timestep (bigram). However, if we evaluate these models only at POIs, their performance is substantially worse (\\(4\\%\\) and \\(0\\%\\)).\n\nWe also measure performance of recurrent neural networks (RNNs) at modeling the voices independently. We train a separate RNN (either a basic RNN cell or an LSTM cell [15]) on each voice to form our RNN Soloists and LSTM Soloists baselines. We compare these to LSTM Quartet, a model consisting of a single LSTM that processes all four voices and outputs an independent softmax over each note category, giving the model full context of the composition in progress. All RNNs have \\(2\\) layers and \\(256\\) units, except for soloists which have \\(64\\) units each, and we train them with \\(512\\) steps of unrolling for backpropagation through time. We train all models to minimize NLL using the Adam optimizer [19] and employ early stopping based on the NLL of the validation set.\n\nWhile the DeepBach model [13] was designed for modeling the chorales of J.S. Bach, the four-voice structure of those chorales is shared by NES-MDB, making the model appropriate for evaluation in our setting. DeepBach embeds each timestep of the four-voice score and then processes these embeddings with a bidirectional LSTM to aggregate past and future musical context. For each voice, the activations of the bidirectional LSTM are concatenated with an embedding of all of the other voices, providing the model with a mechanism to alter its predictions for any voice in context of the others at that timestep. Finally, these merged representations are concatenated to an independent softmax for each of the four voices. Results for DeepBach and our baselines appear in Table 3.\n\nAs expected, the performance of all models at POIs is worse than the global performance. DeepBach achieves substantially better performance at POIs than the other models, likely due to its bidirectional processing which allows the model to \"peek\" at future notes. The LSTM Quartet model is attractive because, unlike DeepBach, it permits efficient ancestral sampling. However, we observe qualitatively that samples from this model are musically unsatisfying. While the performance of the soloists is worse than the models which examine all voices, the superior performance of the LSTM Soloists to the RNN Soloists suggests that LSTMs may be beneficial in this context.\n\nWe also experimented with artificially emphasizing POIs during training, however we found that resultant models produced unrealistically sporadic music. Based on this observation, we recommend that researchers who study NES-MDB always train models with unbiased emphasis, in order to effectively capture the semantics of the particular temporal discretization.\n\n### Expressive performance experiments\n\nThe expressive performance task consists of learning a mapping from a separated score to suitable expressive characteristics. Each timestep of a separated score in NES-MDB has note information (random variable \\(N\\)) for the four instrument voices. An expressive score additionally has velocity (\\(V\\)) and timbre (\\(T\\)) information for P1, P2, and NO but not TR. We can express the distribution of performance characteristics given the composition as \\(P(V,\\ T\\ |\\ N)\\). Some of our proposed solutions factorize this further into a conditional autoregressive formulation \\(\\prod_{t=1}^{T}P(V_{t},T_{t}\\ |\\ N,V_{t<t},T_{t<t})\\), where the model has explicit knowledge of its decisions for velocity and timbre at earlier timesteps.\n\nUnlike for separated composition, there are no well-established baselines for multi-instrumental expressive performance, and thus we design several approaches. For the autoregressive formulation, our most-sophisticated model (Fig. 2) uses a bidirectional LSTM to process the separated score, and a forward-directional LSTM for the autoregressive expressive cha\n\nFigure 2: LSTM Note+Auto expressive performance model that observes both the score and its prior output.\n\ntations from the composition and autoregressive modules are merged and processed by an additional dense layer before projecting to six softmaxes, one for each of \\(V_{\\text{P1}}\\), \\(V_{\\text{P2}}\\), \\(V_{\\text{NO}}\\), \\(T_{\\text{P1}}\\), \\(T_{\\text{P2}}\\), and \\(T_{\\text{NO}}\\). We compare this model (LSTM Note+Auto) to a version which removes the autoregressive module and only sees the separated score (LSTM Note).\n\nWe also measure performance of simple multinomial regression baselines. The non-autoregressive baseline (MultiReg Note) maps the concatenation of \\(N_{\\text{P1}}\\), \\(N_{\\text{P2}}\\), \\(N_{\\text{TR}}\\), and \\(N_{\\text{NO}}\\) directly to the six categorical outputs representing velocity and timbre (no temporal context). An autoregressive version of this model (MultiReg Note+Auto) takes additional inputs consisting of the previous timestep for the six velocity and timbre categories. Additionally, we show results for simple baselines (per-category unigram and bigram distributions) which do not consider \\(N\\). Because the noise timbre field \\(T_{\\text{NO}}\\) is so rarely used (less than \\(0.2\\%\\) of all timesteps), we exclude it from our quantitative evaluation. Results are shown in Table 4.\n\nSimilarly to the musical notes in the separated composition task (Section 4.1), the high rate of NES-MDB results in substantial redundancy across timesteps. Averaged across all velocity and timbre categories, any of these categories at a given timestep has a \\(74\\%\\) chance of having the same value as the previous timestep.\n\nThe performance of the LSTM Note model is comparable to that of the LSTM Note+Auto model at POIs, however the global performance of the LSTM Note+Auto model is substantially better. Intuitively, this suggests that the score is useful for knowing _when_ to change, while the past velocity and timbre values are useful for knowing _what_ value to output next. Interestingly, the MultiReg Note model has better performance at POIs than the MultiReg Note+Auto model. The latter overfit more quickly which may explain its inferior performance despite the fact that it sees strictly more information than the note-only model.\n\n### Blended composition experiments\n\nIn Table 5, we report the performance of several models on the blended composition task (Eq. 2). In NES-MDB, blended scores consist of \\(88\\) possible notes with a maximum of three simultaneous voices (noise generator is discarded). This task, standardized in [2], does not preserve the voicing of the score, and thus it is not immediately useful for generating NES music. Nevertheless, modeling blended scores of polyphonic music has become a standard benchmark for sequential models [18, 5], and NES-MDB\n\n\\begin{table}\n\\begin{tabular}{l c c c c c c c c c c c c c c} \\hline \\hline  & \\multicolumn{8}{c}{Negative log-likelihood} & \\multicolumn{8}{c}{Accuracy} \\\\  & \\multicolumn{8}{c}{Single voice} & \\multicolumn{8}{c}{Aggregate} & \\multicolumn{8}{c}{Single voice} & \\multicolumn{8}{c}{Aggregate} \\\\ \\cline{2-13} Model & \\(V_{\\text{P1}}\\) & \\(V_{\\text{P2}}\\) & \\(V_{\\text{NO}}\\) & \\(T_{\\text{P1}}\\) & \\(T_{\\text{P2}}\\) & POI & All & \\(V_{\\text{P1}}\\) & \\(V_{\\text{P2}}\\) & \\(V_{\\text{NO}}\\) & \\(T_{\\text{P1}}\\) & \\(T_{\\text{P2}}\\) & POI & All \\\\ \\hline Random & \\(2.77\\) & \\(2.77\\) & \\(2.77\\) & \\(1.39\\) & \\(1.39\\) & \\(11.09\\) & \\(11.09\\) & \\(.062\\) & \\(.062\\) & \\(.062\\) & \\(.250\\) & \\(.250\\) & \\(.138\\) & \\(.138\\) \\\\ Unigram & \\(2.87\\) & \\(2.89\\) & \\(3.04\\) & \\(1.35\\) & \\(1.33\\) & \\(11.47\\) & \\(9.65\\) & \\(.020\\) & \\(.022\\) & \\(.061\\) & \\(.006\\) & \\(.004\\) & \\(.023\\) & \\(.309\\) \\\\ Bigram & \\(2.82\\) & \\(2.85\\) & \\(2.78\\) & \\(4.27\\) & \\(4.27\\) & \\(17.00\\) & \\(4.57\\) & \\(.000\\) & \\(.000\\) & \\(.000\\) & \\(.000\\) & \\(.000\\) & \\(.000\\) & \\(.741\\) \\\\ MultiReg Note & \\(2.74\\) & \\(2.72\\) & \\(2.23\\) & \\(1.27\\) & \\(1.18\\) & \\(10.13\\) & \\(8.49\\) & \\(.106\\) & \\(.122\\) & \\(.292\\) & \\(.406\\) & \\(.507\\) & \\(.287\\) & \\(.359\\) \\\\ MultiReg Note+Auto & \\(2.58\\) & \\(2.56\\) & \\(2.04\\) & \\(2.90\\) & \\(2.48\\) & \\(12.56\\) & \\(4.32\\) & \\(.073\\) & \\(.100\\) & \\(.345\\) & \\(.071\\) & \\(.096\\) & \\(.137\\) & \\(.752\\) \\\\ LSTM Note & \\(2.68\\) & \\(2.63\\) & \\(2.09\\) & \\(1.32\\) & \\(1.21\\) & \\(9.94\\) & \\(8.28\\) & \\(.115\\) & \\(.134\\) & \\(.305\\) & \\(.456\\) & \\(.532\\) & \\(.308\\) & \\(.365\\) \\\\ LSTM Note+Auto & \\(1.93\\) & \\(1.89\\) & \\(1.99\\) & \\(2.23\\) & \\(1.89\\) & \\(9.93\\) & \\(3.42\\) & \\(.305\\) & \\(.321\\) & \\(.386\\) & \\(.241\\) & \\(.432\\) & \\(.337\\) & \\(.774\\) \\\\ \\hline \\hline \\end{tabular}\n\\end{table}\nTable 4: Results for expressive performance experiments evaluated at points of interest (POI). Results are broken down by expression category (e.g. \\(V_{\\text{NO}}\\) is noise velocity, \\(T_{\\text{P1}}\\) is pulse 1 timbre) and aggregated at POIs and globally (All).\n\n\\begin{table}\n\\begin{tabular}{l c c c c c c c c c c c c} \\hline \\hline  & \\multicolumn{8}{c}{Negative log-likelihood} & \\multicolumn{8}{c}{Accuracy} \\\\  & \\multicolumn{8}{c}{Single voice} & \\multicolumn{8}{c}{Aggregate} & \\multicolumn{8}{c}{Single voice} & \\multicolumn{8}{c}{Aggregate} \\\\ \\cline{2-13} Model & P1 & P2 & TR & NO & POI & All & P1 & P2 & TR & NO & POI & All \\\\ \\hline Random & \\(4.36\\) & \\(4.36\\) & \\(4.49\\) & \\(2.83\\) & \\(16.04\\) & \\(16.04\\) & \\(.013\\) & \\(.013\\) & \\(.011\\) & \\(.059\\) & \\(.024\\) & \\(.024\\) \\\\ Unigram & \\(4.00\\) & \\(3.77\\) & \\(3.01\\) & \\(2.50\\) & \\(13.27\\) & \\(11.53\\) & \\(.020\\) & \\(.022\\) & \\(.057\\) & \\(.061\\) & \\(.040\\) & \\(.369\\) \\\\ Bigram & \\(4.91\\) & \\(4.93\\) & \\(4.15\\) & \\(3.52\\) & \\(17.50\\) & \\(3.63\\) & \\(.000\\) & \\(.000\\) & \\(.000\\) & \\(.000\\) & \\(.000\\) & \\(.831\\) \\\\ RNN Solists & \\(4.92\\) & \\(4.90\\) & \\(3.59\\) & \\(2.23\\) & \\(15.64\\) & \\(3.11\\) & \\(.000\\) & \\(.000\\) & \\(.004\\) & \\(.183\\) & \\(.047\\) & \\(.830\\) \\\\ LSTM Solists & \\(4.60\\) & \\(4.30\\) & \\(3.01\\) & \\(1.91\\) & \\(13.82\\) & \\(2.70\\) & \\(.014\\) & \\(.008\\) & \\(.125\\) & \\(.246\\) & \\(.098\\) & \\(.838\\) \\\\ LSTM Quarter & \\(3.87\\) & \\(3.71\\) & \\(2.45\\) & \\(1.62\\) & \\(11.65\\) & \\(2.21\\) & \\(.028\\) & \\(.031\\) & \\(.294\\) & \\(.449\\) & \\(.201\\) & \\(.854\\) \\\\ DeepBach [13] & \\(0.82\\) & \\(1.01\\) & \\(0.63\\) & \\(0.83\\) & \\(3.28\\) & \\(0.75\\) & \\(.781\\) & \\(.729\\) & \\(.784\\) & \\(.748\\) & \\(.761\\) & \\(.943\\) \\\\ \\hline \\hline \\end{tabular}\n\\end{table}\nTable 3: Results for separated composition experiments. For each instrument, negative log-likelihood and accuracy are calculated at points of interest (POIs). We also calculate aggregate statistics at POIs and globally (All). While DeepBach [13] achieves the best statistical performance, it uses future context and hence is more expensive to sample from.\n\n\\begin{table}\n\\begin{tabular}{l c c c c c c} \\hline \\hline Model & NES-MDB & PM & NH & MD & BC \\\\ \\hline Random & \\(61.00\\) & \\(61.00\\) & \\(61.00\\) & \\(61.00\\) & \\(61.00\\) \\\\ Note 1-gram [2] & \\(8.71\\) & \\(11.05\\) & \\(10.25\\) & \\(11.51\\) & \\(11.06\\) \\\\ Chord 1-gram [2] & \\(8.76\\) & \\(27.64\\) & \\(5.94\\) & \\(19.03\\) & \\(12.22\\) \\\\ GMM [2] & \\(12.86\\) & \\(15.84\\) & \\(7.87\\) & \\(12.20\\) & \\(11.90\\) \\\\ NADER [2] & \\(8.53\\) & \\(10.28\\) & \\(5.48\\) & \\(10.06\\) & \\(7.19\\) \\\\ RNN [2] & \\(3.04\\) & \\(8.37\\) & \\(4.46\\) & \\(8.13\\) & \\(8.71\\) \\\\ RNN-NADE [2] & \\(2.62\\) & \\(7.48\\) & \\(2.91\\) & \\(6.74\\) & \\(5.83\\) \\\\ LSTM & \\(2.54may be useful as a larger dataset in the same format.\n\nIn general, models assign higher likelihood to NES-MDB than the four other datasets after training. As with our other two tasks, this is likely due to the fact that NES-MDB is sampled at a higher temporal rate, and thus the average deviation across timesteps is lower. Due to its large size, a benefit of examining NES-MDB in this context is that sequential models tend to take longer to overfit the dataset than they do for the other four. We note that our implementations of these models may deviate slightly from those of the original authors, though our models achieve comparable results to those reported in [2, 17] when trained on the original datasets.\n\n## 5 Related Work\n\nThere are several popular datasets commonly used in statistical music composition. A dataset consisting of the entirety of J.S. Bach's four-voice chorales has been extensively studied under the lenses of algorithmic composition and reharmonization [1, 2, 13, 14]. Like NES-MDB, this dataset has a fixed number of voices and can be represented as a separated score (Fig. 1b), however it is small in size (\\(389\\) chorales) and lacks expressive information. Another popular dataset is Piano-midi.de, a corpus of classical piano from various composers [27]. This dataset has expressive timing and dynamics information but has heterogeneous time periods and only features solo piano music. Alongside Bach's chorales and the Piano-midi.de dataset, Boulanger-Lewandowski et al. (2012) standardized the Nottingham collection of folk tunes and MuseData library of orchestral and piano classical music into blended score format (Fig. 1a).\n\nSeveral other symbolic datasets exist containing both compositional and expressive characteristics. The Magaloff Corpus [10] consists of Disklavier recordings of a professional pianist playing the entirety of Chopin's solo piano works. The Lakh MIDI dataset [28] is the largest corpus of symbolic music assembled to date with nearly \\(200\\)k songs. While substantially larger than NES-MDB, the dataset has unconstrained polyphony, inconsistent expressive characteristics, and encompasses a wide variety of genres, instruments and time periods. Another paper trains neural networks on transcriptions of video game music [9], though their dataset only includes a handful of songs.\n\n### Statistical composition\n\nWhile most of the early research in algorithmic music composition focused on expert systems [25], statistical approaches have since become the predominant approach. Mozer (1994) trained RNNs on monophonic melodies using a formulation similar to Eq. 1, finding the composed results to compare favorably to those from a trigram model. Others have also explored monophonic melody generation with RNNs [26, 8]. Boulanger-Lewandowski et al. (2012) standardize the polyphonic prediction task for blended scores (Eq. 2), measuring performance of a multitude of classical baselines against RNNs [30], restricted Boltzmann machines [34], and NADEs [21] on polyphonic music datasets. Several papers [17, 35, 5] directly compare to their results. Statistical models of music have also been employed as symbolic priors to assist music transcription algorithms [2, 4, 24].\n\nProgressing towards models that _assist_ humans in composition, many researchers study models to create new harmonizations for existing musical material. Allan and Williams (2005) train HMMs to create new harmonizations for Bach chorales [1]. Hadjeres et al. (2017) train a bidirectional RNN model to consider past and future temporal context (Eq. 3) [13]. Along with [16, 31], they advocate for the usage of Gibbs sampling to generate music from complex graphical models.\n\n### Statistical performance\n\nMusicians perform music expressively by interpreting a performance with appropriate dynamics, timing and articulation. Computational models of expressive music performance seek to automatically assign such attributes to a score [36]. We point to several extensive surveys for information about the long history of rule-based systems [12, 7, 36, 20].\n\nSeveral statistical models of expressive performance have also been proposed. Raphael (2010) learns a graphical model that automates an accompanying orchestra for a soloist, operating on acoustic features rather than symbolic [29]. Flossmann et al. (2013) build a system to control velocity, articulation and timing of piano performances by learning a graphical model from a large symbolic corpus of human performances [11]. Xia et al. (2015) model the expressive timing and dynamics of piano duet performances using spectral methods [37]. Two end-to-end systems attempt to jointly learn the semantics of composition and expressive performance using RNNs [23, 33]. Malik and Ek (2017) train an RNN to generate velocity information given a musical score [22]. These approaches differ from our own in that they focus on piano performances rather than multi-instrumental music.\n\n## 6 Conclusion\n\nThe NES Music Database is a large corpus for examining multi-instrumental polyphonic composition and expressive performance generation. Compared to existing datasets, NES-MDB allows for examination of the \"full pipeline\" of music composition and performance. We parse the machine code of NES music into familiar formats (e.g. MIDI), eliminating the need for researchers to understand low-level details of the game system. We also provide an open-source tool which converts between the simpler formats and machine code, allowing researchers to audition their generated results as waveforms rendered by the NES. We hope that this dataset will facilitate a new paradigm of research on music generation--one that emphasizes the importance of expressive performance. To this end, we establish several baselines with reproducible evaluation methodology to encourage further investigation.\n\n## 7 Acknowledgements\n\nWe would like to thank Louis Pisha for invaluable advice on the technical details of this project. Additionally, we would like to thank Nicolas Boulanger-Lewandowski, Eunjeong Stella Koh, Steven Merity, Miller Puckette, and Cheng-i Wang for helpful conversations throughout this work. This work was supported by UC San Diego's Chancellors Research Excellence Scholarship program. GPUs used in this research were donated by NVIDIA.\n\n## References\n\n* [1] Moray Allan and Christopher Williams. Harmonising chorales by probabilistic inference. In _Proc. NIPS_, 2005.\n* [2] Nicolas Boulanger-Lewandowski, Yoshua Bengio, and Pascal Vincent. Modeling temporal dependencies in high-dimensional sequences: Application to polyphonic music generation and transcription. In _Proc. ICML_, 2012.\n* [3] Jean-Pierre Briot, Gaetan Hadjeres, and Francois Pachet. Deep learning techniques for music generation-a survey. _arXiv:1709.01620_, 2017.\n* [4] Ali Taylan Cemgil. Bayesian music transcription. _PhD thesis, Radboud University Nijmegen_, 2004.\n* [5] Junyoung Chung, Caglar Gulcehre, KyungHyun Cho, and Yoshua Bengio. Empirical evaluation of gated recurrent neural networks on sequence modeling. In _NIPS Workshops_, 2014.\n* [6] Karen Collins. _Game sound: an introduction to the history, theory, and practice of video game music and sound design_. MIT Press, 2008.\n* [7] Miguel Delgado, Waldo Fajardo, and Miguel Molina-Solana. A state of the art on computational music performance. _Expert systems with applications_, 2011.\n* [8] Douglas Eck and Jurgen Schmidhuber. Finding temporal structure in music: Blues improvisation with LSTM recurrent networks. In _Proc. Neural Networks for Signal Processing_, 2002.\n* [9] Otto Fabius and Joost R van Amersfoort. Variational recurrent auto-encoders. In _ICLR Workshops_, 2015.\n* [10] Sebastian Flossmann, Werner Goebl, Maarten Grachten, Bernhard Niedermayer, and Gerhard Widmer. The Magaloff project: An interim report. _Journal of New Music Research_, 2010.\n* [11] Sebastian Flossmann, Maarten Grachten, and Gerhard Widmer. Expressive performance rendering with probabilistic models. In _Guide to Computing for Expressive Music Performance_. 2013.\n* [12] Werner Goebl, Simon Dixon, Giovanni De Poli, Anders Friberg, Roberto Bresin, and Gerhard Widmer. Sense in expressive music performance: Data acquisition, computational studies, and models. 2008.\n* [13] Gaetan Hadjeres and Francois Pachet. DeepBach: A steerable model for Bach chorales generation. In _Proc. ICML_, 2017.\n* [14] Hermann Hild, Johannes Feulner, and Wolfram Menzel. Harmonet: A neural net for harmonizing chorales in the style of JS Bach. In _NIPS_, 1992.\n* [15] Sepp Hochreiter and Jurgen Schmidhuber. Long short-term memory. _Neural Computation_, 1997.\n* [16] Cheng-Zhi Anna Huang, Tim Cooijmans, Adam Roberts, Aaron Courville, and Douglas Eck. Counterpoint by convolution. In _Proc. ISMIR_, 2017.\n* [17] Daniel D Johnson. Generating polyphonic music using tied parallel networks. In _Proc. International Conference on Evolutionary and Biologically Inspired Music and Art_, 2017.\n* [18] Rafal Jozefowicz, Wojciech Zaremba, and Ilya Sutskever. An empirical exploration of recurrent network architectures. In _Proc. ICML_, 2015.\n* [19] Diederik P Kingma and Jimmy Ba. Adam: A method for stochastic optimization. _arXiv:1412.6980_, 2014.\n* [20] Alexis Kirke and Eduardo R Miranda. An overview of computer systems for expressive music performance. In _Guide to computing for expressive music performance_. 2013.\n* [21] Hugo Larochelle and Iain Murray. The neural autoregressive distribution estimator. In _Proc. AISTATS_, 2011.\n* [22] Iman Malik and Carl Henrik Ek. Neural translation of musical style. _arXiv:1708.03535_, 2017.\n* [23] Huanru Henry Mao, Taylor Shin, and Garrison W. Cottrell. DeepJ: Style-specific music generation. In _Proc. International Conference on Semantic Computing_, 2018.\n* [24] Juhan Nam, Jiquan Ngiam, Honglak Lee, and Malcolm Slaney. A classification-based polyphonic piano transcription approach using learned feature representations. In _Proc. ISMIR_, 2011.\n* [25] Gerhard Nierhaus. _Algorithmic composition: paradigms of automated music generation_. Springer Science & Business Media, 2009.\n* [26] Jean-Francois Paiement, Samy Bengio, and Douglas Eck. Probabilistic models for melodic prediction. _Artificial Intelligence_, 2009.\n\n* [27] Graham E Poliner and Daniel PW Ellis. A discriminative model for polyphonic piano transcription. _EURASIP Journal on Advances in Signal Processing_, 2006.\n* [28] Colin Raffel. _Learning-based methods for comparing sequences, with applications to audio-to-midi alignment and matching_. Columbia University, 2016.\n* [29] Christopher Raphael. Music Plus One and machine learning. In _Proc. ICML_, 2010.\n* [30] David E Rumelhart, Geoffrey E Hinton, and Ronald J Williams. Learning internal representations by error propagation. Technical report, DTIC Document, 1985.\n* [31] Jason Sakellariou, Francesca Tria, Vittorio Loreto, and Francois Pachet. Maximum entropy model for melodic patterns. In _ICML Workshops_, 2015.\n* [32] Craig Stuart Sapp. Comparative analysis of multiple musical performances. In _Proc. ISMIR_, 2007.\n* [33] Ian Simon and Sageev Oore. Performance RNN: Generating music with expressive timing and dynamics, 2017.\n* [34] Paul Smolensky. Information processing in dynamical systems: Foundations of harmony theory. Technical report, DTIC Document, 1986.\n* [35] Raunaq Vohra, Kratarth Goel, and JK Sahoo. Modeling temporal dependencies in data using a DBN-LSTM. In _Proc. IEEE Conference on Data Science and Advanced Analytics_, 2015.\n* [36] Gerhard Widmer and Werner Goebl. Computational models of expressive music performance: The state of the art. _Journal of New Music Research_, 2004.\n* [37] Guangyu Xia, Yun Wang, Roger B Dannenberg, and Geoffrey Gordon. Spectral learning for expressive interactive ensemble music performance. In _Proc. ISMIR_, 2015."}, "BIBREF315": {"title": "Studio online 3.0: An internet\" killer application\" for remote access to ircam sounds and processing tools", "authors": [{"first": "Guillaume", "middle": [], "last": "Ballet", "suffix": ""}, {"first": "Riccardo", "middle": [], "last": "Borghesi", "suffix": ""}, {"first": "Peter", "middle": [], "last": "Hoffmann", "suffix": ""}, {"first": "Fabien", "middle": [], "last": "L\u00e9vy", "suffix": ""}], "venue": "Journ\u00e9e d\u2019Informatique Musicale (JIM)", "volume": "", "issue": "", "pages": "", "text_pymu": "JIM 99     -     123 \nStudio Online 3.0: \nAn Internet \"Killer Application\" for Remote Access to \nIRCAM Sounds and Processing tools \nGuillaume Ballet, guballet@club-internet.fr \nRiccardo Borghesi, ricborghesi@hotmail.com  \nPeter Hoffmann, Hoffmann_Peter@hotmail.com \nFabien L\u00e9vy, fabien.levy@wanadoo.fr \nhttp://sol.ircam.fr/external/joba \n \nAbstract: Studio Online 3.0 is the final version of an Internet music application with distributed objects \ndeveloped at IRCAM in 1996/8. This application offers high-quality instrumental sound \"online\" for \nmusic researchers, composers and professional audio studios. Studio Online is 3-tiered: a client applet \nruns in a standard Web browser and connects to a server hosted at IRCAM providing access to IRCAM \nsound transformation tools and to a large sound database. The uniqueness of Studio Online lies in its \nambition to serve the needs of scientific music research, contemporary composition and pedagogical \nactivity. The overall goal of the project was to provide an efficient and easy-to-use application for \ncontemporary audio research, composition and music production with the exclusive use of nonproprietary software tools and open standards.  \nKeywords: World Wide Web, Audio Databases, Sound Processing, Distributed Computing, Client/Server \nArchitectures, CORBA. \n1. Introduction \nIRCAM is a world renowned institution with specific competencies in acoustics and psychoacoustics of \ninstrumental sound, sound analysis and transformation software, and computer aided composition. As a \nmajor \ncenter \nof \nmusical \nresearch \nand \nproduction, \nit \nhas \na \nspecial \nmission \nof \narchiving/documenting/teaching contemporary musical use of technology. Additional artistic competence \nis input by visiting composers and musicologists. Besides IRCAMs departments for research and \ndocumentation, there is also a large department for music production and pedagogy.  \nAll of these departments are in constant need of high quality sound samples of musical instruments: the \nresearch departments need reference material for their various analyses, and the pedagogy needs specific \nsound samples for their music productions. Until recently, research and production had to laboriously \nproduce their own sound material every time they needed it, as there was no centralized collection of \ninstrumental sound readily available for their work. With Studio Online, high-quality instrumental sound \ncan now be instantly downloaded at any time to the personal computer or workstation on the office desk.  \nOne other problem tackled by Studio Online is the availability of advanced IRCAM sound processing \nsoftware for the different users in the institute (composers, researchers, engineers, students) who are \ntypically working on different computer hardware platforms (UNIX workstations, Macintoshes and PCs) \nand with different sound file formats (IRCAM's floating point format, Macintosh AIFF and AIFC, and \nMicrosoft's WAVE format). All these people need a unified, and somewhat more user-friendly access to \nthe power of IRCAM sound processing tools, without dwelling too much on their various versions, \nplatform dependencies, specificities and intricacies of their handling. Not all IRCAM sound processing \ntools have graphical frontends like SVP, FTS, Diphone or Patchwork do, and these are only available on \nspecific platforms (Audiosculpt, Diphone and Patchwork only on Macintoshes, jMAx only on some \nUNIXes).  \n\fJIM 99     -     124 \nThis was probably part of the motivation for IRCAM to respond to a call by the French Ministry of \nIndustry for proposals of a 3-years project on the \"Information Highway\", in 1996. After successful \ncompletion of the project by the end of 1998, IRCAM has at its disposal a versatile service for the various \nneeds of the inhouse staff, visiting composers, and external users (e.g. Forum members). Moreover, Studio \nOnline can be used by any computer connected to the internet. IRCAM technology can therefore be \nremotely accessed and evaluated from anywhere in the world. Studio Online permits an instantaneous, \naround-the-clock access to IRCAM sound archiving and processing power, a remotely configurable and \ncontrollable personal music studio for music professionals and laymen. Not only is it possible to \ndownload sound from the IRCAM database but also to upload own sound files to a private user space and \nhave them treated by IRCAM processing tools. According to the international character of the Internet, \nStudio Online is entirely bilingual (English and French). \nAfter a first phase of consolidation, the Studio Online Team formed under the management of Guillaume \nBallet and comprised developers Rolf W\u00f6hrmann (1997) and Rodolphe Bailly, Riccardo Borghesi and \nPeter Hoffmann (1998), artistic directors Joshua Fineberg (1997) and Fabien L\u00e9vy (1998), sound \nengineers Fran\u00e7ois Eckert (1997) and V\u00e9r\u00e8ne Gribonval (1998), post production engineers Antoine \nMercier, G\u00e9rard d'Elia (1997), and C\u00e9cile Lenoir (1998), and psychoacoustic research assistant Nicolas \nMisdariis, as well as a couple of interns. One other project, also supervised by Guillaume Ballet and \nfunded by the Ministry of Culture, specifically used Studio Online sounds for a popular Web site of \npedagogical vocation called \"Web Culture\". This site was developed by artistic director Fabrice Gu\u00e9dy \nand Web designer Guillaume Dimanche and is accessible at http://sol.ircam.fr/instruments/. \n2. Aims and Scope of the Project \nIt may be adequate to recall the ambitions and aims of the Studio Online Project as conceived by the \nStudio Online Team led by Guillaume Ballet [Ballet 1998]. One important technical ambition was the \nexclusive use of open standards (HTML, TCP/IP, CGI, CORBA, SQL) and non-proprietary technology \n(Java and C++ development under UNIX, standard CORBA tools1, JDBC). An integrated database \nclient/server development system could probably have facilitated the task, but only at the expense of \nprovider dependency, hardware/operating system limitations, or restricted availability by the internet \ncommunity (additional client software or even hardware etc.)2 For using Studio Online, there is no \ndedicated hardware necessary, no encryption involved, no specific client software, no installation of the \nclient, even no version control necessary, and no dependency on a specific carrier or provider. Everybody \ncan connect: all one needs is a working internet connection (some of them are even free of charge!) and an \nup-to-date internet browser, which is a piece of free and ubiquitous software. Everybody who has a \ncomputer can have that. \nOne important artistic ambition was to cover contemporary aspects of instrumental sound of specific \ninterest for contemporary electroacoustic composers and/or of specific pedagogical interest. For example, \nin Studio Online, most instruments (except those with a homogeneous timbre like the strings) are sampled \nin quarter tones. One can interactively search a large systematic collection of wind multiphonics, as well \nas some more 200 different 20th century playing modes and techniques as exotic as e.g. for woodwinds: \n\"jet whistle\", \"key clicks\", \"kiss sounds\", \"subtones\", breathing and singing through the instrument, and \nfor strings such as rubbing with the finger nail, knocking on the instrument's body, pressure bowing, \nartificial harmonics (strings), to name but a few [L\u00e9vy 1998]. Room acoustics are taken into account by \nproviding 6 channels for each sample: 2 near and 2 far stereo microphone pairs as well as a near and an \ninternal (built-in or contact) microphone. \n                                                           \n1Non-proprietary in the sense that the CORBA environment could be changed without any loss of \nfunctionality. The only exception is the \"Gatekeeper\" proxy server, which is an added product of the \nVisibroker ORB (see below). \n2In fact, there was not even a usable Java/CORBA development tool available at the time of the beginning \nof the project being able to create multi-tiered CORBA applications. \n\fJIM 99     -     125 \n3. The Architecture of Studio Online \nStudio Online has been conceived as a 3-tiered internet application. A client applet (the front tier) runs in \na Web browser and connects to a powerful server machine at IRCAM. Two server programs (the middle \ntier) connect the applet to a sound database as well as to a collection of audio processing tools (the back \ntier). In spite of being a Web application, on a fast machine and with a good Internet connection, Studio \nOnline almost feels like a local program. The previewing and downloading of sounds and other data (even \nsimultaneously) is managed by the browser so that the user can immediately go on working with the \ninterface while the browser manages the retrieval of the data (even of several sources simultaneously) in \nthe background. \nFor sound transfers, the applet uses the browser's capabilities of handling various multimedia data for \npreviewing (by spawning appropriate helper applications) or downloading to the user's local hard drive for \nlater use. All other communication is handled by an IIOP CORBA connection through a special proxy \nserver, Visibroker's \"Gatekeeper\", which works around some of the applet's sandbox security restrictions. \nFor example, it permits connecting to a different server interface than from where the applet was loaded, \nand it holds a callback connection allowing the server to recontact the applet on asynchronous events. (We \nuse the callback feature to notify the user upon arrival of sounds uploaded to IRCAM and to constantly \ncheck the liveness of the client applet during the session.) For details, see [Hoffmann 1998]. \nStudio Online has two main server processes: one server is written in Java and manages all session \noriented aspects. Another server is written in C++ and manages the coordination of the various audio \ntransactions like sound transformation, format conversion and downloading. Both servers are of course \nfully multithreaded and so handle multiple sessions and requests concurrently. The session server works \nbetween the client applet and the database containing all informations about user login and preferences \nand the sound taxinomy of Studio Online. The transaction server works between the client applet and \nseveral IRCAM sound processing and format conversion tools as well as a number of other tools for \ngenerating archives, checking the user's disk quota, etc. \nThe CORBA middleware enables a direct communication among objects distributed between the client \napplet and the two server programs as if it were just one single object-oriented program. The object \ndistribution is not only perfectly transparent to the user but also to some degree to the programmer, a fact \nwhich allows much flexibility in design and implementation of a distributed C/S application. \nThe session server connects to the database via a JDBC bridge. This server program stands between the \ndatabase and the client applet and provides a convenient functional layer of abstraction to the SQL \ndatabase communication. The applet, for its part, presents to the user an even more intuitive visual \ninterface for navigation within the sound taxinomy stored in the database. In an iterative, interactive \nprocess, the user is invited to incrementally refine his/her choices on a number of aspects of the sound \n(instrument, playing mode, pitch, etc.) while the interface constantly updates in order to present to the user \nthe number and the aspects of the sounds that are still available. Behind the scenes, every choice of the \nuser in the interface is converted by the applet into a request over the internet to the session server which \nsends a corresponding SQL query to the database, evaluates the result and returns the information \nnecessary in order to update the applet interface. Thanks to an efficient implementation of the remote \nquerying process, the interactive sound selection game almost feels as if one had to do with a local \ninstallation (provided the Internet access is not too bad). \nThe actual sound data are not stored in the database itself but on a large RAID disk array. It was found \nthat it was easier to handle them on a file system, as no prediction could be obtained at the time of how the \ndatabase would eventually behave when loaded with hundreds of Gigabyte of data. In addition, we needed \ndirect access to the sounds during development time and, last but not least, the database BLOB primitives \nwere bugged in Oracle 8. So the database only references the sounds by an identification number which is \npassed by the applet to the transaction server. The transaction server dynamically creates Perl scripts \nwhich contain the sequence of command lines for various tools accessing the sound files on the RAID file \nsystem and converting them according to the user's preferences concerning the microphone configuration \n(near-mono, internal, stereo-near, stereo-far and their left and right channels), the preferred sound file \nformat, sampling rate, quantization and the volume compression of the sounds. On sound download by the \nbrowser, the Perl scripts generated by the transaction server are executed through a CGI invocation and \ntransparently convert the desired sound \"on the fly\" according to the user's specification. The user's \npreferences are configurable at any time and persistent between different sessions.  \n\fJIM 99     -     126 \nStudio Online sounds have not been subjected to any audio compression with possible data loss. The main \nconcern was 100% uncompronized sound quality, and we did not want to trade it off against accelerated \ndownloading time. It is also in order to ease access and to avoid dependency on proprietary compression \nformats. \n \nFigure 1: The Studio Online 3 Distributed Architecture \n4. Related Work \nOther projects have been and are being undertaken around the world to use the Internet as an easy and \ndirect way to access large sound collections. EastWest (www.soundsonline.com) serves 16 bit, 44.1k, \nWAVE and AIFF sound (over 20,000 instrumental sound samples). Search is done by standard HTML \nforms on categories and keywords. The sound can be previewed in Real Audio. Download is accelerated \nby E-magic ZIP compression (30% without data loss) after online payment. However, sound quality is not \nabove standard CD quality. In comparison to Studio Online's 120,000 sounds, the repertoire is limited. \nSound Dogs (www.sounddogs.com) serves over 60,000 sounds and special effects for the cinema (more \nthan 110 GB of data). Search is by categories and keywords, but there is no sound preview yet. \nDownloading is not interactive at all, for sound is sent by e-mail. The sounds are of a high quality (up to \n24 bit, 48k sampling rate) and many different formats are available. These services, however, are not \ninteractive as Studio Online is in the sense that an HTML request is sent and then the user waits for the \nanswer. In Studio Online, client-server interaction is immediate and two-way. \n\"Studio On Line\" (www.audiosoft.com), not to be confounded with Studio Online, serves 16 bit 44.1k \nsounds and samples for post production studios and professionals. Specific hardware is needed to use this \nservice: a dedicated Client Computer of a specific brand is preconfigured with a Digital Video Broadcast \nCard, which decrypts audio data from a dedicated satellite connection (Astra Net) in real time. The \nimmediate access (faster than Studio Online, which is not real time) must be paid, in addition to the \nrenting of the service, by proprietary technology and dependency on a specific connection service. \n\fJIM 99     -     127 \nNone of the mentioned sites are really musical sites with an artistic vocation but commercial delivery \nservices of some big players in the audio and multimedia market. There are no sound transformations \noffered as in Studio Online, no interactive navigation on the content of the sound databases or graphical \ncontrol of parameter configurations as there are in Studio Online like Break Point Functions, compression \ngraphs, and the like, which are only possible through Java programming.  \n5. A Typical Session With Studio Online \nOne should not try to connect to Studio Online with an outmoded computer and obsolete browser \nsoftware. Required is a fast Pentium or comparable processing power, sufficient memory on top of what is \nalready consumed by the operating system and browser software (which is much), Microsoft Explorer \n4.01 (build no. 4.72.xxxx.xx) or Netscape Communicator 4.5.  \n5.1. Startup \nOn visiting the Studio Online Web page containing the client applet (http://sol.ircam.fr/external/joba) a \nnew browser window opens, the Java Virtual Machine starts up and the compressed Java archive (ca. 3 \nMB) is loaded. It takes additional time until the classes (a couple of hundreds) are verified by the Java \nsecurity system and instantiated. This can take a while, and both Netscape and Explorer do not really \nindicate the progress of this procedure, so one must be patient. (Netscape seems almost frozen during this \nperiod, while with Explorer one can easily go on surfing in another browser window.) If the user has \nconfigured a sufficiently large Browser cache (10 MB, say) to keep all the loaded Java classes on the local \nmachine, the applet will start up within seconds the next time. This is because the browser then just checks \nif the local classes are up to date and if so, verification and download of code is skipped. \n5.2. Selecting Sounds \nThe applet first presents the user a login screen where he/she can type a user name and a password. (On a \nfirst visit, the user just enters a user name and a password of his/her own choice in order to identify \nhim/herself on later logins.) On pressing the login button, the applet instantiates the ORB classes, connects \nto the IRCAM server and opens a session. The user preferences of the last session are retrieved (default is \nAIFF/16 bit/44.1 kHz as sound format and English as language). The user is first presented with a \"sound \nselector\" screen which actually is a graphical frontend to the database containing the sound taxinomy. The \nuser selects the attributes of the desired sounds among a number of categories (instrument, playing mode, \ndynamic, pitch(es), octave(s), channel configuration, etc.) and sees how the selector interface updates in \norder to show the choices that remain, until the number of hits is reduced to less than or equal to 24 \nsounds (e.g. a quarter tone octave). \n5.3. Managing Sounds: Downloading, Uploading, and Transforming \nThe user can then load the set of these sounds into the \"sound manager\". This is a directory view on the \nuser's workspace and the central part of the application. From here the user can transform selected sounds \nand recursively create subdirectories containing the results of these transformations (which we call \n\"productions\": the resulting sound file(s), some analysis files, the parameters of the transformation and a \nlog file). The directory structure thus reflects the transformation \"history\" of an original sound. The \ntransformation result is automatically previewed by the audio helper application the user has configured in \nthe browser's preferences as soon as the transformation is done. \nAn interesting chain of transformations, for example, is to split off the noise part of a noisy instrumental \nsound (e.g. a sul ponticello on a double bass or a flutter tongue on a trombone) with additive resynthesis, \nto transpose it two octaves higher and to time stretch it by a factor of four. The result is a most interesting \nsound which has lost almost all similarity to an instrumental sound, while it still benefits from the \ncomplexity and richness of a natural acoustic phenomenon. The user can also be interested in \ndownloading the spectral analysis data, and use them on his/her own computer by displaying them \ngraphically with standard software or even inputting them into his/her own software.  \nThe user can upload his/her own sounds up to 20 MB per file to a private directory on the IRCAM server. \nWAVE, AIFF, AIFC (uncompressed) and IRCAM floating point/short sample sound file formats are \nrecognized. These sounds can be transformed in the same way as the database sounds and downloaded \n\fJIM 99     -     128 \nagain, or left on the server for the next session with Studio Online. Up to 300 MB of disk space can be \nclaimed by the user. The transformation results are stored on the server in IRCAM floating point format in \norder to preserve a maximum of sound quality, so this quota might be reached after some transformations \nof lengthy sound files. In this case, the user is invited to delete some unwanted results before he/she can \nproceed producing new sound data or uploading more sounds. \n5.4. Configuring User Preferences: Language, Sound File Format, and Compression of Sound \nDynamics \nAt any time, the user can reconfigure his/her preferences in order to adapt to his/her specific local \nenvironment (typically PC/MAC/UNIX), linguistic background (English or French speaking), and audio \nsystem (does it support Studio Online's extreme 24 bit dynamic resolution?). Pianissimo sounds from \nStudio Online can be extremely weak when played back on a 16 bit audio system, so we devised a \ngraphical static compressor which permits to directly define a compression curve (linear compression and \nan optional constant offset) to adapt 24 bit dynamics (about 144 dB) to, say, the 16 bit range (about 96 \ndB). All of these configurations are immediately taken into account. For example, as soon as the user \nswitches e.g. from English to French, the configuration interface itself becomes French at once (with all \naccents, of course), as does the rest of the client applet. The same holds for sound transactions: if the user \nchanges from AIFF to WAVE, the next sound downloaded comes as WAVE with Mime Type \n\"audio/wav\", and spawns the corresponding application configured in the browser's preferences.  \n5.5. Search by Psychoacoustic Similarity \nThis interface complements the systematic choice of the sound selector interface. It is a very powerful \nsearch engine through the whole database, across instruments, playing modes, pitches, etc. by \npreprocessed comparison of spectrally analyzed content only. Surprising results can be obtained and \nsounds detected that one would not have found by looking up the sound taxinomy [Hoffmann/Misdariis \n1998]. \nThis interface has been made much more intuitively by the introduction of evocative terms and the \nconcentration on 3 major perceptual categories of sound: brilliance, richness, and attack. Additional \nconstraints can be requested by the user on spectral energy and/or pitch, restricting the hits to a certain \ndistance in these parameters, and a distinction between percussive and non-percussive sounds can be \nenforced. Up to 50 found sounds can be compared to the original sound and added to the sound manager \nfor further treatment.  \n6. Technical Data of Studio Online 3.0 \nStudio Online 3.0 is what could be called an \"Internet Killer Application\" [Orfali/Harkey 1998]. It makes \nuse of the latest achievements in distributed computing to connect Internet clients to a sound server and to \nprovide a sophisticated graphical user interface for the remote query process, the sound transformations, \nthe remote managing of the sound files, and the retrieval of the sound data. After trying standard Internet \ntechnology like HTML pages and CGI scripts, it was found that only a distributed Client/Server \narchitecture could satisfactorily respond to the needs of interactively navigating in a large sound taxinomy, \nproviding a session oriented workspace, supporting intuitive graphical controls and diagrams, and \nallowing the user to configure his/her own persistent preferences of sound format, language, compression \nlevel, etc. [cf., e.g. Weisbecker/Bauer 1998]. \nThe version of Java used is Java 1.1.3, with the JFC/Swing 1.03 layer on the client side. The ORB \nsoftware used is Visibroker for Java 3.2 and Visibroker for C++ 3.1. The database used is the Oracle \n8.0.3.0 database accessed by JDBC 8.0.4.0.6 Level 2 drivers. \nThe Web server is Apache 1.2.4, and the dynamical sound conversion scripts are launched by CGI calls \nwith Perl 5.0.3. The conversion programs are IRCAM's STtools toolkit (updated and completed by the \nStudio Online Team). \nThe server machine is a Sun Microsystems Enterprise UltraSparc 3000 running Solaris 2.5.1. \n\fJIM 99     -     129 \nThe disk array is a Sun Microsystems Raid RSM 2000, configured Raid 5, with 31 disks \u00e0 9 GB each, \nplus two hot spare and a cold spare disk. This gives us, after formatting, a usable disk space of 190 GB. \nThe database disk (1 HD)is fully mirrored with RAID 0+1.  \nThe sound total is 113.823 sounds with 6 tracks each, sampled with 48k, 24 bit (ca. 130 GB of data, \nwhich correspond ca. 12 days of continuous listening). \n7. New Features in Studio Online 3.0 \nDuring 1997, brilliant developer Rolf W\u00f6hrmann created, in close collaboration with Guillaume Ballet, \nversions 1 through 2.6, gradually fixing the architecture as described above [W\u00f6hrmann 1997, 1999]. This \nversion was a fully working, albeit somewhat restricted prototype which already served the needs of a \nconstantly growing user group. During 1998, the sound database was completed to 16 instruments by the \nrecording and editing team, and the software system was enhanced, completed, and tuned by the new \ndevelopment team. Startup of the client applet was optimized by loading all classes \"on demand\". Full \nsupport of the Windows platform was added (WAVE sound file format, support of the Explorer way to \nhandle multimedia data, etc.), sound transformations became stereo and could be indefinitely chained. The \nclient interface was completely redesigned, became fully resizable and uniform on all platforms \n(Swing/JFC look and feel), graphically much enhanced by the hierarchical directory view in the sound \nmanager with indication of the download size, graphical break point function editors for time-dependent \ntransformations, menus and tab controls instead of buttons, etc. Many minor improvements were done to \nthe client, the servers, and the various administration tools. Some small but useful features were added, \nlike e.g. the progress messages during transformation processes and the possibility to abort them, the \npossibility to download multiple sounds in one archive file or to automatically order sounds on CD, and \nautomatic dithering of 8 bit sound. More information is to be found in the release notes [SOL]. \n8. Some Problems Encountered \nWe had much trouble when upgrading from the Java 1.0 AWT to the Swing/JFC library. All Swing GUI \naction is done in the user thread which blocks on synchronous remote method invocations. Since we \ncannot predict the response time of such remote calls we had to program our own threading policy in \norder to refresh the user interface during a remote call. We finally decided to launch a thread for each \nremote connection. But then we had the difficulty of synchronizing these threads, especially in order to \nprevent a user nervously clicking on the interface and flooding the server with newly opened threads (we \nrealized this problem when during testing, our JDBC drivers simply blocked the whole system without any \nerror message after we hectically clicked some hundred times in the interface). This considerably \ncomplicated the programming of the selector interface. We would have wished the Swing/JFC layer to \nimplement the same threading policy as the old AWT.  \nWe also had much trouble with a bug in the Gatekeeper which blocked without any error indication after a \ncouple of days. I shall not mention the dozens of minor bugs in the various Swing/JFC betas and other \nused software (especially our Java development tool). But the most annoying bugs and deficiencies were \nfound in the browser software: no resizing of the applet in Netscape, no upload of sounds possible with \nthe Explorer on the Mac, to name only the most flagrant ones. Microsoft did not correctly port their \ncurrent Java Virtual Machine to the MAC, and the Apple MRJ is so sloppily implemented that one has to \ninvent dozens of workarounds in order to be able to use it at all. See [SOL] for details. \n9. Future Work \nStudio Online is actually a project designed for the future. We used the latest technology available at the \ntime, much to the disenchantment of some of our users which were not able or ready to upgrade to the \nlatest Web Browser versions with a Java Virtual Machines fully compliant to the Java 1.1 API. We \nneeded the new Java version as well as Sunsoft's Swing/JFC classes for the advanced graphics in the \napplet's user interface. We even would have preferred to migrate to Java 1.2 if it had been available at the \ntime, for it integrates the ca. 2 MB of JFC class code that have to be downloaded on the first use of Studio \nOnline. When using Nescape Communicator which already integrates Visibroker's CORBA classes (albeit \n\fJIM 99     -     130 \nin an older version), the applet could even shrink again to its old size of some hundred KB (which at the \ntime gave it the nickname \"JORBA\" for \"just one really big applet\"3). Java 1.2 would also invite to \nreplace the current CGI driven downloading and playing of audio data by an integrated solution using (an \nimproved form of) the Java Media Framework, with its support of many more file formats, etc. \nDespite its success, Studio Online should be considered only the beginning of a much more ambitious \nproject of internetworked sound processing, transparently distributed sound storage and access, and the \ndesign of component software for music purposes. It has been shown that Studio Online technology can \nsolve some of the problems of a large and historically grown research institution as IRCAM, but there is \nstill a long way to go.  \nFor example, the current integration of IRCAM sound processing tools works by command line wrapping \nwhich is a tedious, limited and suboptimal way to expose them to remote use. There are 3 to 8 separate \nprocesses launched per transformation: the various sound conversion tools to feed the source sound into \nand to retrieve the processed sound from a command pipeline, the splitting of stereo sound into mono \nchannels for the Additive engine which itself is but a script executing command lines. Under these \nconditions, it was already an achievement to implement such basic remote controls as a gauge to monitor \nthe progress of a transformation and a button to remotely abort the transformation process!  \nInstead of launching shells executing assembled command line strings, the sound processing engines \nshould be encapsulated as multithreaded CORBA servers. Once there will be stable versions and welldefined control interfaces of these engines, it will be much easier to develop intuitive and fault-tolerant \nintegrated systems using them. It would then be feasible to develop unified graphic interfaces for expert \nconfiguration of these sound processing engines which have remarkable possibilities if used in advanced \nmode. \nStudio Online should develop into a testbed for advanced tool integration, sound internetworking, and \naudio research with the help of distributed objects. There is no lack of ideas: projects have been conceived \nof treating the integration of distributed databases, advanced content search in audio documents (instead \nof the current table lookup), integration of more IRCAM software, etc.  \n10. Conclusion \nStudio Online has been one of the few realizations answering the call for projects on the \"Information \nHighway\" that have been successfully completed in time. This fact makes it all the more deplorable that \nthere has not been any kind of immediate follow-up project. Aside from the fact that much more \nfunctionality could have been added to and on top of Studio Online, it is with the expertise gained during \nthis project that even more interesting inter/intranet applications of distributed processing for musical \npurposes could have been envisaged.  \n \n \nReferences \n \n[Ballet 1998] Guillaume Ballet, Vincent Puig, Hugues Vinet, Projet Studio en ligne, Rapport final, \nIRCAM, Nov. 1998, unpublished. \n[Ballet 1998] Guillaume Ballet, Rapport d'avancement du projet Studio en ligne I, II, III, \nhttp://sol.ircam.fr/~ballet/rapports/* and http://sol.ircam.fr/docs/sol3.0/ \n[Hoffmann 1998] Peter Hoffmann, Studio Online III: Distribution and Interaction. Detailed Space-Time \nDiagrams of main SOL Functionalities, http://sol.ircam.fr/docs/sol3.0/distribution/*. \n[Hoffmann/Misdariis 1998] Peter Hoffmann, Nicolas Misdariis, \"Studio Online 3: Access to IRCAM \nSound Database and Sound Processing Tools from the Inter/Intranet\", Presentation at the 2nd CUIDAD \nmeeting, IRCAM, Dec. 1998, http://sol.ircam.fr/docs/sol3.0/slides/SOL.html \n                                                           \n3Another possible sense of the JORBA acronym could be the combination of Java and CORBA \ntechnology. \n\fJIM 99     -     131 \n[L\u00e9vy 1998] Fabien L\u00e9vy, Rapports d'enregistrements de Studio en ligne, IRCAM 1998, unpublished. \n[L\u00e9vy 1998] Fabien L\u00e9vy, Rapport sur la taxonomie de Studio en ligne, IRCAM 1998, unpublished. \n[Orfali/Harkey 1998] Robert Orfali, Dan Harkey, Client/Server Programming with Java and CORBA, 2nd \ned. Feb. 1998, John Wiley & Sons.  \n[SOL] Online documentation and help at the StudioOnline site: http://sol.ircam.fr/help.html, \nhttp://sol.ircam.fr/docs/sol3.0/* \n[Weisbecker/Bauer 1998] A.Weisbecker, S. Bauer, \"Vom Spaghetti-Code zur Komponenten-Architektur: \nDie Genesis der Anwendungsentwicklung im Intranet-Umfeld\", Focus/Computerwoche Aug. 1998, pp. \n22-24. \n[W\u00f6hrmann 1997] Rolf W\u00f6hrmann, \"Das Studio Online-Projekt am IRCAM\", Mitteilungen 26 der \nDeutschen Gesellschaft f\u00fcr Elektroakustische Musik (DEGEM), 3.9.1997, p. 16-21, htp://www.kgw.tuberlin.de/pub/DegeM/ \n[W\u00f6hrmann 1999] Rolf W\u00f6hrmann, Guillaume Ballet, \"Design and Architecture of Distributed Sound \nProcessing and Database Systems for Web Based Computer Music Applications\", Computer Music \nJournal, forthcoming. \n\fJIM 99     -     132 \n \n \n\f", "text_mmd": "# Studio Online 3.0:\n\nAn Internet \"Killer Application\" for Remote Access to IRCAM Sounds and Processing tools\n\nGuillaume Ballet, guballet@club-internet.fr Riccardo Borghesi, ricborghesi@hotmail.com Peter Hoffmann, Hoffmann_Peter@hotmail.com Fabien Levy, fabien.levy@wanadoo.fr\n\n[http://sol.ircam.fr/external/joba](http://sol.ircam.fr/external/joba)\n\n###### Abstract\n\nStudio Online 3.0 is the final version of an Internet music application with distributed objects developed at IRCAM in 1996/8. This application offers high-quality instrumental sound \"online\" for music researchers, composers and professional audio studios. Studio Online is 3-tiered: a client applet runs in a standard Web browser and connects to a server hosted at IRCAM providing access to IRCAM sound transformation tools and to a large sound database. The uniqueness of Studio Online lies in its ambition to serve the needs of scientific music research, contemporary composition and pedagogical activity. The overall goal of the project was to provide an efficient and easy-to-use application for contemporary audio research, composition and music production with the exclusive use of non-proprietary software tools and open standards.\n\nKeywords: World Wide Web, Audio Databases, Sound Processing, Distributed Computing, Client/Server Architectures, CORBA.\n\n## 1 Introduction\n\nIRCAM is a world renowned institution with specific competencies in acoustics and psychoacoustics of instrumental sound, sound analysis and transformation software, and computer aided composition. As a major center of musical research and production, it has a special mission of archiving/documenting/teaching contemporary musical use of technology. Additional artistic competence is input by visiting composers and musicologists. Besides IRCAMs departments for research and documentation, there is also a large department for music production and pedagogy.\n\nAll of these departments are in constant need of high quality sound samples of musical instruments: the research departments need reference material for their various analyses, and the pedagogy needs specific sound samples for their music productions. Until recently, research and production had to laboriously produce their own sound material every time they needed it, as there was no centralized collection of instrumental sound readily available for their work. With Studio Online, high-quality instrumental sound can now be instantly downloaded at any time to the personal computer or workstation on the office desk.\n\nOne other problem tackled by Studio Online is the availability of advanced IRCAM sound processing software for the different users in the institute (composers, researchers, engineers, students) who are typically working on different computer hardware platforms (UNIX workstations, Macintoshes and PCs) and with different sound file formats (IRCAM's floating point format, Macintosh AIFF and AIFC, and Microsoft's WAVE format). All these people need a unified, and somewhat more user-friendly access to the power of IRCAM sound processing tools, without dwelling too much on their various versions, platform dependencies, specificities and intricacies of their handling. Not all IRCAM sound processing tools have graphical frontends like SVP, FTS, Diphone or Patchwork do, and these are only available on specific platforms (Audiosculpt, Diphone and Patchwork only on Macintoshes, jMAx only on some UNIXes).\n\nThis was probably part of the motivation for IRCAM to respond to a call by the French Ministry of Industry for proposals of a 3-years project on the \"Information Highway\", in 1996. After successful completion of the project by the end of 1998, IRCAM has at its disposal a versatile service for the various needs of the inhouse staff, visiting composers, and external users (e.g. Forum members). Moreover, Studio Online can be used by any computer connected to the internet. IRCAM technology can therefore be remotely accessed and evaluated from anywhere in the world. Studio Online permits an instantaneous, around-the-clock access to IRCAM sound archiving and processing power, a remotely configurable and controllable personal music studio for music professionals and laymen. Not only is it possible to download sound from the IRCAM database but also to upload own sound files to a private user space and have them treated by IRCAM processing tools. According to the international character of the Internet, Studio Online is entirely bilingual (English and French).\n\nAfter a first phase of consolidation, the Studio Online Team formed under the management of Guillaume Ballet and comprised developers Rolf Wohrmann (1997) and Rodolphe Bailly, Riccardo Borghesi and Peter Hoffmann (1998), artistic directors Joshua Fineberg (1997) and Fabien Levy (1998), sound engineers Francois Eckert (1997) and Verene Gribonval (1998), post production engineers Antoine Mercier, Gerard Elia (1997), and Cecile Lenoir (1998), and psychoacoustic research assistant Nicolas Misdariis, as well as a couple of interns. One other project, also supervised by Guillaume Ballet and funded by the Ministry of Culture, specifically used Studio Online sounds for a popular Web site of pedagogical vocation called \"Web Culture\". This site was developed by artistic director Fabrice Guedy and Web designer Guillaume Dimanche and is accessible at [http://sol.ircam.fr/instruments/](http://sol.ircam.fr/instruments/).\n\n## 2 Aims and Scope of the Project\n\nIt may be adequate to recall the ambitions and aims of the Studio Online Project as conceived by the Studio Online Team led by Guillaume Ballet [Ballet 1998]. One important technical ambition was the exclusive use of open standards (HTML, TCP/IP, CGI, CORBA, SQL) and non-proprietary technology (Java and C++ development under UNIX, standard CORBA tools1, JDBC). An integrated database client/server development system could probably have facilitated the task, but only at the expense of provider dependency, hardware/operating system limitations, or restricted availability by the internet community (additional client software or even hardware etc.)2 For using Studio Online, there is no dedicated hardware necessary, no encryption involved, no specific client software, no installation of the client, even no version control necessary, and no dependency on a specific carrier or provider. Everybody can connect: all one needs is a working internet connection (some of them are even free of charge!) and an up-to-date internet browser, which is a piece of free and ubiquitous software. Everybody who has a computer can have that.\n\nFootnote 1: Non-proprietary in the sense that the CORBA environment could be changed without any loss of functionality. The only exception is the \u201dGatekeeper\u201d proxy server, which is an added product of the Visibroker ORB (see below).\n\nFootnote 2: In fact, there was not even a usable Java/CORBA development tool available at the time of the beginning of the project being able to create multi-tiered CORBA applications.\n\nOne important artistic ambition was to cover contemporary aspects of instrumental sound of specific interest for contemporary electroacoustic composers and/or of specific pedagogical interest. For example, in Studio Online, most instruments (except those with a homogeneous timbre like the strings) are sampled in quarter tones. One can interactively search a large systematic collection of wind multiphonics, as well as some more 200 different 20th century playing modes and techniques as exotic as e.g. for woodwinds: \"jet whistle\", \"key clicks\", \"kiss sounds\", \"subtones\", breathing and singing through the instrument, and for strings such as rubbing with the finger nail, knocking on the instrument's body, pressure bowing, artificial harmonics (strings), to name but a few [Levy 1998]. Room acoustics are taken into account by providing 6 channels for each sample: 2 near and 2 far stereo microphone pairs as well as a near and an internal (built-in or contact) microphone.\n\n## 3 The Architecture of Studio Online\n\nStudio Online has been conceived as a 3-tiered internet application. A client applet (the front tier) runs in a Web browser and connects to a powerful server machine at IRCAM. Two server programs (the middle tier) connect the applet to a sound database as well as to a collection of audio processing tools (the back tier). In spite of being a Web application, on a fast machine and with a good Internet connection, Studio Online almost feels like a local program. The previewing and downloading of sounds and other data (even simultaneously) is managed by the browser so that the user can immediately go on working with the interface while the browser manages the retrieval of the data (even of several sources simultaneously) in the background.\n\nFor sound transfers, the applet uses the browser's capabilities of handling various multimedia data for previewing (by spawning appropriate helper applications) or downloading to the user's local hard drive for later use. All other communication is handled by an IIOP CORBA connection through a special proxy server, Visibroker's \"Gatekeeper\", which works around some of the applet's sandbox security restrictions. For example, it permits connecting to a different server interface than from where the applet was loaded, and it holds a callback connection allowing the server to recontact the applet on asynchronous events. (We use the callback feature to notify the user upon arrival of sounds uploaded to IRCAM and to constantly check the liveness of the client applet during the session.) For details, see [10].\n\nStudio Online has two main server processes: one server is written in Java and manages all session oriented aspects. Another server is written in C++ and manages the coordination of the various audio transactions like sound transformation, format conversion and downloading. Both servers are of course fully multithreaded and so handle multiple sessions and requests concurrently. The session server works between the client applet and the database containing all informations about user login and preferences and the sound taxonomy of Studio Online. The transaction server works between the client applet and several IRCAM sound processing and format conversion tools as well as a number of other tools for generating archives, checking the user's disk quota, etc.\n\nThe CORBA middleware enables a direct communication among objects distributed between the client applet and the two server programs as if it were just one single object-oriented program. The object distribution is not only perfectly transparent to the user but also to some degree to the programmer, a fact which allows much flexibility in design and implementation of a distributed C/S application.\n\nThe session server connects to the database via a JDBC bridge. This server program stands between the database and the client applet and provides a convenient functional layer of abstraction to the SQL database communication. The applet, for its part, presents to the user an even more intuitive visual interface for navigation within the sound taxonomy stored in the database. In an iterative, interactive process, the user is invited to incrementally refine his/her choices on a number of aspects of the sound (instrument, playing mode, pitch, etc.) while the interface constantly updates in order to present to the user the number and the aspects of the sounds that are still available. Behind the scenes, every choice of the user in the interface is converted by the applet into a request over the internet to the session server which sends a corresponding SQL query to the database, evaluates the result and returns the information necessary in order to update the applet interface. Thanks to an efficient implementation of the remote querying process, the interactive sound selection game almost feels as if one had to do with a local installation (provided the Internet access is not too bad).\n\nThe actual sound data are not stored in the database itself but on a large RAID disk array. It was found that it was easier to handle them on a file system, as no prediction could be obtained at the time of how the database would eventually behave when loaded with hundreds of Gigabyte of data. In addition, we needed direct access to the sounds during development time and, last but not least, the database BLOB primitives were bugged in Oracle 8. So the database only references the sounds by an identification number which is passed by the applet to the transaction server. The transaction server dynamically creates Perl scripts which contain the sequence of command lines for various tools accessing the sound files on the RAID file system and converting them according to the user's preferences concerning the microphone configuration (near-mono, internal, stereo-near, stereo-far and their left and right channels), the preferred sound file format, sampling rate, quantization and the volume compression of the sounds. On sound download by the browser, the Perl scripts generated by the transaction server are executed through a CGI invocation and transparently convert the desired sound \"on the fly\" according to the user's specification. The user's preferences are configurable at any time and persistent between different sessions.\n\nStudio Online sounds have not been subjected to any audio compression with possible data loss. The main concern was 100% uncompromised sound quality, and we did not want to trade it off against accelerated downloading time. It is also in order to ease access and to avoid dependency on proprietary compression formats.\n\n## 4 Related Work\n\nOther projects have been and are being undertaken around the world to use the Internet as an easy and direct way to access large sound collections. EastWest (www.soundsonline.com) serves 16 bit, 44.1k, WAVE and AIFF sound (over 20,000 instrumental sound samples). Search is done by standard HTML forms on categories and keywords. The sound can be previewed in Real Audio. Download is accelerated by E-magic ZIP compression (30% without data loss) after online payment. However, sound quality is not above standard CD quality. In comparison to Studio Online's 120,000 sounds, the repertoire is limited.\n\nSound Dogs (www.sounddogs.com) serves over 60,000 sounds and special effects for the cinema (more than 110 GB of data). Search is by categories and keywords, but there is no sound preview yet. Downloading is not interactive at all, for sound is sent by e-mail. The sounds are of a high quality (up to 24 bit, 48k sampling rate) and many different formats are available. These services, however, are not interactive as Studio Online is in the sense that an HTML request is sent and then the user waits for the answer. In Studio Online, client-server interaction is immediate and two-way.\n\n\"Studio On Line\" (www.audiosoft.com), not to be confounded with Studio Online, serves 16 bit 44.1k sounds and samples for post production studios and professionals. Specific hardware is needed to use this service: a dedicated Client Computer of a specific brand is preconfigured with a Digital Video Broadcast Card, which decrypts audio data from a dedicated satellite connection (Astra Net) in real time. The immediate access (faster than Studio Online, which is not real time) must be paid, in addition to the renting of the service, by proprietary technology and dependency on a specific connection service.\n\nFigure 1: The Studio Online 3 Distributed Architecture\n\nNone of the mentioned sites are really musical sites with an artistic vocation but commercial delivery services of some big players in the audio and multimedia market. There are no sound transformations offered as in Studio Online, no interactive navigation on the content of the sound databases or graphical control of parameter configurations as there are in Studio Online like Break Point Functions, compression graphs, and the like, which are only possible through Java programming.\n\n## 5 A Typical Session With Studio Online\n\nOne should not try to connect to Studio Online with an outmoded computer and obsolete browser software. Required is a fast Pentium or comparable processing power, sufficient memory on top of what is already consumed by the operating system and browser software (which is much), Microsoft Explorer 4.01 (build no. 4.72.xxxx.xx) or Netscape Communicator 4.5.\n\n### Startup\n\nOn visiting the Studio Online Web page containing the client applet ([http://sol.ircam.fr/external/joba](http://sol.ircam.fr/external/joba)) a new browser window opens, the Java Virtual Machine starts up and the compressed Java archive (ca. 3 MB) is loaded. It takes additional time until the classes (a couple of hundreds) are verified by the Java security system and instantiated. This can take a while, and both Netscape and Explorer do not really indicate the progress of this procedure, so one must be patient. (Netscape seems almost frozen during this period, while with Explorer one can easily go on surfing in another browser window.) If the user has configured a sufficiently large Browser cache (10 MB, say) to keep all the loaded Java classes on the local machine, the applet will start up within seconds the next time. This is because the browser then just checks if the local classes are up to date and if so, verification and download of code is skipped.\n\n### Selecting Sounds\n\nThe applet first presents the user a login screen where he/she can type a user name and a password. (On a first visit, the user just enters a user name and a password of his/her own choice in order to identify him/herself on later logins.) On pressing the login button, the applet instantiates the ORB classes, connects to the IRCAM server and opens a session. The user preferences of the last session are retrieved (default is AIFF/16 bit/44.1 kHz as sound format and English as language). The user is first presented with a \"sound selector\" screen which actually is a graphical frontend to the database containing the sound taxonomy. The user selects the attributes of the desired sounds among a number of categories (instrument, playing mode, dynamic, pitch(es), octave(s), channel configuration, etc.) and sees how the selector interface updates in order to show the choices that remain, until the number of hits is reduced to less than or equal to 24 sounds (e.g. a quarter tone octave).\n\n### Managing Sounds: Downloading, Uploading, and Transforming\n\nThe user can then load the set of these sounds into the \"sound manager\". This is a directory view on the user's workspace and the central part of the application. From here the user can transform selected sounds and recursively create subdirectories containing the results of these transformations (which we call \"productions\": the resulting sound file(s), some analysis files, the parameters of the transformation and a log file). The directory structure thus reflects the transformation \"history\" of an original sound. The transformation result is automatically previewed by the audio helper application the user has configured in the browser's preferences as soon as the transformation is done.\n\nAn interesting chain of transformations, for example, is to split off the noise part of a noisy instrumental sound (e.g. a sul ponticello on a double bass or a flutter tongue on a trombone) with additive resynthesis, to transpose it two octaves higher and to time stretch it by a factor of four. The result is a most interesting sound which has lost almost all similarity to an instrumental sound, while it still benefits from the complexity and richness of a natural acoustic phenomenon. The user can also be interested in downloading the spectral analysis data, and use them on his/her own computer by displaying them graphically with standard software or even inputting them into his/her own software.\n\nThe user can upload his/her own sounds up to 20 MB per file to a private directory on the IRCAM server. WAVE, AIFF, AIFC (uncompressed) and IRCAM floating point/short sample sound file formats are recognized. These sounds can be transformed in the same way as the database sounds and downloadedagain, or left on the server for the next session with Studio Online. Up to 300 MB of disk space can be claimed by the user. The transformation results are stored on the server in IRCAM floating point format in order to preserve a maximum of sound quality, so this quota might be reached after some transformations of lengthy sound files. In this case, the user is invited to delete some unwanted results before he/she can proceed producing new sound data or uploading more sounds.\n\n### 5.4. Configuring User Preferences: Language, Sound File Format, and Compression of Sound Dynamics\n\nAt any time, the user can reconfigure his/her preferences in order to adapt to his/her specific local environment (typically PC/MAC/UNIX), linguistic background (English or French speaking), and audio system (does it support Studio Online's extreme 24 bit dynamic resolution?). Pianissimo sounds from Studio Online can be extremely weak when played back on a 16 bit audio system, so we devised a graphical static compressor which permits to directly define a compression curve (linear compression and an optional constant offset) to adapt 24 bit dynamics (about 144 dB) to, say, the 16 bit range (about 96 dB). All of these configurations are immediately taken into account. For example, as soon as the user switches e.g. from English to French, the configuration interface itself becomes French at once (with all accents, of course), as does the rest of the client applet. The same holds for sound transactions: if the user changes from AIFF to WAVE, the next sound downloaded comes as WAVE with Mime Type \"audio/wav\", and spawns the corresponding application configured in the browser's preferences.\n\n### 5.5. Search by Psychoacoustic Similarity\n\nThis interface complements the systematic choice of the sound selector interface. It is a very powerful search engine through the whole database, across instruments, playing modes, pitches, etc. by preprocessed comparison of spectrally analyzed content only. Surprising results can be obtained and sounds detected that one would not have found by looking up the sound taxonomy [Hoffmann/Misdariis 1998].\n\nThis interface has been made much more intuitively by the introduction of evocative terms and the concentration on 3 major perceptual categories of sound: brilliance, richness, and attack. Additional constraints can be requested by the user on spectral energy and/or pitch, restricting the hits to a certain distance in these parameters, and a distinction between percussive and non-percussive sounds can be enforced. Up to 50 found sounds can be compared to the original sound and added to the sound manager for further treatment.\n\n## 6. Technical Data of Studio Online 3.0\n\nStudio Online 3.0 is what could be called an \"Internet Killer Application\" [Orfali/Harkey 1998]. It makes use of the latest achievements in distributed computing to connect Internet clients to a sound server and to provide a sophisticated graphical user interface for the remote query process, the sound transformations, the remote managing of the sound files, and the retrieval of the sound data. After trying standard Internet technology like HTML pages and CGI scripts, it was found that only a distributed Client/Server architecture could satisfactorily respond to the needs of interactively navigating in a large sound taxonomy, providing a session oriented workspace, supporting intuitive graphical controls and diagrams, and allowing the user to configure his/her own persistent preferences of sound format, language, compression level, etc. [cf., e.g. Weisbecker/Bauer 1998].\n\nThe version of Java used is Java 1.1.3, with the JFC/Swing 1.03 layer on the client side. The ORB software used is Visibroker for Java 3.2 and Visibroker for C++ 3.1. The database used is the Oracle 8.0.3.0 database accessed by JDBC 8.0.4.0.6 Level 2 drivers.\n\nThe Web server is Apache 1.2.4, and the dynamical sound conversion scripts are launched by CGI calls with Perl 5.0.3. The conversion programs are IRCAM's STtools toolkit (updated and completed by the Studio Online Team).\n\nThe server machine is a Sun Microsystems Enterprise UltraSparc 3000 running Solaris 2.5.1.\n\nThe disk array is a Sun Microsystems Raid RSM 2000, configured Raid 5, with 31 disks a 9 GB each, plus two hot spare and a cold spare disk. This gives us, after formatting, a usable disk space of 190 GB. The database disk (1 HD)is fully mirrored with RAID 0+1.\n\nThe sound total is 113.823 sounds with 6 tracks each, sampled with 48k, 24 bit (ca. 130 GB of data, which correspond ca. 12 days of continuous listening).\n\n## 7 New Features in Studio Online 3.0\n\nDuring 1997, brilliant developer Rolf Wohrmann created, in close collaboration with Guillaume Ballet, versions 1 through 2.6, gradually fixing the architecture as described above [Wohrmann 1997, 1999]. This version was a fully working, albeit somewhat restricted prototype which already served the needs of a constantly growing user group. During 1998, the sound database was completed to 16 instruments by the recording and editing team, and the software system was enhanced, completed, and tuned by the new development team. Startup of the client applet was optimized by loading all classes \"on demand\". Full support of the Windows platform was added (WAVE sound file format, support of the Explorer way to handle multimedia data, etc.), sound transformations became stereo and could be indefinitely chained. The client interface was completely redesigned, became fully resizable and uniform on all platforms (Swing/JFC look and feel), graphically much enhanced by the hierarchical directory view in the sound manager with indication of the download size, graphical break point function editors for time-dependent transformations, menus and tab controls instead of buttons, etc. Many minor improvements were done to the client, the servers, and the various administration tools. Some small but useful features were added, like e.g. the progress messages during transformation processes and the possibility to abort them, the possibility to download multiple sounds in one archive file or to automatically order sounds on CD, and automatic dithering of 8 bit sound. More information is to be found in the release notes [SOL].\n\n## 8 Some Problems Encountered\n\nWe had much trouble when upgrading from the Java 1.0 AWT to the Swing/JFC library. All Swing GUI action is done in the user thread which blocks on synchronous remote method invocations. Since we cannot predict the response time of such remote calls we had to program our own threading policy in order to refresh the user interface during a remote call. We finally decided to launch a thread for each remote connection. But then we had the difficulty of synchronizing these threads, especially in order to prevent a user nervously clicking on the interface and flooding the server with newly opened threads (we realized this problem when during testing, our JDBC drivers simply blocked the whole system without any error message after we heectically clicked some hundred times in the interface). This considerably complicated the programming of the selector interface. We would have wished the Swing/JFC layer to implement the same threading policy as the old AWT.\n\nWe also had much trouble with a bug in the Gatekeeper which blocked without any error indication after a couple of days. I shall not mention the dozens of minor bugs in the various Swing/JFC betas and other used software (especially our Java development tool). But the most annoying bugs and deficiencies were found in the browser software: no resizing of the applet in Netscape, no upload of sounds possible with the Explorer on the Mac, to name only the most flagrant ones. Microsoft did not correctly port their current Java Virtual Machine to the MAC, and the Apple MRI is so sloppily implemented that one has to invent dozens of workarounds in order to be able to use it at all. See [SOL] for details.\n\n## 9 Future Work\n\nStudio Online is actually a project designed for the future. We used the latest technology available at the time, much to the disenchantment of some of our users which were not able or ready to upgrade to the latest Web Browser versions with a Java Virtual Machines fully compliant to the Java 1.1 API. We needed the new Java version as well as Sunsoft's Swing/JFC classes for the advanced graphics in the applet's user interface. We even would have preferred to migrate to Java 1.2 if it had been available at the time, for it integrates the ca. 2 MB of JFC class code that have to be downloaded on the first use of Studio Online. When using Nescape Communicator which already integrates Visibroker's CORBA classes (albeitin an older version), the applet could even shrink again to its old size of some hundred KB (which at the time gave it the nickname \"JORBA\" for \"**just one** really **big** applet\"3). Java 1.2 would also invite to replace the current CGI driven downloading and playing of audio data by an integrated solution using (an improved form of) the Java Media Framework, with its support of many more file formats, etc.\n\nFootnote 3: Another possible sense of the JORBA acronym could be the combination of **J**ava and **CORBA** technology.\n\nDespite its success, Studio Online should be considered only the beginning of a much more ambitious project of internetworked sound processing, transparently distributed sound storage and access, and the design of component software for music purposes. It has been shown that Studio Online technology can solve some of the problems of a large and historically grown research institution as IRCAM, but there is still a long way to go.\n\nFor example, the current integration of IRCAM sound processing tools works by command line wrapping which is a tedious, limited and suboptimal way to expose them to remote use. There are 3 to 8 separate processes launched per transformation: the various sound conversion tools to feed the source sound into and to retrieve the processed sound from a command pipeline, the splitting of stereo sound into mono channels for the Additive engine which itself is but a script executing command lines. Under these conditions, it was already an achievement to implement such basic remote controls as a gauge to monitor the progress of a transformation and a button to remotely abort the transformation process!\n\nInstead of launching shells executing assembled command line strings, the sound processing engines should be encapsulated as multithreaded CORBA servers. Once there will be stable versions and well-defined control interfaces of these engines, it will be much easier to develop intuitive and fault-tolerant integrated systems using them. It would then be feasible to develop unified graphic interfaces for expert configuration of these sound processing engines which have remarkable possibilities if used in advanced mode.\n\nStudio Online should develop into a testbed for advanced tool integration, sound internetworking, and audio research with the help of distributed objects. There is no lack of ideas: projects have been conceived of treating the integration of distributed databases, advanced content search in audio documents (instead of the current table lookup), integration of more IRCAM software, etc.\n\n## 10 Conclusion\n\nStudio Online has been one of the few realizations answering the call for projects on the \"Information Highway\" that have been successfully completed in time. This fact makes it all the more deplorable that there has not been any kind of immediate follow-up project. Aside from the fact that much more functionality could have been added to and on top of Studio Online, it is with the expertise gained during this project that even more interesting inter/intranet applications of distributed processing for musical purposes could have been envisaged.\n\n## References\n\n* [Ballet 1998] Guillaume Ballet, Vincent Puig, Hugues Vinet, _Projet Studio en ligne, Rapport final_, IRCAM, Nov. 1998, unpublished.\n* [Ballet 1998] Guillaume Ballet, _Rapport d'avancement du projet Studio en ligne I, II, III_, [http://sol.ircam.fr/~ballet/rapports/](http://sol.ircam.fr/~ballet/rapports/)* and [http://sol.ircam.fr/docs/sol3.0/](http://sol.ircam.fr/docs/sol3.0/)\n* [Hoffmann 1998] Peter Hoffmann, Studio Online III: Distribution and Interaction. Detailed Space-Time Diagrams of main SOL Functionalities, [http://sol.ircam.fr/docs/sol3.0/distribution/](http://sol.ircam.fr/docs/sol3.0/distribution/)*.\n* [Hoffmann/Misdariis 1998] Peter Hoffmann, Nicolas Misdariis, \"Studio Online 3: Access to IRCAM Sound Database and Sound Processing Tools from the Inter/Intranet\", Presentation at the 2nd CUIDAD meeting, IRCAM, Dec. 1998, [http://sol.ircam.fr/docs/sol3.0/slides/SOL.html](http://sol.ircam.fr/docs/sol3.0/slides/SOL.html)* [Levy 1998] Fabien Levy, _Rapports d'enregistrements de Studio en ligne_, IRCAM 1998, unpublished.\n* [Levy 1998] Fabien Levy, _Rapport sur la taxonomie de Studio en ligne_, IRCAM 1998, unpublished.\n* [Orfali/Harkey 1998] Robert Orlali, Dan Harkey, Client/Server Programming with Java and CORBA, 2nd ed. Feb. 1998, John Wiley & Sons.\n* [SGL] Online documentation and help at the StudioOnline site: [http://sol.ircam.fr/help.html](http://sol.ircam.fr/help.html), [http://sol.ircam.fr/docs/sol3.0/](http://sol.ircam.fr/docs/sol3.0/)*\n* [Weisbecker/Bauer 1998] A.Weisbecker, S. Bauer, \"Vom Spaghetti-Code zur Komponenten-Architektur: Die Genesis der Anwendungsentwicklung im Intranet-Umfeld\", Focus/Computerwoche Aug. 1998, pp. 22-24.\n* [Wohrmann 1997] Rolf Wohrmann, \"Das Studio Online-Projekt am IRCAM\", Mitteilungen 26 der Deutschen Gesellschaft fur Elektroakustische Musik (DEGEM), 3.9.1997, p. 16-21, [http://www.kgw.tu-berlin.de/pub/DegeM/](http://www.kgw.tu-berlin.de/pub/DegeM/)\n* [Wohrmann 1999] Rolf Wohrmann, Guillaume Ballet, \"Design and Architecture of Distributed Sound Processing and Database Systems for Web Based Computer Music Applications\", Computer Music Journal, forthcoming.\n\n**Figure Captions**\n\n* **Figure Captions**\n\n* **Figure Captions**"}, "BIBREF312": {"title": "music21: A toolkit for computer-aided musicology and symbolic music data", "authors": [{"first": "Michael", "middle": [], "last": "Scott", "suffix": ""}, {"first": "Cuthbert", "middle": [], "last": "", "suffix": ""}, {"first": "Christopher", "middle": [], "last": "Ariza", "suffix": ""}], "venue": "", "volume": "", "issue": "", "pages": "", "text_pymu": "music21: A Toolkit for Computer-Aided Musicology and  \nSymbolic Music Data \nMichael Scott Cuthbert \nChristopher Ariza \nMusic and Theater Arts \nMassachusetts Institute of Technology \n{cuthbert, ariza}@mit.edu\nABSTRACT\nMusic21 is an object-oriented toolkit for analyzing, \nsearching, and transforming music in symbolic (scorebased) forms. The modular approach of the project allows \nmusicians and researchers to write simple scripts rapidly \nand reuse them in other projects. The toolkit aims to provide powerful software tools integrated with sophisticated \nmusical knowledge to both musicians with little programming experience (especially musicologists) and to \nprogrammers with only modest music theory skills. \nThis paper introduces the music21 system, demonstrating how to use it and the types of problems it is wellsuited toward advancing. We include numerous examples \nof its power and flexibility, including demonstrations of \ngraphing data and generating annotated musical scores. \n1. INTRODUCTION: WHY MUSIC21?\nComputers have transformed so many aspects of musicology\u2014from writing and editing papers, to studying \nmanuscripts with digital files, to creating databases of \ncomposers\u2019 letters, to typesetting editions\u2014that it is incredible that most analytical tasks that music historians \nperform remain largely untouched by technology. The \nstudy of the rich troves of musical data in scores, \nsketches, intabulations, lead-sheets, and other sources of \nsymbolic music data is still done almost exclusively by \nhand. Even when databases and spreadsheets are employed, they are usually created for a single purpose. \nSuch specialized approaches cannot easily be reused. \nComputer scientists often assume that, compared to \nworking with scanned images of scores or sound files, \nmanipulating symbolic data should be a cinch. Most of \nthe information from a score can easily be converted to \ntext-based or numeric formats that general-purpose statistical or information-retrieval tools can manipulate. In \npractice the complexities of music notation and theory \nresult in these tools rarely being sufficient. \nFor instance, a researcher might want to compare \nhow closely the music of two composers adheres to a particular scale (say, the major scale). What begins as a \nstraightforward statistical problem requiring little musical \nknowledge\u2014simply encode which notes are in the scale \nof the piece\u2019s key and which are not\u2014can quickly grow \nbeyond the capabilities of general statistics packages. \nSuppose that after some initial work, our researcher decides that notes on stronger beats should be weighed \nmore heavily than those on weaker beats. Now she must \neither add the information about beats by hand to each \nnote or write a new algorithm that labels the beats. Beat \nlabeling is another task that initially seems easy but rapidly becomes extremely troublesome for several reasons.  \nAre grace-notes accented or unaccented? Only a musically-trained ear that also knows the norms of an era can tell. \nIncompletely-filled measures, such as pickup measures \nand mid-bar repeats, present problems for algorithms. As \nthe researcher\u2019s corpus expands, the time spent on metaresearch expands with it. What began as a straightforward \nproject becomes a set of tedious separate labors: transforming data from multiple formats into one, moving \ntransposing instruments into sounding pitch, editorial accidentals in early music, or finding ways of visualizing \ntroublesome moments for debugging. \nResearchers in other fields can call upon generalpurpose toolkits to deal with time-consuming yet largely \nsolved problems. For instance, a scientist working with a \nlarge body of text has easy access to open-source libraries \nfor removing punctuation, converting among textencoding formats, correcting spelling, identifying parts of \nspeech, sentence diagramming, automatic translation, and \nof course rendering text in a variety of media. Libraries \nand programs to help with the musical equivalents of \neach of these tasks do exist, but few exchange data with \neach other in standardized formats. Even fewer are designed in modern, high-level programming languages. As \na result of these difficulties, computational solutions to \nmusicological problems are rarely employed even when \nthey would save time, expand the scope of projects, or \nquickly find important exceptions to overly broad pronouncements. \nThe music21 project (http://web.mit.edu/music21) \nexpands the audience for computational musicology by \ncreating a new toolkit built from the ground up with intuitive simplicity and object-oriented design throughout. \n(The \u201c21\u201d in the title comes from the designation for \nMIT\u2019s classes in Music, Course 21M.) The advantages of \nobject-oriented design have led to its wide adoption in \nmany realms of software engineering. These design principles have been employed in music synthesis and generation systems over the past 25 years [2, 9, 10] but have \nnot been thoroughly integrated into packages for the \nanalysis of music as symbolic data. Humdrum, the most \nwidely adopted software package [6], its contemporary \nports [7, 11], and publications using these packages show \nthe great promise of computational approaches to music \ntheory and musicology. Yet Humdrum can be difficult to \nuse: both programmers and non-programmers alike may \nfind its reliance on a chain of shell-scripts, rather than object-oriented libraries, limiting and not intuitive.  \nNicholas Cook has called upon programmers to \ncreate for musicologists \u201ca modular approach involving \n637\n11th International Society for Music Information Retrieval Conference (ISMIR 2010)\n\fan unlimited number of individual software tools\u201d [3]. A \nframework built with intuitive, reusable, and expandable \nobjects satisfies Cook\u2019s call without sacrificing power for \nmore complex tasks. \nAs a new, open-source, cross-platform toolkit written \nin Python, music21 provides such a modular approach, \nmelding object-oriented music representation and analysis with a concise and simple programming interface. \nSimplicity of use, ease of expansion, and access to existing data are critical to the design of music21. The toolkit \nimports Humdrum/Kern, MusicXML [4], and userdefined formats (with MIDI and MuseData forthcoming). \nBecause it is written in Python, music21 can tap into \nmany other libraries, integrating internet resources (such \nas geomapping with Google Maps), visualization software, and sophisticated database searches with musical \nanalysis. \nThis brief paper gives an overview of the music21\ntoolkit. Through examples of musicological applications \nthat the system enables, the main distinguishing features \nare illustrated: simplicity of use and expansion. \n2. SCRIPTING AND OBJECTS \nMusic21 is built in Python, a well-established programming language packaged with Macintosh and Unix computers and freely downloadable for Windows users.  The \ntoolkit adds a set of related libraries, providing sophisticated musical knowledge to Python. As shown in Figure \n1, after adding the system with \u201cfrom music21    \nimport *\u201d, straightforward tasks such as displaying or \nplaying a short melody, getting a twelve-tone matrix, or \nconverting from Humdrum\u2019s Kern format to MusicXML \ncan each be accomplished with a single line of code. \nDisplay a simple melody in musical notation:\n  tinyNotation.TinyNotationStream( \n        \"c4 d8 f g16 a g f#\", \"3/4\").show() \nPrint the twelve-tone matrix for a tone row (in this case the \nopening of Schoenberg\u2019s Fourth String Quartet): \nprint(serial.rowToMatrix( \n            [2,1,9,10,5,3,4,0,8,7,6,11]) )  \nor since most of the 2nd-Viennese school rows are already \navailable as objects, you could instead type:   \nprint(serial.RowSchoenbergOp37().matrix() ) \nConvert a file from Humdrum\u2019s **kern data format to MusicXML for editing in Finale or Sibelius: \n  parse('/users/documents/composition.krn'). \n      write('xml') \nFigure 1. Three simple examples of one-line music21 scripts. \nThough single-line tasks are simpler to accomplish in \nmusic21 than in existing packages, the full power of the \nnew toolkit comes from bringing together and extending \nhigh-level objects. The framework includes many objects, \nincluding Pitches, Chords, Durations, TimeSignatures, \nIntervals, Instruments, and standard Ornaments. Through \nmethod calls, objects can perform their own analyses and \ntransformations. For instance, Chords can find their own \nroots, create closed-position versions of themselves, \ncompute their Forte prime forms, and so on. Researchers \ncan extend objects for their own needs, such as altering \nthe pitch of open Violin strings to study scordatura, specializing (subclassing) the Note class into MensuralNote \nfor studying Renaissance Music, or grouping Measures \ninto Hypermeters. The object-oriented design of music21 simplifies writing these extensions. \n3. STREAMS: POWERFUL, NESTABLE, \nCONTAINERS OF TIMED ELEMENTS \nAt the core of music21 is a novel grouping of musical \ninformation into Streams: nestable containers that allow \nresearchers to quickly find simultaneous events, follow a \nvoice, or represent instruments playing in different tempi \nand meters. Elements within Streams are accessed with \nmethods such as getElementById(), an approach similarly to the Document Object Model (DOM) of retrieving \nelements from within XML and HTML documents. Like \nnearly every music21 object, Streams can immediately \nbe visually displayed in Lilypond or with programs that \nimport MusicXML (such as Finale and Sibelius).  \nThrough the Stream model, a program can find notes or \nchords satisfying criteria that change from section to section of a piece, such as all notes that are the seventhdegree of the current key (as identified either manually or \nwith an included key-detection algorithm) and then retrieve information such as the last-defined clef, dynamic, \nor metrical accent level at that point. \n Many tools to visualize, process, and annotate \nStreams come with the music21 framework. These tools \ninclude graphing modules, analytical tools, and convenience routines for metrical analysis [8], phrase extraction, \nand identification of non-harmonic tones. Figure 2 demonstrates the use of metrical analysis, derived from \nnested hierarchical subdivisions of the time signature [1], \nto annotate two Bach chorales in different meters. \nfrom music21.analysis import metrical \n# load a Bach Chorale from the music21 corpus of supplied pieces \nbwv30_6 = corpus.parseWork('bach/bwv30.6.xml') \n# get just the bass part using DOM-like method calls\nbass = bwv30_6.getElementById('Bass') \n# get measures 1 through 10\nexcerpt = bass.getMeasureRange(1,10) \n# apply a Lerdahl/Jackendoff-style metrical analysis to the piece.\nmetrical.labelBeatDepth(excerpt) \n# display measure 0 (pickup) to measure 6 in the default viewer  \n# (here Finale Reader 2009)\nexcerpt.show() \n638\n11th International Society for Music Information Retrieval Conference (ISMIR 2010)\n\f#\nb\na\ne\nm\ne\nF\nla\nS\ntw\nw\nm\nta\np\na\nlo\na\nw\n# perform the same\nbwv11_6 = cor\nalto = bwv11_\nexcerpt = alt\nmetrical.labe\nexcerpt.show(\nFigure 2. Ana\nabeler, are inc\nStreams (includ\nwo Bach chora\nwith dots corres\n4\nIn addition\nmodern progra\nakes advantag\nproaches to sof\nand documenta\nongevity of the\nas the ability o\nwork of contrib\ne process on a diffe\nrpus.parseWor\n_6.getElement\nto.getMeasure\nelBeatDepth(e\n()\nalytical tools, s\ncluded with mu\nding Scores an\nales, each in a\nsponding to the\n4. FURTHER\nn to providing \namming langu\nge of some of\nftware distribut\nation. These a\ne system acros\nof the system t\nbutors. \nferent chorale in 3/\nrk('bach/bwv1\ntById('Alto')\neRange(13,20)\nexcerpt) \nsuch as this m\nusic21 and w\nnd Parts). Her\na different mete\neir metric stren\nR FEATURES \nsophisticated \nage, the musi\nf the best cont\ntion, licensing,\napproaches as\nss multiple pla\nto grow and in\n/4 time\n11.6.xml') \n)\n)\nmetrical accent\nork with most\nre, excerpts of\ner, are labeled\nngths. \nresources in a\nic21 package\ntemporary ap, development,\nsure both the\ntforms as well\nncorporate the\nt\nt\nf\nd\na\ne\n-,\ne\nl\ne\n4.1 An I\nResearc\nMusic\ntion of fr\nincluding\nnumerou\nRenaissa\ncorpus p\nURL bo\nries, ava\nwhen fir\nsearcher \nand Mus\nonly gro\ndepth of\n4.2 Perm\nMus\ntogether \ntoolkit is\nsoftware\nis releas\n(LGPL),\nsoftware\nsynchron\ndexed, a\nclasses, \ntest \nr\nweb.mit.\ncumentat\nrequests,\nBetter th\nspecific \nexample\nutility.  \n5.1 Find\nThe sc\npart of a\nop. 133, \nnant seve\nthe chor\nand the \nacross ba\nop133 = \n       \nviolin2 \n# an empt\ndisplay \nfor thi\n# get a l\n     # and re\n  notes \n  skipU\n  skipR\n  pitch\nIntegrated an\nhers\nc21 comes wit\nfreely-distributa\ng a complete \nus Beethoven \nance polyphon\npackage even \nokmarks to m\nailable online,\nrst requested a\nfor future use\nsicXML files.\nw the tools for\nf the corpus of w\nmissive Licens\nic21 is a tool\nin a wide ran\ns only achieved\ne components i\nsed under the\n allowing its u\ne. So that imple\nnized, the tool\nand searchable\nautomatically \nroutines. \nTh\n.edu/music21)\ntion and relea\n, and bug repor\n5.\nhan an explana\nexamples illus\ns are chosen \nding Chords w\ncript in Figure\na MusicXML s\nto find measu\nenth chords in \nrd in closed p\nForte prime \narlines would a\ncorpus.pars\n      'beet\n= op133.get\nty container for la\n= stream.St\nsMeasure in\nlist of consecutive \nests (and putting n\n= thisMeasu\nnisons = Tru\nests = True,\nes = stream.\nd Virtual Cor\nth a corpus pac\nable music for \ncollection of \nString Quarte\nny. The virtual\nfurther. Simila\nmusic resources\ncan be autom\nand then made\ne. The corpus\nFuture system\nr analysis, but \nworks. \nse and Full Do\nlkit: a collectio\nnge of context\nd if users can \nin their own w\ne Lesser Gen\nse within both \nementation and\nlkit also featu\ndocumentation\ncreated from \nhe\nmusic2\nhosts up-to-d\nase links. Cod\nrts are housed \nEXAMPLES\nation of high-l\nstrate the toolk\nfor both their \nwithin Melodic\n3 searches the\nscore of Beeth\nures that melod\nconsecutive n\nposition, the su\nform. (Runni\nadd just a few l\neWork( \nhoven/opus13\nElementById(\nter display \nream()  \nviolin2.meas\nnotes, skipping un\nnothing in their pla\nre.findConse\ne, skipOctav\nnoNone = Tr\nStream(notes\nrpus of Music \nckage, a large c\nanalysis and t\nthe Bach Ch\nts, and examp\nl corpus exten\nar to a collect\ns, additional re\nmatically down\ne available to t\n includes both\nm expansions w\nalso the bread\nocumentation\non of tools tha\nts. The promis\nexpand and int\nwork. Thus, mu\neral Public L\nfree and comm\nd documentatio\nures high-quali\nn of all modul\nthe source cod\n21 \nsite \ndate informatio\nde browsing, f\nat Google Cod\nS\nlevel features, \nkit\u2019s promise.\nnovel and pr\nc Fragments\ne entire second\nhoven\u2019s Gro\u00dfe\ndically express \nnotes. It then di\nurrounding me\ning the same \nlines of code).\n3.xml')  \n'2nd Violin'\nures: \nnisons, octaves, \naces)\ncutiveNotes(\nves = True,\nrue)\n).pitches \nfor \ncollectesting, \nhorales, \nples of \nnds the \ntion of \nepertonloaded \nthe reh Kern \nwill not \ndth and \nat work \nse of a \ntegrate \nsic21\nLicense \nmercial \non stay \nity, inles and \nde and \n(http:// \non, dofeature \nde.\na few \nThese \nractical \nd violin \ne Fuge,\ndomiisplays \neasure, \nquery \n)\n639\n11th International Society for Music Information Retrieval Conference (ISMIR 2010)\n\fd\nF\nm\n5\nto\nc\nn\nu\n(\nc\nty\nlo\ns\nT\nin\ntw\ng\nti\nf\nf\nf\n#\nm\nn\ng\ng\nfor i in ra\n   # makes eve\n   testChord\n   testChord\n   if testCh\n     # A domi\n      \n            #  We labe\n            #  and the f\n     testCho\n            \n     primeFo\n         thi\n     firstNo\n     firstNo\n            # Then we\n            #  by the m\n     chordMe\n     chordMe\n        test\n     display\n     display\ndisplay.show(\nFigure 3. The r\nmelodically. \n5.2 Distributio\nFigure 4 de\no help visualiz\ncern. These gra\nnotes, and how\nused. From two\na minuet, in re\ncan be seen tha\nype of bell-cu\now notes, and \nstral space. Ch\nThe difference\nnquiry is wort\nween duration \ngraphing metho\nion tool for th\nformats.  \nfrom music21.\nfrom music21.\n# display 3D grap\nmozartStream \n   xml.mozar\nnotes = mozar\ng = graph.Plo\n   notes, co\ng.process() \nange(len(pitc\nery set of 4 notes in\nd = chord.Cho\nd.duration.ty\nhord.isDomina\nnant-seventh chor\nel the chord with th\nfirst note of the m\nord.lyric = \"\n   thisMeasu\norm = chord.C\nisMeasure.pit\note = thisMea\note.lyric = p\ne append the chor\nmeasure containing\neasure = stre\neasure.append\ntChord.closed\ny.append(chor\ny.append(this\n()\nresults of a sea\nons of Notes b\nemonstrates th\nze trends that a\naphs plot three\nw frequently the\no small excerpt\ned) and by Ch\nat pitches in th\nurve distributio\nmany notes to\nhopin\u2019s usage j\ns in pitch usa\nth pursuing fur\nand pitch app\nods help resear\nheir data, easil\n.musicxml imp\n.humdrum impo\nphs of count, pitch,\n= music21.pa\nrtTrioK581Exc\nrtStream.flat\not3DBarsPitch\nolors=['r']) \nches) - 3): \nnto a whole-note c\nord(pitches[i\nype = \"whole\"\nantSeventh():\nrd was found in thi\nhe measure numbe\nmeasure with the Fo\n\"m. \" + str( \nure.measureNu\nChord( \ntches).primeF\nasure.notes[0\nprimeForm    \nrd in closed positio\ng the chord. \neam.Measure()\nd(\ndPosition()) \nrdMeasure) \nsMeasure) \narch for chords\nby Pitch and D\nhe ability of mu\nare otherwise d\ne features: pitc\nese pitches and\nts of pieces in \nopin (a mazurk\nhe Mozart exa\nn, with few hi\noward the midd\njumps through\nage suggest th\nrther, but no c\nears. Music21\nrchers find the \nly switching a\nport testFile\nort testFiles\n, and duration\narse( \ncerpt) \nt.stripTies()\nhSpaceQuarter\nchord\ni:i+4])     \n\"\n:\nis measure. \ner\norte Prime form\number) \nFormString \n0]\n     \non followed \n)\ns expressed \nDuration \nusic21 graphs\ndifficult to disch, duration of\nd durations are\n3/4 by Mozart\nka, in blue), it\nample follow a\nigh notes, few\ndle of the regihout the piano.\nat this line of\nconnection be1\u2019s easy-to-use\nbest visualizaamong diverse\nes as xml \ns as kern \n)\nrLength( \n      \ns\n-f\ne\nt\nt\na\nw\n-\nf\n-e\n-e\n# perform \nchopinS\nnotes = \ng = grap\n    not\ng.proce\nFigure 4\nMozart a\nThe\ndistinctiv\ntween pi\ntreme e\nd\u2019intensi\nfirst wor\ntween pi\n(isolated\nthe same process o\ntream = musi\nchopinStrea\nph.Plot3DBar\nes, colors=[\nss() \n4. Differences\nand Chopin. \nMozart and \nve individual \nitch and durati\nexample is M\nit\u00e9s\u201d from Qua\nrk of total ser\nitch and durat\nd for clarity), is\non a different work\nc21.parse(ke\nm.flat.strip\nsPitchSpaceQ\n'b']) \ns in pitch dist\nChopin examp\nusage, show \nion. Many oth\nMessiaen\u2019s \u201cM\natre \u00e9tudes de \nrialism. A per\ntion, as found \ns plotted in Fi\nk\nrn.mazurka6)\nTies() \nuarterLength\ntribution betwe\nples, while sh\nlittle correlatio\ner pieces do. A\nMode de vale\nrythme, perha\nrfect correlatio\nin the middle\ngure 5. An asp\nh(\neen\nhowing \non beAn exurs et \naps the \non bee voice \npect of \n640\n11th International Society for Music Information Retrieval Conference (ISMIR 2010)\n\fthe composition that is difficult to observe in the score \nbut easy to see in this graph is the cubic shape (-x3) made \nthrough the choice of pitches and rhythms. This shape is \nnot at all explained by the serial method of the piece.  Also easily seen is that, although Messiaen uses lower notes \nless often, there is not a perfect correlation between pitch \nand frequency of use (e.g., 21 B-flats vs. 22 A-flats). \nmessiaen = converter.parse( \n               'd:/valeurs_part2.xml') \nnotes = messiaen.flat.stripTies() \ng = graph.PlotScatterWeightedPitch\\ \n    SpaceQuarterLength(notes, xLog = False, \n    title='Messiaen, Mode de Valeurs, \n    middle voice') \ng.process() \nFigure 5. A graph of pitch to duration relationships in \nMessiaen, \u201cMode de valeurs,\u201d showing the correlation \nbetween the two note attributes. \n5.3 Pitch Class Density Over Time \nIn Figure 6, pitch class usage, over the duration of \nthe composition in the cello part of a MusicXML score of \nBeethoven\u2019s Gro\u00dfe Fuge, is graphed. Even though the \ntemporal resolution of this graph is coarse, it is clear that \nthe part gets less chromatic towards the end of the work.  \n(We have manually highlighted the tonic and dominant in \nthis example.) \nbeethovenScore = corpus.parseWork('opus133.xml') \ncelloPart = \\ \n      beethovenScore.getElementById('Cello') \n# given a \u201cflat\u201d view of the stream, with nested information  \n# removed and all information at the same hierarchical level, \n# combine tied notes into single notes with summed durations \nnotes = celloPart.flat.stripTies() \ng = graph.PlotScatterPitchClassOffset(notes, \n    title='Beethoven Opus 133, Cello') \ng.process() \nFigure 6. A graph of pitch class usage over time in \nBeethoven\u2019s Gro\u00dfe Fuge.\n5.4 Testing Nicolaus de Capua\u2019s Regulae of Musica \nFicta\nThis example shows a sophisticated, musicological \napplication of music21. Among his other writings, the \nearly-fifteenth century music theorist Nicolaus of Capua \ngave a set of regulae, or rules, for creating musica ficta\n[5]. Musica ficta, simply put, was a way of avoiding tritones and other undesirable intervals and create more \nconclusive cadences through the use of unwritten accidentals that performers would know to sing. Unlike the \nrules of most other theorists of his time, Nicolaus\u2019s four \nrules rely solely on the melodic intervals of one voice. \nHerlinger\u2019s study of Nicolaus\u2019s rules suggested that they \ncould be extremely successful at eliminating harmonic \nproblems while at the same time being easy enough for \nany musician to master. However, as is conventional in \nmusicology, this study was performed by hand on a few \nexcerpts of music by a single composer, Antonio Zachara \nda Teramo. Using music21 we have been able to automatically apply Nicolaus\u2019s rules to a much wider set of \nencoded music, the complete incipits and cadences of all \nTrecento ballate (about 10,000 measures worth of music) \nand then automatically evaluate the quality of harmonic \nchanges implied by these rules. Figure 7 shows an excerpt of the code for a single rule, that a descending major second (\u201cM-2\u201d) immediately followed by an ascending major second (\u201cM2\u201d) should be transformed into two \nhalf-steps by raising the middle note: \n# n1, n2, and n3 are three consecutive notes \n# i1 is the interval between n1 and n2\n# i2 is the interval between n2 and n3\ni1 = generateInterval(n1,n2) \ni2 = generateInterval(n2,n3) \n# we test if the two intervals are the ones fitting the rule\nif i1.directedName == \"M-2\" and \\ \n   i2.directedName == \"M2\":\n  # since the intervals match , we add an editorial accidental\n  n2.editorial.ficta = \\  \n         Accidental(\"sharp\")\n641\n11th International Society for Music Information Retrieval Conference (ISMIR 2010)\n\f# we also color the affected notes so that if we display the music \n  # the notes stick out.  Different colors indicate different rules \n  n1.editorial.color = \"blue\"\n  n2.editorial.color = \"forestGreen\"\n  n3.editorial.color = \"blue\"\nFigure 7. Applying ficta accidentals with music21.\nThe results of applying one or all the rules to an individual cadence or piece can be seen immediately. Figure 8 shows the rules applied to one piece where they \ncreate two \u201cclosest-approaches\u201d to perfect consonances \n(major sixth to octave and minor third to unison). These \nare the outcomes one expects from a good set of regulae\nfor musica ficta.\n    # get a particular worksheet of an Excel spreadsheet\nballataObj = cadencebook.BallataSheet() \n    # create an object for row 267\npieceObj = ballataObj.makeWork(267)  \n    # run the four rules (as described above)\napplyCapua(pieceObj) \n    # display the first cadence of the piece (second snippet) by \n    # running it through Lilypond and generating a PNG file\npieceObj.snippets[1].lily.showPNG() \nFigure 8. Music21 code for automatically adding musica \nficta to Francesco (Landini), De[h], pon\u2019 quest\u2019amor, \nfirst cadence. \nIn other pieces, Nicolaus\u2019s rules have an injurious effect, \nas Figure 9 shows. With the toolkit, we were able to run \nthe rules on the entire database of Trecento ballatas and \ndetermine that Nicolaus\u2019s rules cannot be used indiscriminately. Far too many cases appeared where the proposed ficta hurt the harmony. One of the main advantages \nof the music21 framework is making such observations \non large collections of musical data possible. \nFigure 9. Francesco, D\u2019amor mi biasmo, incipit after automatically applying ficta accidentals. \n6. FUTURE WORK \nThe first alpha releases of music21 introduce fundamental objects and containers and, as shown above, \noffer powerful tools for symbolic music processing. \nThe next stage of development will add native support for additional input and output formats, including \nMIDI. Further, libraries of additional processing, analysis, visualization routines, as well as new and expanded \nobject models (such as non-Western scales), will be added to the system. We are presently focusing on creating \nsimple solutions for common-practice music theory tasks \nvia short music21 scripts, and within a year hope to be \nable to solve almost every common music theory problem \nencountered by first-year conservatory students. \n7. ACKNOWLEDGEMENTS \nThe authors thank the Seaver Institute for their generous funding of music21. Additional thanks are also \nextended to three anonymous reviewers for their helpful \ncomments. \n8. REFERENCES \n[1] Ariza, C. and M. Cuthbert. 2010. \u201cModeling Beats, \nAccents, Beams, and Time Signatures Hierarchically \nwith music21 Meter Objects.\u201d In Proceedings of the \nInternational Computer Music Conference. San \nFrancisco: International Computer Music Association. \n[2] Buxton, W. and W. Reeves, R. Baecker, L. Mezei. \n1978. \u201cThe Use of Hierarchy and Instance in a Data \nStructure for Computer Music.\u201d Computer Music \nJournal 2 (4): 10-20. \n[3] Cook, N. 2004. \u201cComputational and Comparative \nMusicology.\u201d \nIn \nEmpirical \nMusicology: \nAims, \nMethods, Prospects. N. Cook and E. Clarke, eds. New \nYork: Oxford University Press. 103-126. \n[4] Good, M. 2001. \u201cAn Internet-Friendly Format for \nSheet Music.\u201d In Proceedings of XML 2001.\n[5] Herlinger, J. 2004. \u201cNicolaus de Capua, Antonio Zacara da Teramo, and musica ficta.\u201d In Antonio Zacara \nda Teramo e il suo tempo. F. Zimei, ed. Lucca: LIM. \n67\u201389.\n[6] Huron, D. 1997. \u201cHumdrum and Kern: Selective \nFeature Encoding.\u201d In Beyond MIDI: the Handbook \nof Musical Codes. E. Selfridge-Field, ed. Cambridge: \nMIT Press. 375-401. \n[7] \nKnopke, \nI. \n2008. \n\u201cThe \nPerlHumdrum \nand \nPerlLilypond \nToolkits \nfor \nSymbolic \nMusic \nInformation Retrieval.\u201d ISMIR 2008 147-152. \n[8] Lerdahl, F. and R. Jackendoff. 1983. A Generative \nTheory of Tonal Music. Cambridge: MIT Press. \n[9] Pope, S. T. 1987. \u201cA Smalltalk-80-based Music \nToolkit.\u201d In Proceedings of the International \nComputer \nMusic \nConference. \nSan \nFrancisco: \nInternational Computer Music Association. 166-173. \n[10] Pope, S. T. 1989. \u201cMachine Tongues XI: ObjectOriented Software Design.\u201d Computer Music Journal\n13 (2): 9-22. \n[11] Sapp, C. S. 2008. \u201cMuseinfo: Musical Information \nProgramming \nin \nC++.\u201d \nInternet: \nhttp://museinfo.sapp.org. \n642\n11th International Society for Music Information Retrieval Conference (ISMIR 2010)\n\f", "text_mmd": "# music21: A Toolkit for Computer-Aided Musicology and Symbolic Music Data\n\n###### Abstract\n\nMusic21 is an object-oriented toolkit for analyzing, searching, and transforming music in symbolic (score-based) forms. The modular approach of the project allows musicians and researchers to write simple scripts rapidly and reuse them in other projects. The toolkit aims to provide powerful software tools integrated with sophisticated musical knowledge to both musicians with little programming experience (especially musicologists) and to programmers with only modest music theory skills.\n\nThis paper introduces the music21 system, demonstrating how to use it and the types of problems it is well-suited toward advancing. We include numerous examples of its power and flexibility, including demonstrations of graphing data and generating annotated musical scores.\n\nMusic21 Music21 Music21 Music21 Music21 Music21 Music21 Music21 Music21 Music21 Music21 Music21 Music21 Music21 Music21\n\n## 1 Introduction: Why Music21?\n\nComputers have transformed so many aspects of musicology--from writing and editing papers, to studying manuscripts with digital files, to creating databases of composers' letters, to typesetting editions--that it is incredible that most analytical tasks that music historians perform remain largely untouched by technology. The study of the rich troves of musical data in scores, sketches, intabulations, lead-sheets, and other sources of symbolic music data is still done almost exclusively by hand. Even when databases and spreadsheets are employed, they are usually created for a single purpose. Such specialized approaches cannot easily be reused.\n\nComputer scientists often assume that, compared to working with scanned images of scores or sound files, manipulating symbolic data should be a cinch. Most of the information from a score can easily be converted to text-based or numeric formats that general-purpose statistical or information-retrieval tools can manipulate. In practice the complexities of music notation and theory result in these tools rarely being sufficient.\n\nFor instance, a researcher might want to compare how closely the music of two composers adheres to a particular scale (say, the major scale). What begins as a straightforward statistical problem requiring little musical knowledge--simply encode which notes are in the scale of the piece's key and which are not--can quickly grow beyond the capabilities of general statistics packages. Suppose that after some initial work, our researcher decides that notes on stronger beats should be weighed more heavily than those on weaker beats. Now the must either add the information about beats by hand to each note or write a new algorithm that labels the beats. Beat labeling is another task that initially seems easy but rapidly becomes extremely troublesome for several reasons. Are grace-notes accented or unaccented? Only a musical-ly-trained ear that also knows the norms of an era can tell. Incompletely-filled measures, such as pickup measures and mid-bar repeats, present problems for algorithms. As the researcher's corpus expands, the time spent on measurement expands with it. What began as a straightforward project becomes a set of tedious separate labors: transforming data from multiple formats into one, moving transposing instruments into sounding pitch, editorial accidentals in early music, or finding ways of visualizing troublesome moments for debugging.\n\nResearchers in other fields can call upon general-purpose toolkits to deal with time-consuming yet largely solved problems. For instance, a scientist working with a large body of text has easy access to open-source libraries for removing punctuation, converting among text-encoding formats, correcting spelling, identifying parts of speech, sentence diagramming, automatic translation, and of course rendering text in a variety of media. Libraries and programs to help with the musical equivalents of each of these tasks do exist, but few exchange data with each other in standardized formats. Even fewer are designed in modern, high-level programming languages. As a result of these difficulties, computational solutions to musicological problems are rarely employed even when they would save time, expand the scope of projects, or quickly find important exceptions to overly broad pronouncements.\n\nThe music21 project ([http://web.mit.edu/music21](http://web.mit.edu/music21)) expands the audience for computational musicology by creating a new toolkit built from the ground up with intuitive simplicity and object-oriented design throughout. (The \"21\" in the title comes from the designation for MIT's classes in Music, Course 21M, The advantages of object-oriented design have led to its wide adoption in many realms of software engineering. These design principles have been employed in music synthesis and generation systems over the past 25 years [2, 9, 10] but have not been thoroughly integrated into packages for the analysis of music as symbolic data. Hundrum, the most widely adopted software package [6], its contemporary ports [7, 11], and publications using these packages show the great promise of computational approaches to music theory and musicology. Yet Hundrum can be difficult to use: both programmers and non-programmers alike may find its reliance on a chain of shell-scripts, rather than object-oriented libraries, limiting and not intuitive.\n\nNicholas Cook has called upon programmers to create for musicologists \"a modular approach involving\n\n[MISSING_PAGE_FAIL:2]\n\n## 4 Further Features\n\nIn addition to providing sophisticated resources in a modern programming language, the music21 package takes advantage of some of the best contemporary approaches to software distribution, licensing, development, and documentation. These approaches assure both the longevity of the system across multiple platforms as well as the ability of the system to grow and incorporate the work of contributors.\n\n### An Integrated and Virtual Corpus of Music for Researchers\n\nMusic21 comes with a corpus package, a large collection of freely-distributable music for analysis and testing, including a complete collection of the Bach Chorales, numerous Bechwine String Quartets, and examples of Renaissance polyphony. The virtual corpus extends the corpus package even further. Similar to a collection of URL bookmarks to music resources, additional repertoires, available online, can be automatically downloaded when first requested and then made available to the researcher for future use. The corpus includes both Kern and MusicXML files. Future system expansions will not only grow the tools for analysis, but also the breadth and depth of the corpus of works.\n\n### Permissive License and Full Documentation\n\nMusic21 is a toolkit: a collection of tools that work together in a wide range of contexts. The promise of a toolkit is only achieved if users can expand and integrate software components in their own work. Thus, music21 is released under the Lesser General Public License (LGPL), allowing its use within both free and commercial software. So that implementation and documentation stay synchronized, the toolkit also features high-quality, indexed, and searchable documentation of all modules and classes, automatically created from the source code and test routines. The music21 site ([http://web.mit.edu/music21](http://web.mit.edu/music21)) hosts up-to-date information, documentation and release links. Code browsing, feature requests, and bug reports are housed at Google Code.\n\n## 5 Examples\n\nBetter than an explanation of high-level features, a few specific examples illustrate the toolkit's promise. These examples are chosen for both their novel and practical utility.\n\n### Finding Chords within Melodic Fragments\n\nThe script in Figure 3 searches the entire second violin part of a MusicXML score of Bechowen's _Grofe Fuge_, op. 133, to find measures that medically express dominant seventh chords in consecutive notes. It then displays the chord in closed position, the surrounding measure, and the Forte prime form. (Running the same query across barlines would add just a few lines of code).\n\nop133 = corpus.parseMork{'beethoven/opus133.xml'} violin2 = op133.getElementById('2nd Violin')\n\n_# an empty container for later display_ display = stream.Stream()\n\n**for** thisMeasure**in** violin2.measures:\n\n_# got a list of consecutive notes, skipping unions, octaves, #and runs (and run putting nothing in their places)_ notes = thisMeasure.ritolConnecutiveNotes( skipUnions=True, skipOtaves=True, skipBests=True, noNone=True)\n\npitches = stream.Stream(notes).pitches\n\nFigure 2: Analytical tools, such as this metrical accent labeler, are included with music21 and work with most Streams (including Scores and Parts). Here, excerpts of two Bach chorales, each in a different meter, are labeled with dots corresponding to their metric strengths.\n\n### Distributions of Notes by Pitch and Duration\n\nFigure 4 demonstrates the ability of music21 graphs to help visualize trends that are otherwise difficult to discern. These graphs plot three features: pitch, duration of notes, and how frequently these pitches and durations are used. From two small excepts of pieces in 3/4 by Mozart (a minur, in red) and by Chopin (a maxurka, in blue), it can be seen that pitches in the Mozart example follow a type of bell-curve distribution, with few high notes, few low notes, and many notes toward the middle of the registral space. Chopin's usage jumps throughout the piano. The differences in pitch usage suggest that this line of inquiry is worth pursuing further, but no connection between duration and pitch appears. Music21's easy-to-use graphing methods help researchers find the best visualization tool for their data, easily switching among diverse formats.\n\n```\nfrommusic21.musicom1importtestFilesasxml frommusic21.humdrumimporttestFilesaskern\n```\n#display3Dgraphsofcount,pitch,andduration mozartStream=music21.parse() xml.mozartFlor658Iklecar.notes=mozartStream.flat.stripTries() q=graph.Plot3DBarsaPitchSpaceQuarterLength(notes,colors=['r']) q.process() ```\n\nThe Mozart and Chopin examples, while showing distinctive individual usage, show little correlation between pitch and duration. Many other pieces do. An extreme example is Messian's \"Mode de valeurs et d'intensities\" from _Quatre eudes de rythme_, perhaps the first work of total serialism. A perfect correlation between pitch and duration, as found in the middle voice (isolated for clarity), is plotted in Figure 5. An aspect of\n\nFigure 4: Differences in pitch distribution between Mozart and Chopin.\n\nFigure 3: The results of a search for chords expressed melodically.\n\nthe composition that is difficult to observe in the score but easy to see in this graph is the cubic shape (:-x) made through the choice of pitches and rhythms. This shape is not at all explained by the serial method of the piece. Also easily seen is that, although Messiainen uses lower notes less often, there is not a perfect correlation between pitch and frequency of use (e.g., 21 B-flats vs. 22 A-flats).\n\n### Pitch Class Density Over Time\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.1 **Pitch Class Density Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.2 **Pitch Class Density Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.3 **Pitch Class Density Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.4 **Pitch Class Density Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.5 **Pitch Class Density Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.6 **Pitch Class Density Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.7 **Pitch Class Density Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.8 **Pitch Class Density Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.9 **Pitch Class Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.1 **Pitch Class Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.1 **Pitch Class Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.1 **Pitch Class Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.2 **Pitch Class Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.3 **Pitch Class Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.4 **Pitch Class Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.5 **Pitch Class Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.6 **Pitch Class Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.7 **Pitch Class Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.8 **Pitch Class Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.9 **Pitch Class Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.1 **Pitch Class Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.1 **Pitch Class Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.1 **Pitch Class Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.1 **Pitch Class Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.1 **Pitch Class Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.2 **Pitch Class Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.3 **Pitch Class Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is clear that the part gets less chromatic towards the end of the work. (We have manually highlighted the tonic and dominant in this example.)\n\n#### 5.3.4 **Pitch Class Over Time**\n\nIn Figure 6, pitch class usage, over the duration of the composition in the cello part of a MusicXML score of Beethoven's _Grose Fuge_, is graphed. Even though the temporal resolution of this graph is coarse, it is graphed. Even though the temporal resolution of this graph is coarse, it is graphed. Even though the temporal resolution of this graph is graphed. Even though the temporal resolution of this graph is fine, it is graphed. Even though the temporal resolution of this graph is fine, it is graphed.\n\nIn other pieces, Nicolaus's rules have an injurious effect, as Figure 9 shows. With the toolkit, we were able to run the rules on the entire database of Trecento ballatas and determine that Nicolaus's rules cannot be used indiscriminately. Far too many cases appeared where the proposed _ficta_ hurt the harmony. One of the main advantages of the music21 framework is making such observations on large collections of musical data possible.\n\n## 6 Future Work\n\nThe first alpha releases of music21 introduce fundamental objects and containers and, as shown above, offer powerful tools for symbolic music processing.\n\nThe next stage of development will add native support for additional input and output formats, including MIDI. Further, libraries of additional processing, analysis, visualization routines, as well as new and expanded object models (such as non-Western scales), will be added to the system. We are presently focusing on creating simple solutions for common-practice music theory tasks via short music21 scripts, and within a year hope to be able to solve almost every common music theory problem encountered by first-year conservatory students.\n\n## 7 Acknowledgements\n\nThe authors thank the Seaver Institute for their generous funding of music21. Additional thanks are also extended to three anonymous reviewers for their helpful comments.\n\n## References\n\n* [1] Ariza, C. and M. Cuthbert. 2010. \"Modeling Beats, Accents, Beams, and Time Signatures Hierarchically with music21 Meter Objects.\" In _Proceedings of the International Computer Music Conference_. San Francisco: International Computer Music Association.\n* [2] Buxton, W. and W. Reeves, R. Baecker, L. Mezei. 1978. \"The Use of Hierarchy and Instance in a Data Structure for Computer Music.\" _Computer Music Journal_ 2 (4): 10-20.\n* [3] Cook, N. 2004. \"Computational and Comparative Musicology.\" In _Empirical Musicology: Aims, Methods, Prospects_. N. Cook and E. Clarke, eds. New York: Oxford University Press. 103-126.\n* [4] Good, M. 2001. \"An Internet-Friendly Format for Sheet Music.\" In _Proceedings of XML 2001_.\n* [5] Herlinger, J. 2004. \"Nicolaus de Capua, Antonio Zacara da Teramo, and _musica ficta_.\" In _Antonio Zacara da Teramo e il suo tempo_. F. Zimei, ed. Lucca: LIM. 67-89.\n* [6] Huron, D. 1997. \"Humdrum and Kern: Selective Feature Encoding.\" In _Beyond MIDI: the Handbook of Musical Codes_. E. Selfridge-Field, ed. Cambridge: MIT Press. 375-401.\n* [7] Knopke, I. 2008. \"The PerlHumdrum and PerlLibpond Toolkits for Symbolic Music Information Retrieval.\" _ISMR 2008_ 147-152.\n* [8] Lerdahl, F. and R. Jackendorf. 1983. _A Generative Theory of Tonal Music_. Cambridge: MIT Press.\n* [9] Pope, S. T. 1987. \"A Smalltalk-80-based Music Toolkit.\" In _Proceedings of the International Computer Music Conference_. San Francisco: International Computer Music Association. 166-173.\n* [10] Pope, S. T. 1989. \"Machine Tongues XI: Object-Oriented Software Design.\" _Computer Music Journal_ 13 (2): 9-22.\n* [11] Sapp, C. S. 2008. \"Museinfo: Musical Information Programming in C++.\" Internet: [http://museinfo.sapp.org](http://museinfo.sapp.org).\n\nFigure 8: Music21 code for automatically adding _musica ficta_ to Francesco (Landini), _De[h], pon\u2019 quest amor_, first cadence.\n\nFigure 7: Applying ficta accidentals with music21.\n\nFigure 9: Francesco, _D\u2019amor mi biasmo_, incipit after automatically applying _ficta_ accidentals."}, "BIBREF306": {"title": "Learning to generate music with sentiment", "authors": [{"first": "Lucas", "middle": [], "last": "Ferreira", "suffix": ""}, {"first": "Jim", "middle": [], "last": "Whitehead", "suffix": ""}], "venue": "ISMIR", "volume": "", "issue": "", "pages": "384--390", "text_pymu": "LEARNING TO GENERATE MUSIC WITH SENTIMENT\nLucas N. Ferreira\nUniversity of California, Santa Cruz\nDepartment of Computational Media\nJim Whitehead\nUniversity of California, Santa Cruz\nDepartment of Computational Media\nABSTRACT\nDeep Learning models have shown very promising results in automatically composing polyphonic music pieces.\nHowever, it is very hard to control such models in order to\nguide the compositions towards a desired goal. We are interested in controlling a model to automatically generate\nmusic with a given sentiment. This paper presents a generative Deep Learning model that can be directed to compose music with a given sentiment. Besides music generation, the same model can be used for sentiment analysis\nof symbolic music. We evaluate the accuracy of the model\nin classifying sentiment of symbolic music using a new\ndataset of video game soundtracks. Results show that our\nmodel is able to obtain good prediction accuracy. A user\nstudy shows that human subjects agreed that the generated\nmusic has the intended sentiment, however negative pieces\ncan be ambiguous.\n1. INTRODUCTION\nMusic Generation is an important application domain of\nDeep Learning in which models learn musical features\nfrom a dataset in order to generate new, interesting music.\nSuch models have been capable of generating high quality\npieces of different styles with strong short-term dependencies 1 [2]. A major challenge of this domain consists of\ndisentangling these models to generate compositions with\ngiven characteristics. For example, one can\u2019t easily control a model trained on classical piano pieces to compose\na tense piece for a horror scene of a movie. Being able\nto control the output of the models is specially important\nfor the field of Affective Music Composition, whose major\ngoal is to automatically generate music that is perceived\nto have a specific emotion or to evoke emotions in listeners [19]. Applications involve generating soundtracks for\nmovies and video-games [18], sonification of biophysical\ndata [3] and generating responsive music for the purposes\nof music therapy and palliative care [9].\nRecently, Radford et al. [13] showed that a generative Long short-term memory (LSTM) neural network can\n1 Supporting strong long-term dependencies (music form) is still an\nopen problem.\n\u00a9 Lucas N. Ferreira, Jim Whitehead. Licensed under a Creative Commons Attribution 4.0 International License (CC BY 4.0). Attribution:\nLucas N. Ferreira, Jim Whitehead. \u201cLearning to Generate\nMusic With Sentiment\u201d, 20th International Society for Music Information Retrieval Conference, Delft, The Netherlands, 2019.\nlearn an excellent representation of sentiment (positivenegative) on text, despite being trained only to predict the\nnext character in the Amazon reviews dataset [6]. When\ncombined to a Logistic Regression, this LSTM achieves\nstate-of-the-art sentiment analysis accuracy on the Stanford Sentiment Treebank dataset and can match the performance of previous supervised systems using 30-100x\nfewer labeled examples.\nThis LSTM stores almost all\nof the sentiment signal in a distinct \u201csentiment neuron\u201d,\nwhich can be used to control the LSTM to generate sentences with a given sentiment. In this paper, we explore\nthis approach with the goal of composing symbolic music\nwith a given sentiment. We also explore this approach as a\nsentiment classifier for symbolic music.\nIn order to evaluate this approach, we need a dataset of\nmusic in symbolic format that is annotated by sentiment.\nEven though emotion detection is an important topic in\nmusic information retrieval [7], it is typically studied on\nmusic in audio format. To the best of our knowledge, there\nare no datasets of symbolic music annotated according to\nsentiment. Therefore, we created a new dataset composed\nof 95 MIDI labelled piano pieces (966 phrases of 4 bars)\nfrom video game soundtracks. Each piece is annotated by\n30 human subjects according to a valence-arousal (dimensional) model of emotion [15]. The sentiment of each piece\nis then extracted by summarizing the 30 annotations and\nmapping the valence axis to sentiment. The same dataset\nalso contains another 728 non-labelled pieces, which were\nused for training the generative LSTM.\nWe combine this generative LSTM with a Logistic\nRegression and analyse its sentiment prediction accuracy\nagainst a traditional classification LSTM trained in a fullysupervised way. Results showed that our model (generative LSTM with Logistic Regression) outperformed the supervised LSTM by approximately 30%. We also analysed\nthe generative capabilities of our model with a user study.\nHuman subjects used an online annotation tool to label 3\npieces controlled to be negative and 3 pieces controlled to\nbe positive. Results showed human annotators agree the\ngenerated positive pieces have the intended sentiment. The\ngenerated negative pieces appear to be ambiguous, having\nboth negative and positive parts.\nWe believe this paper is the first work to explore sentiment analysis in symbolic music and it presents the first\ndisentangled Deep Learning model for music generation\nwith sentiment. Another contribution of this paper is a labelled dataset of symbolic music annotated according to\nsentiment. These contributions open several direction for\narXiv:2103.06125v1  [cs.LG]  9 Mar 2021\n\ffuture research, specially music generation with emotions\nas both a multi-class problem and as a regression problem. Moreover, these methods could be applied to create\nsoundtrack generation systems for films, video games, interactive narratives, audio books, etc.\n2. RELATED WORK\nThis paper is related to previous work on Affective Algorithmic Music Composition, more specifically to works\nthat process music in symbolic form in order to generate\nmusic with a given emotion. A common approach for this\nproblem consists of designing a rule-based system to map\nmusical features to a given emotion in a categorical or dimensional space [19]. For example, Williams et al. [18]\npropose a system to generate soundtracks for video games\nwhere each game\u2019s scene graph (defining all the possible branching of scenes in the game) is annotated according to a valence-arousal model. A second-order Markov\nmodel is used to learn melodies from a dataset and are\nthen transformed by a rule-based system to fit the annotated emotions in the graph. Davis and Mohammad [4]\nfollow a similar approach in TransPose, a system that composes piano melodies for novels. TransPose uses a lexiconbased approach to automatically detect emotions (categorical model) in novels and a rule-based technique to create\npiano melodies with these emotions.\nThere are a few other approaches in the literature to\ncompose music with a given emotion. Scirea et al. [16]\nrecently presented a framework called MetaCompose designed to create background music for games in real-time.\nMetaCompose generates music by (i) randomly creating\na chord sequence from a pre-defined chord progression\ngraph, (ii) evolving a melody for this chord sequence using a genetic algorithm and (iii) producing an accompaniment for the melody/chord sequence combination. Monteith et al. [10] approaches Affective Algorithmic Music\nComposition from a Machine Learning perspective to learn\nmelodies and rhythms from a corpus of music labeled according to a categorical model of emotion. Individual Hidden Markov models and n-grams are trained for each category to generate pitches and underlying harmonies, respectively. Rhythms are sampled randomly from examples of a\ngiven category.\nDeep Learning models have recently achieved highquality results in music composition with short-term dependencies [2]. These models normally are trained on a\ncorpus of MIDI files to predict the next note to be played\nbased on a given note. In general, these models can\u2019t be\nmanipulated to generate music with a given emotion. For\nexample, in the system DeepBach, Hadjeres et al. [5] use a\ndependency network and a Gibbs-like sampling procedure\nto generate high-quality four-part chorales in the style of\nBach. Roberts et at. [14] train recurrent variational autoencoder (VAEs) to reproduce short musical sequences and\nwith a novel hierarchical decoder they are able to model\nlong sequences with musical structure for both individual\ninstruments and a three-piece band (lead, bass, and drums).\nThe majority of the deep learning models are trained\nto generate musical scores and not performances. Oore et\nal. [11] tackles this problem by training an LSTM with a\nnew representation that supports tempo and velocity events\nfrom MIDI files. This model was trained on the Yamaha\ne-Piano Competition [1], which contains MIDI captures\nof ~1400 performances by skilled pianists.\nWith this\nnew representation and dataset, Oore et al. [11] generated\nmore human-like performances when compared to previous models.\n3. MODEL\nWe propose a Deep Learning method for affective algorithmic composition that can be controlled to generate music\nwith a given sentiment. This method is based on the work\nof Radford et al. [13] which generates product reviews (in\ntextual form) with sentiment. Radford et al. [13] used a\nsingle-layer multiplicative long short-term memory (mLSTM) network [8] with 4096 units to process text as a sequence of UTF-8 encoded bytes (character-based language\nmodeling). For each byte, the model updates its hidden\nstate of the mLSTM and predicts a probability distribution\nover the next possible byte.\nThis mLSTM was trained on the Amazon product review dataset, which contains over 82 million product reviews from May 1996 to July 2014 amounting to over 38\nbillion training bytes [6].\nRadford et al. [13] used the\ntrained mLSTM to encode sentences from four different\nSentiment Analysis datasets. The encoding is performed\nby initializing the the states to zeros and processing the sequence character-by-character. The final hidden states of\nthe mLSTM are used as a feature representation. With the\nencoded datasets, Radford et al. [13] trained a simple logistic regression classifier with L1 regularization and outperformed the state-of-the-art methods at the time using\n30-100x fewer labeled examples.\nBy inspecting the relative contributions of features on\nvarious datasets, Radford et al. [13] discovered a single\nunit within the mLSTM that directly corresponded to sentiment. Because the mLSTM was trained as a generative\nmodel, one can simply set the value of the sentiment unit\nto be positive or negative and the model generates corresponding positive or negative reviews.\n3.1 Data Representation\nWe use the same combination of mLSTM and logistic regression to compose music with sentiment. To do this, we\ntreat the music composition problem as a language modeling problem. Instead of characters, we represent a music\npiece as a sequence of words and punctuation marks from a\nvocabulary that represents events retrieved from the MIDI\nfile. Sentiment is perceived in music due to several features\nsuch as melody, harmony, tempo, timbre, etc [7]. Our data\nrepresentation attempts to encode a large part of these features 2 using a small set of words:\n\u2022 \u201cn_[pitch]\u201d: play note with given pitch number: any\ninteger from 0 to 127.\n2 Constrained by the features one can extract from MIDI data.\n\ft_120 v_76 d_whole_0 n_50 n_54 n_57\nv_92 d_eighth n_86 . . v_84\nd_quarter_1 n_81 . .\nFigure 1: A short example piece encoded using our proposed representation. The encoding represents the first two\ntime steps of the shown measure.\n\u2022 \u201cd_[duration]_[dots]\u201d: change the duration of the\nfollowing notes to a given duration type with a given\namount of dots. Types are breve, whole, half, quarter, eighth, 16th and 32nd. Dots can be any integer\nfrom 0 to 3.\n\u2022 \u201cv_[velocity]\u201d: change the velocity of the following\nnotes to a given velocity (loudness) number. Velocity is discretized in bins of size 4, so it can be any\ninteger in the set V = 4, 8, 12, . . . , 128.\n\u2022 \u201ct_[tempo]\u201d: change the tempo of the piece to a\ngiven tempo in bpm. Tempo is also discretized in\nbins of size 4, so it can be any integer in the set\nT = 24, 28, 32, . . . , 160.\n\u2022 \u201c.\u201d: end of time step. Each time step is one sixteenth\nnote long.\n\u2022 \u201c\\n\u201d: end of piece.\nFor example, Figure 1 shows the encoding of the first\ntwo time steps of the first measure of the Legend of Zelda\n- Ocarina of Time\u2019s Prelude of Light. The first time step\nsets the tempo to 120bpm, the velocity of the following\nnotes to 76 and plays the D Major Triad for the duration\nof a whole note. The second time step sets the velocity\nto 84 and plays a dotted quarter A5 note. The total size\nof this vocabulary is 225 and it represents both the composition and performance elements of a piece (timing and\ndynamics).\n4. SENTIMENT DATASET\nIn order to apply the Radford et al. [13] method to compose music with sentiment, we also need a dataset of MIDI\nfiles to train the LSTM and another one to train the logistic regression. There are many good datasets of music\nin MIDI format in the literature. However, to the best of\nour knowledge, none are labelled according to sentiment.\nThus, we created a new dataset called VGMIDI which is\ncomposed of 823 pieces extracted from video game soundtracks in MIDI format. We choose video game soundtracks\nbecause they are normally composed to keep the player\nin a certain affective state and thus they are less subjective pieces. All the pieces are piano arrangements of the\nsoundtracks and they vary in length from 26 seconds to\n3 minutes. Among these pieces, 95 are annotated according to a 2-dimensional model that represents emotion using\na valence-arousal pair. Valence indicates positive versus\nnegative emotion, and arousal indicates emotional intensity [17].\nWe use this valence-arousal model because it allows continuous annotation of music and because of its\nflexibility\u2014one can directly map a valence-arousal (v-a)\npair to a multiclass (happy, sad, surprise, etc) or a binary\n(positive/negative) model. Thus, the same set of labelled\ndata permits the investigation of affective algorithmic music composition as both a classification (multiclass and/or\nbinary) and as a regression problem. The valence-arousal\nmodel is also one of the most common dimensional models\nused to label emotion in music [17].\nAnnotating a piece according to the v-a model consists\nof continuously listening to the piece and deciding what\nvalence-arousal pair best represents the emotion of that\npiece in each moment, producing a time-series of v-a pairs.\nThis task is subjective, hence there is no single \u201ccorrect\u201d\ntime-series for a given piece. Thus, we decided to label\nthe pieces by asking several human subjects to listen to the\npieces and then considering the average time-series as the\nground truth. This process was conducted online via Amazon Mechanical Turk, where each piece was annotated by\n30 subjects using a web-based tool we designed specifically for this task. Each subject annotated 2 pieces out of\n95, and got rewarded USD $0.50 for performing this task.\n4.1 Annotation Tool and Data Collection\nThe tool we designed to annotate the video game soundtracks in MIDI format is composed of five steps, each one\nbeing a single web-page. These steps are based on the\nmethodology proposed by Soleymani et al. [17] for annotating music pieces in audio waveform. First, participants\nare introduced to the annotation task with a short description explaining the goal of the task and how long it should\ntake in average. Second, they are presented to the definitions of valence and arousal.\nIn the same page, they\nare asked to play two short pieces and indicate whether\narousal and valence are increasing or decreasing. Moreover, we ask the annotators to write two to three sentences\ndescribing the short pieces they listened to. This page is\nintended to measure their understanding of the valencearousal model and willingness to perform the task. Third,\na video tutorial was made available to the annotators explaining how to use the annotation tool. Fourth, annotators\nare exposed to the main annotation page.\nThis main page has two phases: calibration and annotation. In the calibration phase, annotators listen to the first\n15 seconds of the piece in order to get used to it and to define the starting point of the annotation circle. In the anno-\n\fFigure 2: Screenshot of the annotation tool.\ntation phase they listen to the piece from beginning to end\nand label it using the annotation circle, which starts at the\npoint defined during the calibration phase. Figure 2 shows\nthe annotation interface for valence and arousal, where annotators click and hold the circle (with the play icon) inside\nthe v-a model (outer circle) indicating the current emotion\nof the piece. In order to maximize annotators\u2019 engagement\nin the task, the piece is only played while they maintain a\nclick on the play circle. In addition, basic instructions on\nhow to use the tool are showed to the participants along\nwith the definitions of valence and arousal. A progression\nbar is also showed to the annotators so they know how far\nthey are from completing each phase. This last step (calibration and annotation) is repeated for a second piece. All\nof the pieces the annotators listened to are MIDI files synthesized with the \u201cYamaha C5 Grand\" soundfont. Finally,\nafter the main annotation step, participants provide demographic information including gender, age, location (country), musicianship experience and whether they previously\nknew the pieces they annotated.\n4.2 Data Analysis\nThe annotation task was performed by 1425 annotators,\nwhere 55% are female and 42% are male. The other 3%\nclassified themselves as transgender female, transgender\nmale, genderqueer or choose not to disclose their gender.\nAll annotators are from the United States and have an average age of approximately 31 years. Musicianship experience was assessed using a 5-point Likert scale where 1\nmeans \u201cI\u2019ve never studied music theory or practice\u201d and\n5 means \u201cI have an undergraduate degree in music\u201d. The\naverage musicianship experience is 2.28. They spent on\naverage 12 minutes and 6 seconds to annotate the 2 pieces.\nThe data collection process provides a time series of\nvalence-arousal values for each piece, however to create a\nmusic sentiment dataset we only need the valence dimension, which encodes negative and positive sentiment. Thus,\nwe consider that each piece has 30 time-series of valence\nvalues. The annotation of each piece was preprocessed,\nsummarized into one time-series and split into \u201cphrases\u201d of\nsame sentiment. The preprocessing is intended to remove\nnoise caused by subjects performing the task randomly to\nget the reward as fast as possible. The data was preprocessed by smoothing each annotation with moving average\nFigure 3: Data analysis process used to define the final\nlabel of the phrases of a piece.\nand clustering all 30 time-series into 3 clusters (positive,\nnegative and noise) according to the dynamic time-warping\ndistance metric.\nWe consider the cluster with the highest variance to be\nnoise cluster and so we discard it. The cluster with more\ntime series among the two remaining ones is then selected\nand summarized by the mean of its time series. We split\nthis mean into several segments with the same sentiment.\nThis is performed by splitting the mean at all the points\nwhere the valence changes from positive to negative or\nvice-versa. Thus, all chunks with negative valence are considered phrases with negative sentiment and the ones with\npositive valence are positive phrases. Figure 3 shows an\nexample of this three-steps process performed on a piece.\nAll the phrases that had no notes (i.e. silence phrases) were\nremoved. This process created a total of 966 phrases: 599\npositive and 367 negative.\n5. SENTIMENT ANALYSIS EVALUATION\nTo evaluate the sentiment classification accuracy of our\nmethod (generative mLSTM + logistic regression), we\ncompare it to a baseline method which is a traditional\nclassification mLSTM trained in a supervised way. Our\nmethod uses unlabelled MIDI pieces to train a generative\nmLSTM to predict the next word in a sequence. An additional logistic regression uses the hidden states of the\ngenerative mLSTM to encode the labelled MIDI phrases\nand then predict sentiment. The baseline method uses only\nlabelled MIDI phrases to train a classification mLSTM to\npredict the sentiment for the phrase.\nThe unlabelled pieces used to train the generative mLSTM were transformed in order to create additional training examples, following the methodology of Oore et al.\n[11]. The transformations consist of time-stretching (making each piece up to 5% faster or slower) and transposition\n(raising or lowering the pitch of each piece by up to a major third). We then encoded all these pieces and transformations according to our word-based representation (see\nSection 3.1). Finally, the encoded pieces were shuffled and\n\f90% of them were used for training and 10% for testing.\nThe training set was divided into 3 shards of similar size\n(approximately 18500 pieces each \u2013 325MB) and the testing set was combined into 1 shard (approximately 5800\npieces \u2013 95MB).\nWe trained the generative mLSTM with 6 different sizes\n(number of neurons in the mLSTM layer): 128, 256, 512,\n1024, 2048 and 4096. For each size, the generative mLSTM was trained for 4 epochs using the 3 training shards.\nWeights were updated with the Adam optimizer after processing sequences of 256 words on mini-batches of size\n32. The mLSTM hidden and cell states were initialized\nto zero at the beginning of each shard. They were also\npersisted across updates to simulate full-backpropagation\nand allow for the forward propagation of information outside of a given sequence [13]. Each sequence is processed\nby an embedding layer (which is trained together with the\nmLSTM layer) with 64 neurons before passing through the\nmLSTM layer. The learning rate was set to 5 \u2217 10\u22126 at the\nbeginning and decayed linearly (after each epoch) to zero\nover the course of training.\nWe evaluated each variation of the generative mLSTM\nwith a forward pass on test shard using mini-batches of size\n32. Table 1 shows the average 3 cross entropy loss for each\nvariation of the generative mLSTM.\nmLSTM Neurons\nAverage Cross Entropy Loss\n128\n1.80\n256\n1.61\n512\n1.41\n1024\n1.25\n2048\n1.15\n4096\n1.11\nTable 1: Average cross entropy loss of the generative mLSTM with different amount of neurons.\nThe average cross entropy loss decreases as the size of\nthe mLSTM increases, reaching the best result (loss 1.11)\nwhen size is equal to 4096. Thus, we used the variation\nwith 4096 neurons to proceed with the sentiment classification experiments.\nFollowing the methodology of Radford et al. [13], we\nre-encoded each of the 966 labelled phrases using the final\ncell states (a 4096 dimension vector) of the trained generative mLSTM-4096. The states are calculated by initializing\nthem to zero and processing the phrase word-by-word. We\nplug a logistic regression into the mLSTM-4096 to turn it\ninto a sentiment classifier. This logistic regression model\nwas trained with regularization \u201cL1\u201d to shrink the least important of the 4096 feature weights to zero. This ends up\nhighlighting the generative mLSTM neurons that contain\nmost of the sentiment signal.\nWe compared this generative mLSTM + logistic regression approach against our baseline, the supervised mLSTM. This is an mLSTM with exactly the same architecture and size of the generative version, but trained in a\n3 Each mini-batch reports one loss.\nfully supervised way. To train this supervised mLSTM,\nwe used the word-based representation of the phrases, but\nwe padded each phrase with silence (the symbol \u201c.\u201d) in\norder to equalize their length. Training parameters (learning rate and decay, epochs, batch size, etc) were the same\nones of the the generative mLSTM. It is important to notice\nthat in this case the mini-batches are formed of 32 labelled\nphrases and not words. We evaluate both methods using a\n10-fold cross validation approach, where the test folds have\nno phrases that appear in the training folds. Table 2 shows\nthe sentiment classification accuracy of both approaches.\nMethod\nTest Accuracy\nGen. mLSTM-4096 + Log. Reg.\n89.83 \u00b1 3.14\nSup. mLSTM-4096\n60.35 \u00b1 3.52\nTable 2: Average (10-fold cross validation) sentiment classification accuracy of both generative (with logistic regression) and supervised mLSTMs.\nThe\ngenerative\nmLSTM\nwith\nlogistic\nregression\nachieved an accuracy of 89.83%, outperforming the supervised mLSTM by 29.48%. The supervised mLSTM accuracy of 60.35% suggests that the amount of labelled data\n(966 phrases) was not enough to learn a good mapping between phrases and sentiment. The accuracy of our method\nshows that the generative mLSTM is capable of learning,\nin an unsupervised way, a good representation of sentiment\nin symbolic music.\nThis is an important result, for two reasons. First, since\nthe higher accuracy of generative mLSTM is derived from\nusing unlabeled data, it will be easier to improve this over\ntime using additional (less expensive) unlabeled data, instead of the supervised mLSTM approach which requires\nadditional (expensive) labeled data. Second, because the\ngenerative mLSTM was trained to predict the next word\nin a sequence, it can be used as a music generator. Since\nit is combined with a sentiment predictor, it opens up the\npossibility of generating music consistent with a desired\nsentiment. We explore this idea in the following section.\n6. GENERATIVE EVALUATION\nTo control the sentiment of the music generated by our mLSTM, we find the subset of neurons that contain the sentiment signal by exploring the weights of the trained logistic\nregression model. Since each of the 10 generative models\nderived from the 10 fold splits in Table 2 are themselves\na full model, we use the model with the highest accuracy.\nAs shown in Figure 4, the logistic regression trained with\nregularization \u201cL1\u201d uses 161 neurons out of 4096. Unlike\nthe results of Radford et al. [13], we don\u2019t have one single\nneuron that stores most of the sentiment signal. Instead, we\nhave many neurons contributing in a more balanced way.\nTherefore, we can\u2019t simply change the values of one neuron to control the sentiment of the output music.\nWe used a Genetic Algorithm (GA) to optimize the\nweights of the 161 L1 neurons in order to lead our mL-\n\fFigure 4: Weights of 161 L1 neurons.\nNote multiple\nprominent positive and negative neurons.\nSTM to generate only positive or negative pieces. Each\nindividual in the population of this GA has 161 real-valued\ngenes representing a small noise to be added to the weights\nof the 161 L1 neurons.\nThe fitness of an individual is\ncomputed by (i) adding the genes of the individual to the\nweights (vector addition) of the 161 L1 neurons of the generative mLSTM, (ii) generating P pieces with this mLSTM, (iii) using the logistic regression model to predict\nthese P generated pieces and (iv) calculating the mean\nsquared error of the P predictions given a desired sentiment s \u2208 S = {0, 1}.\nThe GA starts with a random population of size 100\nwhere each gene of each individual is an uniformly sampled random number \u22122 \u2264 r \u2264 2. For each generation,\nthe GA (i) evaluates the current population, (ii) selects 100\nparents via a roulette wheel with elitism, (iii) recombines\nthe parents (crossover) taking the average of their genes\nand (iv) mutates each new recombined individual (new\noffspring) by randomly setting each gene to an uniformly\nsampled random number \u22122 \u2264 r \u2264 2.\nWe performed two independent executions of this GA,\none to optimize the mLSTM for generating positive pieces\nand another one for negative pieces. Each execution optimized the individuals during 100 epochs with crossover\nrate of 95% and mutation rate of 10%. To calculate the\nfitness of each individual, we generated P=30 pieces with\n256 words each, starting with the symbol \u201c.\u201d (end of time\nstep). The optimization for positive and negative generation resulted in best individuals with fitness 0.16 and 0.33,\nrespectively. This means that if we add the genes of the\nbest individual of the final population to the weights of the\ngenerative mLSTM, we generate positive pieces with 84%\naccuracy and negative pieces with 67% accuracy.\nAfter these two optimization processes, the genes of\nthe best final individual of the positive optimization were\nadded to the weights of the 161 L1 neurons of the trained\ngenerative mLSTM. We then generated 30 pieces with\n1000 words starting with the symbol \u201c.\u201d (end of time step)\nand randomly selected 3 of them. The same process was\nrepeated using the genes of the best final individual of the\nnegative execution. We asked annotators to label this 6\ngenerated pieces via Amazon MTurk, using the the same\nmethodology described in Section 4.1.\nFigure 5 shows\nthe average valence per measure of each of the generated\npieces.\nFigure 5: Average valence of the 6 generated pieces, as\ndetermined by human annotators. with least variance.\nWe observe that the human annotators agreed that the\nthree positive generated pieces are indeed positive. The\ngenerated negative pieces are more ambiguous, having\nboth negative and positive measures. However, as a whole\nthe negative pieces have lower valence than the positive\nones. This suggests that the best negative individual (with\nfitness 0.33) encountered by the GA wasn\u2019t good enough to\ncontrol the mLSTM to generate complete negative pieces.\nMoreover, the challenge to optimize the L1 neurons suggests that there are more positive pieces than negative ones\nin the 3 shards used to train the generative mLSTM.\n7. CONCLUSION AND FUTURE WORK\nThis paper presented a generative mLSTM that can be controlled to generate symbolic music with a given sentiment.\nThe mLSTM is controlled by optimizing the weights of\nspecific neurons that are responsible for the sentiment signal. Such neurons are found plugging a Logistic Regression to the mLSTM and training the Logistic Regression\nto classify sentiment of symbolic music encoded with the\nmLSTM hidden states. We evaluated this model both as a\ngenerator and as a sentiment classifier. Results showed that\nour model obtained good classification accuracy, outperforming a equivalent LSTM trained in a fully supervised\nway. Moreover, a user study showed that humans agree\nthat our model can generate positive and negative music,\nwith the caveat that the negative pieces are more ambiguous.\nIn the future, we plan to improve our model to generate\nless ambiguous negative pieces. Another future work consists of expanding the model to generate music with a given\nemotion (e.g. happy, sad, suspenseful, etc.) as well as with\na given valence-arousal pair (real numbers). We also plan\nto use this model to compose soundtracks in real-time for\noral storytelling experiences [12].\n\f8. ACKNOWLEDGMENTS\nWe would like to thank Dr. Levi Lelis for the great feedback and Dr. Leonardo N. Ferreira for the support on the\ntime series analysis. This research was supported by CNPq\n(200367/2015-3).\n9. REFERENCES\n[1] International e-piano competition. http://www.\npiano-e-competition.com. Accessed: 201904-12.\n[2] Jean-Pierre Briot, Ga\u00ebtan Hadjeres, and Fran\u00e7ois Pachet. Deep learning techniques for music generation-a\nsurvey. arXiv preprint arXiv:1709.01620, 2017.\n[3] Sixian Chen, John Bowers, and Abigail Durrant. \u2019ambient walk\u2019: A mobile application for mindful walking\nwith sonification of biophysical data. In Proceedings\nof the 2015 British HCI Conference, British HCI \u201915,\npages 315\u2013315, New York, NY, USA, 2015. ACM.\n[4] Hannah Davis and Saif M Mohammad. Generating\nmusic from literature. Proceedings of the 3rd Workshop\non Computational Linguistics for Literature (CLfL),\npages 1\u201310, 2014.\n[5] Ga\u00ebtan Hadjeres, Fran\u00e7ois Pachet, and Frank Nielsen.\nDeepbach: a steerable model for bach chorales generation. In Proceedings of the 34th International Conference on Machine Learning-Volume 70, pages 1362\u2013\n1371. JMLR. org, 2017.\n[6] Ruining He and Julian McAuley. Ups and downs:\nModeling the visual evolution of fashion trends with\none-class collaborative filtering. In Proceedings of the\n25th International Conference on World Wide Web,\nWWW \u201916, pages 507\u2013517, Republic and Canton of\nGeneva, Switzerland, 2016. International World Wide\nWeb Conferences Steering Committee.\n[7] Youngmoo E Kim,\nErik M Schmidt,\nRaymond\nMigneco, Brandon G Morton, Patrick Richardson, Jeffrey Scott, Jacquelin A Speck, and Douglas Turnbull.\nMusic emotion recognition: A state of the art review.\nIn Proc. ISMIR, volume 86, pages 937\u2013952. Citeseer,\n2010.\n[8] Ben Krause, Iain Murray, Steve Renals, and Liang Lu.\nMultiplicative LSTM for sequence modelling. ICLR\nWorkshop track, 2017.\n[9] Eduardo R Miranda, Wendy L Magee, John J Wilson, Joel Eaton, and Ramaswamy Palaniappan. Braincomputer music interfacing (bcmi):\nfrom basic research to the real world of special needs. Music &\nMedicine, 3(3):134\u2013140, 2011.\n[10] Kristine Monteith, Tony R Martinez, and Dan Ventura. Automatic generation of music for inducing emotive response. In International Conference on Computational Creativity, pages 140\u2013149, 2010.\n[11] Sageev Oore, Ian Simon, Sander Dieleman, and Doug\nEck. Learning to create piano performances. In NIPS\n2017 Workshop on Machine Learning for Creativity\nand Design, 2017.\n[12] Rafael R Padovani, Lucas N Ferreira, and Levi HS\nLelis. Bardo: Emotion-based music recommendation\nfor tabletop role-playing games. In Thirteenth Artificial Intelligence and Interactive Digital Entertainment\nConference, 2017.\n[13] Alec Radford, Rafal Jozefowicz, and Ilya Sutskever.\nLearning to generate reviews and discovering sentiment. arXiv preprint arXiv:1704.01444, 2017.\n[14] Adam Roberts, Jesse Engel, and Douglas Eck, editors. Hierarchical Variational Autoencoders for Music,\n2017.\n[15] James A Russell. A circumplex model of affect. Journal of personality and social psychology, 39(6):1161,\n1980.\n[16] Marco Scirea, Julian Togelius, Peter Eklund, and Sebastian Risi. Affective evolutionary music composition\nwith metacompose. Genetic Programming and Evolvable Machines, 18(4):433\u2013465, 2017.\n[17] Mohammad Soleymani, Micheal N. Caro, Erik M.\nSchmidt, Cheng-Ya Sha, and Yi-Hsuan Yang. 1000\nsongs for emotional analysis of music. In Proceedings\nof the 2Nd ACM International Workshop on Crowdsourcing for Multimedia, CrowdMM \u201913, pages 1\u20136,\nNew York, NY, USA, 2013. ACM.\n[18] Duncan Williams, Alexis Kirke, Joel Eaton, Eduardo\nMiranda, Ian Daly, James Hallowell, Etienne Roesch,\nFaustina Hwang, and Slawomir J Nasuto. Dynamic\ngame soundtrack generation in response to a continuously varying emotional trajectory. In Audio Engineering Society Conference: 56th International Conference: Audio for Games. Audio Engineering Society,\n2015.\n[19] Duncan Williams, Alexis Kirke, Eduardo R Miranda,\nEtienne Roesch, Ian Daly, and Slawomir Nasuto. Investigating affect in algorithmic composition systems.\nPsychology of Music, 43(6):831\u2013854, 2015.\n\f", "text_mmd": "# Learning to Generate Music With Sentiment\n\n###### Abstract\n\nDeep Learning models have shown very promising results in automatically composing polyphonic music pieces. However, it is very hard to control such models in order to guide the compositions towards a desired goal. We are interested in controlling a model to automatically generate music with a given sentiment. This paper presents a generative Deep Learning model that can be directed to compose music with a given sentiment. Besides music generation, the same model can be used for sentiment analysis of symbolic music. We evaluate the accuracy of the model in classifying sentiment of symbolic music using a new dataset of video game soundtracks. Results show that our model is able to obtain good prediction accuracy. A user study shows that human subjects agreed that the generated music has the intended sentiment, however negative pieces can be ambiguous.\n\nLucas N. Ferreira University of California, Santa Cruz\n\nDepartment of Computational Media\n\n## 1 Introduction\n\nMusic Generation is an important application domain of Deep Learning in which models learn musical features from a dataset in order to generate new, interesting music. Such models have been capable of generating high quality pieces of different styles with strong short-term dependencies 1[2]. A major challenge of this domain consists of disentangling these models to generate compositions with given characteristics. For example, one can't easily control a model trained on classical piano pieces to compose a tense piece for a horror scene of a movie. Being able to control the output of the models is specially important for the field of Affective Music Composition, whose major goal is to automatically generate music that is perceived to have a specific emotion or to evoke emotions in listeners [19]. Applications involve generating soundtracks for movies and video-games [18], sonification of biophysical data [3] and generating responsive music for the purposes of music therapy and palliative care [9].\n\nFootnote 1: Supporting strong long-term dependencies (music form) is still an open problem.\n\nRecently, Radford et al. [13] showed that a generative Long short-term memory (LSTM) neural network can learn an excellent representation of sentiment (positive-negative) on text, despite being trained only to predict the next character in the Amazon reviews dataset [6]. When combined to a Logistic Regression, this LSTM achieves state-of-the-art sentiment analysis accuracy on the Stanford Sentiment Treebank dataset and can match the performance of previous supervised systems using 30-100x fewer labeled examples. This LSTM stores almost all of the sentiment signal in a distinct \"sentiment neuron\", which can be used to control the LSTM to generate sentences with a given sentiment. In this paper, we explore this approach with the goal of composing symbolic music with a given sentiment. We also explore this approach as a sentiment classifier for symbolic music.\n\nIn order to evaluate this approach, we need a dataset of music in symbolic format that is annotated by sentiment. Even though emotion detection is an important topic in music information retrieval [7], it is typically studied on music in audio format. To the best of our knowledge, there are no datasets of symbolic music annotated according to sentiment. Therefore, we created a new dataset composed of 95 MIDI labelled piano pieces (966 phrases of 4 bars) from video game soundtracks. Each piece is annotated by 30 human subjects according to a valence-arousal (dimensional) model of emotion [15]. The sentiment of each piece is then extracted by summarizing the 30 annotations and mapping the valence axis to sentiment. The same dataset also contains another 728 non-labelled pieces, which were used for training the generative LSTM.\n\nWe combine this generative LSTM with a Logistic Regression and analyse its sentiment prediction accuracy against a traditional classification LSTM trained in a fully-supervised way. Results showed that our model (generative LSTM with Logistic Regression) outperformed the supervised LSTM by approximately 30%. We also analysed the generative capabilities of our model with a user study. Human subjects used an online annotation tool to label 3 pieces controlled to be negative and 3 pieces controlled to be positive. Results showed human annotators agree the generated positive pieces have the intended sentiment. The generated negative pieces appear to be ambiguous, having both negative and positive parts.\n\nWe believe this paper is the first work to explore sentiment analysis in symbolic music and it presents the first disentangled Deep Learning model for music generation with sentiment. Another contribution of this paper is a labelled dataset of symbolic music annotated according to sentiment. These contributions open several direction forfuture research, specially music generation with emotions as both a multi-class problem and as a regression problem. Moreover, these methods could be applied to create soundtrack generation systems for films, video games, interactive narratives, audio books, etc.\n\n## 2 Related Work\n\nThis paper is related to previous work on Affective Algorithmic Music Composition, more specifically to works that process music in symbolic form in order to generate music with a given emotion. A common approach for this problem consists of designing a rule-based system to map musical features to a given emotion in a categorical or dimensional space [19]. For example, Williams et al. [18] propose a system to generate soundtracks for video games where each game's scene graph (defining all the possible branching of scenes in the game) is annotated according to a valence-arousal model. A second-order Markov model is used to learn melodies from a dataset and are then transformed by a rule-based system to fit the annotated emotions in the graph. Davis and Mohammad [4] follow a similar approach in TransPose, a system that composes piano melodies for novels. TransPose uses a lexicon-based approach to automatically detect emotions (categorical model) in novels and a rule-based technique to create piano melodies with these emotions.\n\nThere are a few other approaches in the literature to compose music with a given emotion. Scirea et al. [16] recently presented a framework called MetaCompose designed to create background music for games in real-time. MetaCompose generates music by (i) randomly creating a chord sequence from a pre-defined chord progression graph, (ii) evolving a melody for this chord sequence using a genetic algorithm and (iii) producing an accompaniment for the melody/chord sequence combination. Monteith et al. [10] approaches Affective Algorithmic Music Composition from a Machine Learning perspective to learn melodies and rhythms from a corpus of music labeled according to a categorical model of emotion. Individual Hidden Markov models and n-grams are trained for each category to generate pitches and underlying harmonies, respectively. Rhythms are sampled randomly from examples of a given category.\n\nDeep Learning models have recently achieved high-quality results in music composition with short-term dependencies [2]. These models normally are trained on a corpus of MIDI files to predict the next note to be played based on a given note. In general, these models can't be manipulated to generate music with a given emotion. For example, in the system DeepBach, Hadjeres et al. [5] use a dependency network and a Gibbs-like sampling procedure to generate high-quality four-part chorales in the style of Bach. Roberts et at. [14] train recurrent variational autoencoder (VAEs) to reproduce short musical sequences and with a novel hierarchical decoder they are able to model long sequences with musical structure for both individual instruments and a three-piece band (lead, bass, and drums).\n\nThe majority of the deep learning models are trained to generate musical scores and not performances. Oore et al. [11] tackles this problem by training an LSTM with a new representation that supports tempo and velocity events from MIDI files. This model was trained on the Yamaha e-Piano Competition [1], which contains MIDI captures of ~1400 performances by skilled pianists. With this new representation and dataset, Oore et al. [11] generated more human-like performances when compared to previous models.\n\n## 3 Model\n\nWe propose a Deep Learning method for affective algorithmic composition that can be controlled to generate music with a given sentiment. This method is based on the work of Radford et al. [13] which generates product reviews (in textual form) with sentiment. Radford et al. [13] used a single-layer multiplicative long short-term memory (mLSTM) network [8] with 4096 units to process text as a sequence of UTF-8 encoded bytes (character-based language modeling). For each byte, the model updates its hidden state of the mLSTM and predicts a probability distribution over the next possible byte.\n\nThis mLSTM was trained on the Amazon product review dataset, which contains over 82 million product reviews from May 1996 to July 2014 amounting to over 38 billion training bytes [6]. Radford et al. [13] used the trained mLSTM to encode sentences from four different Sentiment Analysis datasets. The encoding is performed by initializing the the states to zeros and processing the sequence character-by-character. The final hidden states of the mLSTM are used as a feature representation. With the encoded datasets, Radford et al. [13] trained a simple logistic regression classifier with L1 regularization and outperformed the state-of-the-art methods at the time using 30-100x fewer labeled examples.\n\nBy inspecting the relative contributions of features on various datasets, Radford et al. [13] discovered a single unit within the mLSTM that directly corresponded to sentiment. Because the mLSTM was trained as a generative model, one can simply set the value of the sentiment unit to be positive or negative and the model generates corresponding positive or negative reviews.\n\n### Data Representation\n\nWe use the same combination of mLSTM and logistic regression to compose music with sentiment. To do this, we treat the music composition problem as a language modeling problem. Instead of characters, we represent a music piece as a sequence of words and punctuation marks from a vocabulary that represents events retrieved from the MIDI file. Sentiment is perceived in music due to several features such as melody, harmony, tempo, timbre, etc [7]. Our data representation attempts to encode a large part of these features 1 using a small set of words:\n\nFootnote 1: Constrained by the features one can extract from MIDI data.\n\n* \"n_[pitch]\": play note with given pitch number: any integer from 0 to 127.\n\n* \"d_[duration]_[dots]\": change the duration of the following notes to a given duration type with a given amount of dots. Types are breve, whole, half, quarter, eighth, 16th and 32nd. Dots can be any integer from 0 to 3.\n* \"v_[velocity]\": change the velocity of the following notes to a given velocity (loudness) number. Velocity is discretized in bins of size 4, so it can be any integer in the set \\(V=4,8,12,\\ldots,128\\).\n* \"t_[tempo]\": change the tempo of the piece to a given tempo in bpm. Tempo is also discretized in bins of size 4, so it can be any integer in the set \\(T=24,28,32,\\ldots,160\\).\n* \"\": end of time step. Each time step is one sixteenth note long.\n* \"u\": end of piece.\n\nFor example, Figure 1 shows the encoding of the first two time steps of the first measure of the Legend of Zelda - Ocarina of Time's Prelude of Light. The first time step sets the tempo to 120bpm, the velocity of the following notes to 76 and plays the D Major Triad for the duration of a whole note. The second time step sets the velocity to 84 and plays a dotted quarter A5 note. The total size of this vocabulary is 225 and it represents both the composition and performance elements of a piece (timing and dynamics).\n\n## 4 Sentiment Dataset\n\nIn order to apply the Radford et al. [13] method to compose music with sentiment, we also need a dataset of MIDI files to train the LSTM and another one to train the logistic regression. There are many good datasets of music in MIDI format in the literature. However, to the best of our knowledge, none are labelled according to sentiment. Thus, we created a new dataset called VGMIDI which is composed of 823 pieces extracted from video game soundtracks in MIDI format. We choose video game soundtracks because they are normally composed to keep the player in a certain affective state and thus they are less subjective pieces. All the pieces are piano arrangements of the soundtracks and they vary in length from 26 seconds to 3 minutes. Among these pieces, 95 are annotated according to a 2-dimensional model that represents emotion using a valence-arousal pair. Valence indicates positive versus negative emotion, and arousal indicates emotional intensity [17].\n\nWe use this valence-arousal model because it allows continuous annotation of music and because of its flexibility--one can directly map a valence-arousal (v-a) pair to a multiclass (happy, sad, surprise, etc) or a binary (positive/negative) model. Thus, the same set of labelled data permits the investigation of affective algorithmic music composition as both a classification (multiclass and/or binary) and as a regression problem. The valence-arousal model is also one of the most common dimensional models used to label emotion in music [17].\n\nAnnotating a piece according to the v-a model consists of continuously listening to the piece and deciding what valence-arousal pair best represents the emotion of that piece in each moment, producing a time-series of v-a pairs. This task is subjective, hence there is no single \"correct\" time-series for a given piece. Thus, we decided to label the pieces by asking several human subjects to listen to the pieces and then considering the average time-series as the ground truth. This process was conducted online via Amazon Mechanical Turk, where each piece was annotated by 30 subjects using a web-based tool we designed specifically for this task. Each subject annotated 2 pieces out of 95, and got rewarded USD $0.50 for performing this task.\n\n### Annotation Tool and Data Collection\n\nThe tool we designed to annotate the video game soundtracks in MIDI format is composed of five steps, each one being a single web-page. These steps are based on the methodology proposed by Soleymani et al. [17] for annotating music pieces in audio waveform. First, participants are introduced to the annotation task with a short description explaining the goal of the task and how long it should take in average. Second, they are presented to the definitions of valence and arousal. In the same page, they are asked to play two short pieces and indicate whether arousal and valence are increasing or decreasing. Moreover, we ask the annotators to write two to three sentences describing the short pieces they listened to. This page is intended to measure their understanding of the valence-arousal model and willingness to perform the task. Third, a video tutorial was made available to the annotators explaining how to use the annotation tool. Fourth, annotators are exposed to the main annotation page.\n\nThis main page has two phases: calibration and annotation. In the calibration phase, annotators listen to the first 15 seconds of the piece in order to get used to it and to define the starting point of the annotation circle. In the anno\n\nFigure 1: A short example piece encoded using our proposed representation. The encoding represents the first two time steps of the shown measure.\n\ntation phase they listen to the piece from beginning to end and label it using the annotation circle, which starts at the point defined during the calibration phase. Figure 2 shows the annotation interface for valence and arousal, where annotators click and hold the circle (with the play icon) inside the v-a model (outer circle) indicating the current emotion of the piece. In order to maximize annotators' engagement in the task, the piece is only played while they maintain a click on the play circle. In addition, basic instructions on how to use the tool are showed to the participants along with the definitions of valence and arousal. A progression bar is also showed to the annotators so they know how far they are from completing each phase. This last step (calibration and annotation) is repeated for a second piece. All of the pieces the annotators listened to are MIDI files synthesized with the \"Yamaha C5 Grand\" soundfont. Finally, after the main annotation step, participants provide demographic information including gender, age, location (country), musicianship experience and whether they previously knew the pieces they annotated.\n\n### Data Analysis\n\nThe annotation task was performed by 1425 annotators, where 55% are female and 42% are male. The other 3% classified themselves as transgender female, transgender male, genderqueer or choose not to disclose their gender. All annotators are from the United States and have an average age of approximately 31 years. Musicianship experience was assessed using a 5-point Likert scale where 1 means \"I've never studied music theory or practice\" and 5 means \"I have an undergraduate degree in music\". The average musicianship experience is 2.28. They spent on average 12 minutes and 6 seconds to annotate the 2 pieces.\n\nThe data collection process provides a time series of valence-arousal values for each piece, however to create a music sentiment dataset we only need the valence dimension, which encodes negative and positive sentiment. Thus, we consider that each piece has 30 time-series of valence values. The annotation of each piece was preprocessed, summarized into one time-series and split into \"phrases\" of same sentiment. The preprocessing is intended to remove noise caused by subjects performing the task randomly to get the reward as fast as possible. The data was preprocessed by smoothing each annotation with moving average and clustering all 30 time-series into 3 clusters (positive, negative and noise) according to the dynamic time-warping distance metric.\n\nWe consider the cluster with the highest variance to be noise cluster and so we discard it. The cluster with more time series among the two remaining ones is then selected and summarized by the mean of its time series. We split this mean into several segments with the same sentiment. This is performed by splitting the mean at all the points where the valence changes from positive to negative or vice-versa. Thus, all chunks with negative valence are considered phrases with negative sentiment and the ones with positive valence are positive phrases. Figure 3 shows an example of this three-steps process performed on a piece. All the phrases that had no notes (i.e. silence phrases) were removed. This process created a total of 966 phrases: 599 positive and 367 negative.\n\n## 5 Sentiment Analysis Evaluation\n\nTo evaluate the sentiment classification accuracy of our method (generative mLSTM + logistic regression), we compare it to a baseline method which is a traditional classification mLSTM trained in a supervised way. Our method uses unlabelled MIDI pieces to train a generative mLSTM to predict the next word in a sequence. An additional logistic regression uses the hidden states of the generative mLSTM to encode the labelled MIDI phrases and then predict sentiment. The baseline method uses only labelled MIDI phrases to train a classification mLSTM to predict the sentiment for the phrase.\n\nThe unlabelled pieces used to train the generative mLSTM were transformed in order to create additional training examples, following the methodology of Oore et al. [11]. The transformations consist of time-stretching (making each piece up to 5% faster or slower) and transposition (raising or lowering the pitch of each piece by up to a major third). We then encoded all these pieces and transformations according to our word-based representation (see Section 3.1). Finally, the encoded pieces were shuffled and\n\nFigure 3: Data analysis process used to define the final label of the phrases of a piece.\n\nFigure 2: Screenshot of the annotation tool.\n\n90% of them were used for training and 10% for testing. The training set was divided into 3 shards of similar size (approximately 18500 pieces each - 325MB) and the testing set was combined into 1 shard (approximately 5800 pieces - 95MB).\n\nWe trained the generative mLSTM with 6 different sizes (number of neurons in the mLSTM layer): 128, 256, 512, 1024, 2048 and 4096. For each size, the generative mLSTM was trained for 4 epochs using the 3 training shards. Weights were updated with the Adam optimizer after processing sequences of 256 words on mini-batches of size 32. The mLSTM hidden and cell states were initialized to zero at the beginning of each shard. They were also persisted across updates to simulate full-backpropagation and allow for the forward propagation of information outside of a given sequence [13]. Each sequence is processed by an embedding layer (which is trained together with the mLSTM layer) with 64 neurons before passing through the mLSTM layer. The learning rate was set to \\(5*10^{-6}\\) at the beginning and decayed linearly (after each epoch) to zero over the course of training.\n\nWe evaluated each variation of the generative mLSTM with a forward pass on test shard using mini-batches of size 32. Table 1 shows the average 3 cross entropy loss for each variation of the generative mLSTM.\n\nFootnote 3: Each mini-batch reports one loss.\n\nThe average cross entropy loss decreases as the size of the mLSTM increases, reaching the best result (loss 1.11) when size is equal to 4096. Thus, we used the variation with 4096 neurons to proceed with the sentiment classification experiments.\n\nFollowing the methodology of Radford et al. [13], we re-encoded each of the 966 labelled phrases using the final cell states (a 4096 dimension vector) of the trained generative mLSTM-4096. The states are calculated by initializing them to zero and processing the phrase word-by-word. We plug a logistic regression into the mLSTM-4096 to turn it into a sentiment classifier. This logistic regression model was trained with regularization \"L1\" to shrink the least important of the 4096 feature weights to zero. This ends up highlighting the generative mLSTM neurons that contain most of the sentiment signal.\n\nWe compared this generative mLSTM + logistic regression approach against our baseline, the supervised mLSTM. This is an mLSTM with exactly the same architecture and size of the generative version, but trained in a fully supervised way. To train this supervised mLSTM, we used the word-based representation of the phrases, but we padded each phrase with silence (the symbol \".\") in order to equalize their length. Training parameters (learning rate and decay, epochs, batch size, etc) were the same ones of the the generative mLSTM. It is important to notice that in this case the mini-batches are formed of 32 labelled phrases and not words. We evaluate both methods using a 10-fold cross validation approach, where the test folds have no phrases that appear in the training folds. Table 2 shows the sentiment classification accuracy of both approaches.\n\nThe generative mLSTM with logistic regression achieved an accuracy of 89.83%, outperforming the supervised mLSTM by 29.48%. The supervised mLSTM accuracy of 60.35% suggests that the amount of labelled data (966 phrases) was not enough to learn a good mapping between phrases and sentiment. The accuracy of our method shows that the generative mLSTM is capable of learning, in an unsupervised way, a good representation of sentiment in symbolic music.\n\nThis is an important result, for two reasons. First, since the higher accuracy of generative mLSTM is derived from using unlabeled data, it will be easier to improve this over time using additional (less expensive) unlabeled data, instead of the supervised mLSTM approach which requires additional (expensive) labeled data. Second, because the generative mLSTM was trained to predict the next word in a sequence, it can be used as a music generator. Since it is combined with a sentiment predictor, it opens up the possibility of generating music consistent with a desired sentiment. We explore this idea in the following section.\n\n## 6 Generative Evaluation\n\nTo control the sentiment of the music generated by our mLSTM, we find the subset of neurons that contain the sentiment signal by exploring the weights of the trained logistic regression model. Since each of the 10 generative models derived from the 10 fold splits in Table 2 are themselves a full model, we use the model with the highest accuracy. As shown in Figure 4, the logistic regression trained with regularization \"L1\" uses 161 neurons out of 4096. Unlike the results of Radford et al. [13], we don't have one single neuron that stores most of the sentiment signal. Instead, we have many neurons contributing in a more balanced way. Therefore, we can't simply change the values of one neuron to control the sentiment of the output music.\n\nWe used a Genetic Algorithm (GA) to optimize the weights of the 161 L1 neurons in order to lead our mL\n\n\\begin{table}\n\\begin{tabular}{c c} \\hline \\hline\n**mLSTM Neurons** & **Average Cross Entropy Loss** \\\\ \\hline\n128 & 1.80 \\\\\n256 & 1.61 \\\\\n512 & 1.41 \\\\\n1024 & 1.25 \\\\\n2048 & 1.15 \\\\\n4096 & 1.11 \\\\ \\hline \\hline \\end{tabular}\n\\end{table}\nTable 1: Average cross entropy loss of the generative mLSTM with different amount of neurons.\n\n\\begin{table}\n\\begin{tabular}{l c} \\hline \\hline\n**Method** & **Test Accuracy** \\\\ \\hline Gen. mLSTM-4096 + Log. Reg. & 89.83 \\(\\pm\\) 3.14 \\\\ Sup. mLSTM-4096 & 60.35 \\(\\pm\\) 3.52 \\\\ \\hline \\hline \\end{tabular}\n\\end{table}\nTable 2: Average (10-fold cross validation) sentiment classification accuracy of both generative (with logistic regression) and supervised mLSTMs.\n\nSTM to generate only positive or negative pieces. Each individual in the population of this GA has \\(161\\) real-valued genes representing a small noise to be added to the weights of the \\(161\\) L1 neurons. The fitness of an individual is computed by (i) adding the genes of the individual to the weights (vector addition) of the \\(161\\) L1 neurons of the generative mLSTM, (ii) generating \\(P\\) pieces with this mLSTM, (iii) using the logistic regression model to predict these \\(P\\) generated pieces and (iv) calculating the mean squared error of the \\(P\\) predictions given a desired sentiment \\(s\\in S=\\{0,1\\}\\).\n\nThe GA starts with a random population of size 100 where each gene of each individual is an uniformly sampled random number \\(-2\\leq r\\leq 2\\). For each generation, the GA (i) evaluates the current population, (ii) selects 100 parents via a roulette wheel with elitism, (iii) recombines the parents (crossover) taking the average of their genes and (iv) mutates each new recombined individual (new offspring) by randomly setting each gene to an uniformly sampled random number \\(-2\\leq r\\leq 2\\).\n\nWe performed two independent executions of this GA, one to optimize the mLSTM for generating positive pieces and another one for negative pieces. Each execution optimized the individuals during 100 epochs with crossover rate of 95% and mutation rate of 10%. To calculate the fitness of each individual, we generated \\(P\\)=30 pieces with 256 words each, starting with the symbol \":\" (end of time step). The optimization for positive and negative generation resulted in best individuals with fitness \\(0.16\\) and \\(0.33\\), respectively. This means that if we add the genes of the best individual of the final population to the weights of the generative mLSTM, we generate positive pieces with 84% accuracy and negative pieces with 67% accuracy.\n\nAfter these two optimization processes, the genes of the best final individual of the positive optimization were added to the weights of the 161 L1 neurons of the trained generative mLSTM. We then generated 30 pieces with 1000 words starting with the symbol \":\" (end of time step) and randomly selected 3 of them. The same process was repeated using the genes of the best final individual of the negative execution. We asked annotators to label this 6 generated pieces via Amazon MTurk, using the the same methodology described in Section 4.1. Figure 5 shows the average valence per measure of each of the generated pieces.\n\nWe observe that the human annotators agreed that the three positive generated pieces are indeed positive. The generated negative pieces are more ambiguous, having both negative and positive measures. However, as a whole the negative pieces have lower valence than the positive ones. This suggests that the best negative individual (with fitness \\(0.33\\)) encountered by the GA wasn't good enough to control the mLSTM to generate complete negative pieces. Moreover, the challenge to optimize the L1 neurons suggests that there are more positive pieces than negative ones in the 3 shards used to train the generative mLSTM.\n\n## 7 Conclusion and Future Work\n\nThis paper presented a generative mLSTM that can be controlled to generate symbolic music with a given sentiment. The mLSTM is controlled by optimizing the weights of specific neurons that are responsible for the sentiment signal. Such neurons are found plugging a Logistic Regression to the mLSTM and training the Logistic Regression to classify sentiment of symbolic music encoded with the mLSTM hidden states. We evaluated this model both as a generator and as a sentiment classifier. Results showed that our model obtained good classification accuracy, outperforming a equivalent LSTM trained in a fully supervised way. Moreover, a user study showed that humans agree that our model can generate positive and negative music, with the caveat that the negative pieces are more ambiguous.\n\nIn the future, we plan to improve our model to generate less ambiguous negative pieces. Another future work consists of expanding the model to generate music with a given emotion (e.g. happy, sad, suspenseful, etc.) as well as with a given valence-arousal pair (real numbers). We also plan to use this model to compose soundtracks in real-time for oral storytelling experiences [12].\n\nFigure 4: Weights of 161 L1 neurons. Note multiple prominent positive and negative neurons.\n\nFigure 5: Average valence of the 6 generated pieces, as determined by human annotators. with least variance.\n\n## 8 Acknowledgments\n\nWe would like to thank Dr. Levi Lelis for the great feedback and Dr. Leonardo N. Ferreira for the support on the time series analysis. This research was supported by CNPq (200367/2015-3).\n\n## References\n\n* [1] International e-piano competition. [http://www.piano-e-competition.com](http://www.piano-e-competition.com). Accessed: 2019-04-12.\n* [2] Jean-Pierre Briot, Gaetan Hadjeres, and Francois Pachet. Deep learning techniques for music generation-a survey. _arXiv preprint arXiv:1709.01620_, 2017.\n* [3] Sixian Chen, John Bowers, and Abigail Durrant. 'ambient walk': A mobile application for mindful walking with sonification of biophysical data. In _Proceedings of the 2015 British HCI Conference_, British HCI '15, pages 315-315, New York, NY, USA, 2015. ACM.\n* [4] Hannah Davis and Saif M Mohammad. Generating music from literature. _Proceedings of the 3rd Workshop on Computational Linguistics for Literature (CIfL)_, pages 1-10, 2014.\n* [5] Gaetan Hadjeres, Francois Pachet, and Frank Nielsen. Deepbach: a steerable model for bach chorales generation. In _Proceedings of the 34th International Conference on Machine Learning-Volume 70_, pages 1362-1371. JMLR. org, 2017.\n* [6] Ruining He and Julian McAuley. Ups and downs: Modeling the visual evolution of fashion trends with one-class collaborative filtering. In _Proceedings of the 25th International Conference on World Wide Web_, WWW '16, pages 507-517, Republic and Canton of Geneva, Switzerland, 2016. International World Wide Web Conferences Steering Committee.\n* [7] Youngmoo E Kim, Erik M Schmidt, Raymond Migneco, Brandon G Morton, Patrick Richardson, Jeffrey Scott, Jacquelin A Speck, and Douglas Turnbull. Music emotion recognition: A state of the art review. In _Proc. ISMIR_, volume 86, pages 937-952. Citeseer, 2010.\n* [8] Ben Krause, Iain Murray, Steve Renals, and Liang Lu. Multiplicative LSTM for sequence modelling. _ICLR Workshop track_, 2017.\n* [9] Eduardo R Miranda, Wendy L Magee, John J Wilson, Joel Eaton, and Ramaswamy Palaniappan. Brain-computer music interfacing (bcmi): from basic research to the real world of special needs. _Music & Medicine_, 3(3):134-140, 2011.\n* [10] Kristine Monteith, Tony R Martinez, and Dan Ventura. Automatic generation of music for inducing emotive response. In _International Conference on Computational Creativity_, pages 140-149, 2010.\n* [11] Sageev Oore, Ian Simon, Sander Dieleman, and Doug Eck. Learning to create piano performances. In _NIPS 2017 Workshop on Machine Learning for Creativity and Design_, 2017.\n* [12] Rafael R Padovani, Lucas N Ferreira, and Levi HS Lelis. Bardo: Emotion-based music recommendation for tabletop role-playing games. In _Thirteenth Artificial Intelligence and Interactive Digital Entertainment Conference_, 2017.\n* [13] Alec Radford, Rafal Jozefowicz, and Ilya Sutskever. Learning to generate reviews and discovering sentiment. _arXiv preprint arXiv:1704.01444_, 2017.\n* [14] Adam Roberts, Jesse Engel, and Douglas Eck, editors. _Hierarchical Variational Autoencoders for Music_, 2017.\n* [15] James A Russell. A circumplex model of affect. _Journal of personality and social psychology_, 39(6):1161, 1980.\n* [16] Marco Scirea, Julian Togelius, Peter Eklund, and Sebastian Risi. Affective evolutionary music composition with metacompose. _Genetic Programming and Evolvable Machines_, 18(4):433-465, 2017.\n* [17] Mohammad Soleymani, Micheal N. Caro, Erik M. Schmidt, Cheng-Ya Sha, and Yi-Hsuan Yang. 1000 songs for emotional analysis of music. In _Proceedings of the 2Nd ACM International Workshop on Crowdsourcing for Multimedia_, CrowdMM '13, pages 1-6, New York, NY, USA, 2013. ACM.\n* [18] Duncan Williams, Alexis Kirke, Joel Eaton, Eduardo Miranda, Ian Daly, James Hallowell, Etienne Roesch, Faustina Hwang, and Slawomir J Nasuto. Dynamic game soundtrack generation in response to a continuously varying emotional trajectory. In _Audio Engineering Society Conference: 56th International Conference: Audio for Games_. Audio Engineering Society, 2015.\n* [19] Duncan Williams, Alexis Kirke, Eduardo R Miranda, Etienne Roesch, Ian Daly, and Slawomir Nasuto. Investigating affect in algorithmic composition systems. _Psychology of Music_, 43(6):831-854, 2015."}, "BIBREF179": {"title": "Automatic melody harmonization with triad chords: A comparative study", "authors": [{"first": "Yin-Cheng", "middle": [], "last": "Yeh", "suffix": ""}, {"first": "Wen-Yi", "middle": [], "last": "Hsiao", "suffix": ""}, {"first": "Satoru", "middle": [], "last": "Fukayama", "suffix": ""}, {"first": "Tetsuro", "middle": [], "last": "Kitahara", "suffix": ""}, {"first": "Benjamin", "middle": [], "last": "Genchel", "suffix": ""}, {"first": "", "middle": [], "last": "Hao-Min", "suffix": ""}, {"first": "Hao-Wen", "middle": [], "last": "Liu", "suffix": ""}, {"first": "Yian", "middle": [], "last": "Dong", "suffix": ""}, {"first": "Terence", "middle": [], "last": "Chen", "suffix": ""}, {"first": "Yi-Hsuan", "middle": [], "last": "Leong", "suffix": ""}, {"first": "", "middle": [], "last": "Yang", "suffix": ""}], "venue": "", "volume": "", "issue": "", "pages": "", "text_pymu": "Automatic Melody Harmonization with Triad Chords:\nA Comparative Study\nYin-Cheng Yeh, Wen-Yi Hsiao, Satoru Fukayama, Tetsuro Kitahara,\nBenjamin Genchel, Hao-Min Liu, Hao-Wen Dong, Yian Chen, Terence Leong, and\nYi-Hsuan Yang\nARTICLE HISTORY\nCompiled February 1, 2022\nABSTRACT\nSeveral prior works have proposed various methods for the task of automatic melody\nharmonization, in which a model aims to generate a sequence of chords to serve as\nthe harmonic accompaniment of a given multiple-bar melody sequence. In this paper,\nwe present a comparative study evaluating and comparing the performance of a set\nof canonical approaches to this task, including a template matching based model, a\nhidden Markov based model, a genetic algorithm based model, and two deep learning\nbased models. The evaluation is conducted on a dataset of 9,226 melody/chord\npairs we newly collect for this study, considering up to 48 triad chords, using a\nstandardized training/test split. We report the result of an objective evaluation\nusing six different metrics and a subjective study with 202 participants.\nKEYWORDS\nSymbolic music generation; automatic melody harmonization; functional harmony\n1. Introduction\nAutomatic\nmelody\nharmonization,\na\nsub-task\nof\nautomatic\nmusic\ngeneration\n(Fern\u00b4andez & Vico, 2013), refers to the task of creating computational models that\ncan generate a harmonic accompaniment for a given melody (Chuan & Chew, 2007;\nSimon, Morris, & Basu, 2008). Here, the term harmony, or harmonization, is used to\nrefer to chordal accompaniment, where an accompaniment is defined relative to the\nmelody as the supporting section of the music. Figure 1 illustrates the inputs and\noutputs for a melody harmonization model.\nMelody harmonization is a challenging task as there are multiple ways to harmonize\nthe same melody; what makes a particular harmonization pleasant is subjective, and\noften dependent on musical genre and other contextual factors. Tonal music, which\nencompasses most of Western music, defines specific motivic relations between chords\nbased on scales such as those defined in functional harmony (Riemann, 1893). While\nthese relations still stand and are taught today, their application towards creating\nYeh, Hsiao, Liu, Dong and Yang are with Academia Sinica, Taiwan ({ycyeh, wayne391, paul115236,\nsalu133445,\nyang}@citi.sinica.edu.tw);\nFukayama\nis\nwith\nNational\nInstitute\nof\nAdvanced\nIndustrial\nScience\nand\nTechnology,\nJapan\n(satoru\ns.fukayama@aist.go.jp);\nKitahara\nis\nwith\nNihon\nUniversity,\nJapan\n(kitahara@chs.nihon-u.ac.jp);\nGenchel\nis\nwith\nGeorgia\nInstitute\nof\nTechnology,\nUSA\n(benjiegenchel@gmail.com);\nChen\nand\nLeong\nare\nwith\nKKBOX\nInc.,\nTaiwan\n(annchen@kkbox.com,\nterenceleong@kkboxgroup.com)\narXiv:2001.02360v3  [cs.SD]  27 Apr 2021\n\fFigure 1.\nDiagram of the slightly modified version of the bidirectional long short-term memory network\n(BiLSTM) based model (Lim et al., 2017) for melody harmonization. The input to the model is a melody\nsequence. With two layers of BiLSTM and one fully-connected (FC) layer, the model generates as output a\nsequence of chord labels (e.g., Cm or B chords), one for each half bar. See Section 2.4 for details.\npleasant music often depends on subtleties, long term dependencies and cultural contexts which may be readily accessible to a human composer, but very difficult to learn\nand detect for a machine. While a particular harmonization may be deemed technically\ncorrect in some cases, it can also be seen as uninteresting in a modern context.\nThere have been several efforts made towards this task in the past (Makris, Kayrdis,\n& Sioutas, 2016). Before the rise of deep learning, the most actively employed approach\nis based on hidden Markov models (HMMs). For example, Paiement, Eck, and Bengio (2006) proposed a tree-structured HMM that allows for learning the non-local\ndependencies of chords, and encoded probabilities for chord substitution taken from\npsycho-acoustics. They additionally presented a novel representation for chords that\nencodes relative scale degrees rather than absolute note values, and included a subgraph in their model specifically for processing it. Tsushima, Nakamura, Itoyama,\nand Yoshii (2017) similarly presented a hierarchical tree-structured model combining\nprobabilistic context-free grammars (PCFG) for chord symbols and HMMs for chord\nrhythms. Temperley (2009) presented a statistical model that would generate and\nanalyze music along three sub-structures: metrical structure, harmonic structure, and\nstream structure. In the generative portion of this model, a metrical structure defining\nthe emphasis of beats and sub-beats is first generated, and then harmonic structure\nand progression are generated conditioned on that metrical structure.\nThere are several previous works which attempt to formally and probabilistically\nanalyze tonal harmony and harmonic structure. For example, Rohrmeier and Cross\n(2008) applied a number of statistical techniques to harmony in Bach chorales in order\nto uncover a proposed underlying harmonic syntax that naturally produces common\nperceptual and music theoretic patterns including functional harmony. Jacoby, Tishby,\nand Tymoczko (2015) attempted to categorize common harmonic symbols (scale degrees, roman numerals, or sets of simultaneous notes) into higher level functional\n2\n\fgroups, seeking underlying patterns that produce and generalize functional harmony.\nTsushima, Nakamura, Itoyama, and Yoshii (2018) used unsupervised learning in training generative HMM and PCFG models for harmonization, showing that the patterns\nlearned by these models match the categorizations presented by functional harmony.\nMore lately, people have begun to explore the use of deep learning for a variety of\nmusic generation tasks (Briot, Hadjeres, & Pachet, 2017). For melody harmonication,\nLim et al. (2017) proposed a model that employed two bidirectional long short-term\nmemory (BiLSTM) recurrent layers (Hochreiter & Schmidhuber, 1997) and one fullyconnected layer to learn the correspondence between pairs of melody and chord sequences. The model architecture is depicted in Figure 1. According to the experiments\nreported in (Lim et al., 2017), this model outperforms a simple HMM model and a\nmore complicated DNN-HMM model (Hinton et al., 2012) for melody harmonization\nwith major and minor triad chords.\nMoreover, melody harmonization is also relevant to four-part chorale harmonization (Allan & Williams, 2005; Ebcio\u02c7glu, 1988; Hadjeres & Pachet, 2017; C.Z. A. Huang, Cooijmans, Roberts, Courville, & Eck, 2017) and accompaniment generation (Chuan & Chew, 2007; Dong, Hsiao, Yang, & Yang, 2018; Simon et al., 2008).\nAlthough these three tasks share the same input, monophonic melodies, they have\ndistinct outputs\u2014lead sheets, four-part chorales and full arrangements, respectively.\nAnother relevant topic is harmonic analysis (T.-P. Chen & Su, 2018; De Haas, Magalh\u02dcaes, Wiering, & Veltkamp, 2014; Harte, Sandler, & Gasser, 2006; Raphael & Stoddard, 2004; Temperley, 2009). Despite having similar input and output spaces, melody\nharmonization is fundamentally different from harmonic analysis. On one hand, harmonic analysis takes polyphonic music as inputs, while melody harmonization takes\nmonophonic melodies as inputs and is considered more difficult as less harmonic information is given. On the other hand, there is in general a correct answer for harmonic\nanalysis, while there are no strict answers for melody harmonization.\nWe note that, while many new models are being proposed for melody harmonization,\nat present there is no comparative study evaluating a wide array of different approaches\nfor this task, using the same training set and test set. Comparing models trained on\ndifferent training sets is problematic as it is hard to have a standardized definition of\nimprovement and quality. Moreover, as there is to date no standardized test set for\nthis task, it is hard to make consistent comparison between different models.\nIn this paper, we aim to bridge this gap with the following three contributions:\n(1) We implement in total five melody harmonization models that span a number of\ncanonical approaches to the task, including template matching, hidden Markov\nmodel (HMM) (Simon et al., 2008), genetic algorithm (GA) (Kitahara, Giraldo,\n& Ramirez, 2018), and two variants of deep recurrent neural network (RNN)\nmodels (Lim et al., 2017). We then present a comparative study comparing the\nperformance of these models. To our best knowledge, a comparative study that\nconsiders such a diverse set of approaches for melody harmonization using a\nstandardized dataset has not been attempted before.\nAs we follow fairly faithfully the implementation proposed in the original\npublications, these models differ in terms of not only the model architectures but\nalso the employed features. Therefore, we have to admit that our study cannot\ndecouple the effects of the model architectures and the features. Yet, we note\nthat the comparison of the first four models is an architecture-vs-architecture\ncomparison, while the comparison of the two RNN models is a feature-vs-feature\ncomparison.\n3\n\f(2) We compile a new dataset, called the Hooktheory Pianoroll Triad Dataset\n(HTPD3), to evaluate the implemented models over well-annotated lead sheet\nsamples of music. A lead sheet is a form of musical notation that specifies the\nessential elements of a song\u2014the melody, harmony, and where present, lyrics\n(Liu & Yang, 2018). HTPD3 provides melody lines and accompanying chords\nspecifying both chord symbol and harmonic function useful for our study. We\nconsider 48 triad chords in this study, including major, minor, diminished, and\naugmented triad chords.\nWe use the same training split of HTPD3 to train the implemented models\nand evaluate them on the same test split.\n(3) We employ six objective metrics for evaluating the performance of melody harmonization models. These metrics consider either the distribution of chord labels\nin a chord sequence, or how the generated chord sequence fits with the given\nmelody. In addition, we conduct an online user study and collect the feedback\nfrom 202 participants around the world to assess the quality of the generated\nchordal accompaniment.\nWe discuss the findings of comparative study, hoping to gain insights into the\nstrength and weakness of the evaluated methods. Moreover, we show that incorporating the idea of functional harmony (T.-P. Chen & Su, 2018) while harmonizing\nmelodies greatly improves the result of the model presented by (Lim et al., 2017).\nIn what follows, we present in Section 2 the models we consider and evaluate in\nthis comparative study. Section 3 provides the details of the HTPD3 dataset we build\nfor this study, and Section 4 the objective metrics we consider. Section 5 presents the\nsetup and result of the study. We discuss the findings and limtiations of this study in\nSection 6, and then conclude the paper in Section 7.\n2. Automatic Melody Harmonization Models\nA melody harmonization model takes a melody sequence of T bars as input and generates a corresponding chord sequence as output. Chord Sequence is defined here as a\nseries of chord labels Y = y1, y2, . . . , yM, where M denotes the length of the sequence.\nIn this work, each model predicts a chord label for every half bar, i.e. M = 2T. Each\nlabel yj is chosen from a finite chord vocabulary C. To reduce the complexity of this\ntask, we consider here only the triad chords, i.e., chords composed of three notes.\nSpecifically, we consider major, minor, diminished, and augmented triad chords, all\nin root position. We also consider No Chord (N.C.), or rest, so the size of the chord\nvocabulary is |C| = 49. Melody Sequence is a time-series of monophonic musical notes\nin MIDI format. We compute a sequence of features as X = x1, x2, . . . , xN to represent\nthe melody and use them as the inputs to our models. Unless otherwise specified, we\nset N = M, computing a feature vector for each half bar.\nGiven a set of melody and corresponding chord sequences, a melody harmonization\nmodel f(\u00b7) can be trained by minimizing the loss computed between the ground truth\nY\u2217 and the model output \u02c6Y\u2217 = f(X\u2217), where X\u2217 is the input melody.\nWe consider three non-deep learning based and two deep learning based models in\nthis study. While the majority are adaptation of existing methods, one (deep learning\nbased) is a novel method which we introduce in this paper (see Section 2.5). All models\nare carefully implemented and trained using the training split of HTPD3. We present\nthe technical details of these models below.\n4\n\f2.1. Template Matching-based Model\nThis model is based on an early work on audio-based chord recognition (Fujishima,\n1999). The model segments training melodies into half-bars, and constructs a pitch\nprofile for each segment. The chord label for a new segment is then selected based on\nthe label for the training segment whose pitch profile it most closely matches. When\nthere is more than one possible chord template that has the highest matching score,\nwe choose a chord randomly based on uniform distribution among the possibilities. We\nrefer to this model as template matching-based as the underlying method compares\nthe profile of a given melody segment with those of the template chords.\nWe use Fujishima\u2019s pitch class profile (PCP) (Fujishima, 1999) as the pitch profile\nrepresenting respectively the melody and chord for each half-bar. A PCP is a 12dimensional feature vector x \u2208 [0, 1]12 where each element corresponds to the activity\nof a pitch class. The PCP for each of the |C| chord labels is constructed by setting\nthe elements corresponding to the pitch classes that are part of the chord to one, and\nall the others to zero. Because we consider only triad chords in this work, there will\nbe exactly three one\u2019s in the PCP of a chord label for each half bar. The PCP for\nmelody is constructed similarly, but additionally considering the duration of notes.\nSpecifically, the activity of the k-th pitch class, i.e., xk \u2208 [0, 1], is set by the ratio of\ntime the pitch class is active during the corresponding half bar.\nThe result of this model are more conservative by design, featuring intensive use\nof chord tones. And, this model sets the chord label independently for each half bar,\nwithout considering the neighboring chord labels, or the chord progression over time.\nWe note that, to remove the effect of the input representations on the harmonization\nresult, we use PCP as the model input representation for all the other models we\nimplement for melody harmonizationm.\n2.2. HMM-based Model\nHMM is a probabilistic framework for modeling sequences with latent or hidden variables. Our HMM-based harmonization model regards chord labels as latent variables\nand estimates the most likely chord sequence for a given set of melody notes. Unlike\nthe template matching-based model, this model considers the relationship between\nneighboring chord labels. HMM-based models similar to this one were widely used in\nchord generation and melody harmonization research before the current era of deep\nlearning (Raczy\u00b4nski, Fukayama, & Vincent, 2013; Simon et al., 2008).\nWe adopt a simple HMM architecture employed in (Lim et al., 2017). This model\nmakes the following assumptions:\n1. The observed melody sequence X = x1, . . . , xM is statistically biased due to the\nhidden chord sequence Y = y1, . . . , yM, which is to be estimated.\n2. xm depends on only ym, \u2200m \u2208 [1, M].\n3. ym depends on only ym\u22121, \u2200m \u2208 [2, M].\nThe task is to estimate the most likely hidden sequence \u02c6Y = \u02c6y1, . . . , \u02c6yM given X. This\namounts to maximizing the posterior probability:\n\u02c6Y\n=\narg max\nY\nP(Y |X) = arg max\nY\nP(X|Y )P(Y )\n=\narg max\nY\nM\n\ufffd\nm=1\nP(xm|ym)P(ym|ym\u22121),\n(1)\n5\n\fwhere P(y1|y0) is equal to P(y1). The term P(xm|ym) is also called the emission probability, and the term P(ym|ym\u22121) is called the transition probability. This optimization\nproblem can be solved by the Viterbi algorithm (Forney, 1973).\nDeparting from the HMM in (Lim et al., 2017), our implementation uses the PCPs\ndescribed in Section 2.1 to represent melody notes, i.e., to compute xm. Accordingly,\nwe use multivariate Gaussian distributions to model the emission probabilities, as\ndemonstrated by Fujishima (Sheh & Ellis, 2003). For each chord label, we set the\ncovariance matrix of the corresponding Gaussian distribution to be a diagonal matrix,\nand calculate the mean and variance for each dimension from the PCP features of\nmelody segments that are associated with that chord label in the training set.\nTo calculate the transition probabilities, we count the number of transitions between\nsuccessive chord labels (i.e., bi-grams), then normalize those counts to sum to one\nfor each preceding chord label. A uniform distribution is used when there is no bigram count for the preceding chord label. To avoid zero probabilities, we smooth the\ndistribution by interpolating P(ym|ym\u22121) with the prior probability P(ym) as follows,\nP \u2032(ym|ym\u22121) = (1 \u2212 \u03b2)P(ym) + \u03b2P(ym|ym\u22121) ,\n(2)\nyielding the revised transition probability P \u2032(ym|ym\u22121). The hyperparameter \u03b2 is empirically set to 0.08 via experiments on a random 10% subset of the training set.\n2.3. Genetic Algorithm (GA)-based Model\nA GA is a flexible algorithm that generally maximizes an objective function or fitness\nfunction. GAs have been used for melody generation and harmonization in the past\n(de Le\u00b4on, I\u02dcnesta, Calvo-Zaragoza, & Rizo, 2016; Phon-Amnuaisuk & Wiggins, 1999),\njustifying their inclusion in this study. A GA can be used in both rule-based and probabilistic approaches. In the former case, we need to design a rule set of what conditions\nmust be satisfied for musically acceptable melodies or harmonies\u2014the fitness function\nis formulated based on this rule set. In the latter, the fitness function is formulated\nbased on statistics of a data set.\nHere, we design a GA-based melody harmonization model by adapting the GAbased melody generation model proposed by (Kitahara et al., 2018). Unlike the other\nimplemented models, the GA-based model takes as input a computed feature vector\nfor every 16-th note (i.e., 1/4 beats). Thus, the melody representation has a temporal\nresolution 8 times that of the chord progression (i.e., N = 8M). This means that x8m\nand ym point to the same temporal position.\nOur model uses a probabilistic approach, determining a fitness function based on\nthe following elements. First, the (logarithmic) conditional probability of the chord\nprogression given the melody is represented as:\nF1(X, Y ) =\nN\n\ufffd\nn=1\nlog P(y\u2308n/8\u2309|xn),\n(3)\nwhere \u2308 \u2309 is the ceiling function. The chord transition probability is computed as:\nF2(Y ) =\nM\n\ufffd\nm=3\nlog P(ym|ym\u22122, ym\u22121) .\n(4)\n6\n\fThe conditional probability of each chord given its temporal position is defined as:\nF3(Y ) =\nM\n\ufffd\nm=1\nlog P(ym|Posm) ,\n(5)\nwhere Posm is the temporal position of the chord ym. For simplicity, we defined Posm =\nmod(m, 8), where mod is the modulo function. With this term, the model may learn\nthat the tonic chord tends to appear at the first half of the first bar, while the dominant\n(V ) chord tends to occur at the second half of the second bar.\nFinally, we use the entropy to evaluate a chord sequence\u2019s complexity, which should\nnot be too low as to avoid monotonous chord sequences. The entropy is defined as\nE(Y ) = \u2212 \ufffd\nci\u2208C P(Y = ci) log P(Y = ci). In the fitness function, we evaluate how\nlikely this entropy E(Y ) is in a given data set.\nF4(Y ) = log P(E = E(Y )) ,\n(6)\nwhere E is the random variable of the entropy of chord progressions and is discritized\nby 0.25. Its probability distribution is obtained from the training data.\nThe fitness function F(Y ) is calculated as:\nF(Y ) = w1F1(X, Y ) + w2F2(Y ) + w3F3(Y ) + w4F4(Y ) .\n(7)\nWe simply set all the weights w1, w2, w3, w4 to 1.0 here.\n2.4. Deep BiLSTM-based Model\nThis first deep learning model is adapted from the one proposed by (Lim et al.,\n2017), which uses BiLSTM layers. This model extracts contextual information from\nthe melody sequentially from both the positive and negative time directions. The original model makes chord prediction for every bar, using a vocabulary of only the major\nand minor triad chords (i.e., |C| = 24). We slightly extend this model such that the\nharmonic rhythm is a half bar, and the output chord vocabulary includes diminished\nand augmented chords, and the N.C. symbol (i.e., |C| = 49).\nAs shown in Figure 1, this model has two BiLSTM layers, followed by a fullyconnected layer. Dropout (Srivastava, Hinton, Krizhevsky, Sutskever, & Salakhutdinov, 2014) is applied with probability 0.2 at the output layer. This dropout rate, as\nwell as the number of hidden layers and hidden units, are empirically chosen by maximizing the chord prediction accuracy on a random held-out subset of the training set.\nWe train the model using minibatch gradient descent with categorical cross entropy as\nthe the cost function. We use Adam as the optimizer and regularize by early stopping\nat the 10-th epoch to prevent over-fitting.\n2.5. Deep Multitask Model: MTHarmonizer\nFrom our empirical observation on the samples generated by the aforementioned BiLSTM model, we find that the model has two main defects for longer phrases:\n(1) overuse of common chords\u2014common chords like C, F, and G major are\nrepeated and overused, making the chord progression monotonous.\n7\n\f(2) incorrect phrasing\u2014non-congruent phrasing between the melody and chords\nsimilarly results from the frequent occurrence of common chords. The resulting\nfrequent occurrence of progressions like F\u2192C or G\u2192C in generated sequences\nimplies a musical cadence in an unfit location, potentially bringing an unnecessary sense of ending in the middle of a chord sequence.\nWe propose an extension of the BiLSTM model to address these two defects. The\ncore idea is to train the model to predict not only the chord labels but also the chord\nfunctions (T.-P. Chen & Su, 2018), as illustrated in Figure 2. We call the resulting\nmodel a deep multitask model, or MTHarmonizer, since it deals with two tasks at the\nsame time. We note that the use of the chord functions for melody harmonization has\nbeen found useful by Tsushima et al. (2018), using an HMM-based model.\nFunctional harmony elaborates the relationship between chords and scales, and\ndescribes how harmonic motion guides musical perception and emotion (T.-P. Chen &\nSu, 2018). While a chord progression consisting of randomly selected chords generally\nfeels aimless, chord progressions which follow the rules of functional harmony establish\nor contradict a tonality. Music theorists annotate each scale degree into functions,\nsuch as tonic and dominant, based on the association between chord and degree in a\nparticular scale. These functions explain the role a given scale degree, and its associated\nchord relative to the scale, plays in musical phrasing and composition. Specifically, we\nconsider the following functions:\n\u2022 The tonic function serves to stabilize and reinforce the tonal center.\n\u2022 The dominant function provides a strong sense of motion back to tonal center.\nFor example, a progression that moves from a dominant function scale degree\nchord to a tonal scale degree chord first creates tension, then resolves it.\n\u2022 The others that encompasses all the other chords that are neither tonic nor\ndominant, such as the subdominant chords.\nAs will be introduced in Section 3, all the pieces in HTPD3 are in either C Major\nor c minor. Therefore, all chords share the same tonal center. We can directly map the\nchords into \u2018tonic,\u2019 \u2018dominant,\u2019 and \u2018others\u2019 functional groups, by name, without worrying about their relative functions in other keys, for other tonal centers. Specifically,\nwe consider C, Am, Cm, A as tonic chords, and G and B diminished as dominant\nchords. The other chords all fall into the others category.\nWe identify two potential benefits of adding chord functions to the target output.\nFirst, in contrast to the distribution of chord labels, the distribution of chord functions\nis relatively balanced, making it easier for the model to learn the chord functions.\nSecond, as the chord functions and chord labels are interdependent, adding the chord\nfunctions as a target informs the model which chord labels share the same function and\nmay therefore be interchangeable. We hypothesize that this multi-task learning will\nhelp our model learn proper functional progression, which in turn will produce better\nharmonic phrasing relative to the melody. Specifically, the loss function is defined as:\nL\u2217\n=\nLchord + \u03b3Lfunction\n=\nH( \u02c6Ychord, Ychord) + \u03b3H( \u02c6Yfunction, Yfunction)\n=\nH(f(X), Ychord) + \u03b3H(g(X), Yfunction) ,\n(8)\nwhere H(\u00b7) denotes the categorical cross entropy function, f(\u00b7) the chord label prediction branch, and g(\u00b7) the chord function prediction branch. When \u03b3 = 0, the model\nreduces to the uni-task model proposed by Lim et al. (2017), and we can simply write\n8\n\fFigure 2.\nDiagram of the proposed MTHarmonizer, a deep multitask model extended from the model (Lim\net al., 2017) depicted in Figure 1. See Section 2.5 for details.\nYchord as Y . In our work, we set \u03b3 = 1.5 to ensure the loss value from Lchord and\nLfunction are equally scaled. The two branches f and g share the two BiLSTM layers\nbut not the fully-connected layer. Empirically, we found that if \u03b3 is too small, the\nmodel will tend to harmonize the melody with the chords with tonic and dominant\nfunctions; the resulting chord sequences would therefore lack diversity.\nThe outputs of f and g are likelihood values for each chord label and chord function\ngiven an input melody. As Figure 2 shows, in predicting the final chord sequence, we\nrely on a weighted combination of the outputs of f and g in the following way:\n\u02c6Y = arg max\n\u02c6y1,\u02c6y2,...,\u02c6yM\nM\n\ufffd\nm=1\n(P(\u02c6ym = f(xm)) \u2217 \u03b1mP(\u02c6ym = h(g(xm)))) ,\n(9)\nwhere h(\u00b7) is simply a look-up table that maps the three chord functions to the |C|\nchord labels, and \u03b1m is a pre-defined hyperparameter that allows us to boost the\nimportance of correctly predicting the chord function over that of correctly predicting\nthe chord label, for each chord. In our implementation, we set \u03b1m = 1.0 for the tonic\nand dominant chords, and \u03b1m = 1.8 for the other chords, to encourage the model to\nselect chord labels that have lower likelihood, i.e., to use the \u201cothers\u201d chords. This\nwould more likely affect the middle part of a chord sequence, because this is where the\nlikelihood to observe a chord from the three functions to be likely similar, so applying\ndifferent \u03b1m makes a difference. In contrast, in the beginning or the end of a phrase,\nthe likelihood of observing the \u201cothers\u201d chords would tend to be low anyway, even\nafter we boost it with \u03b1m. As we will mainly add diversity to the middle part of a\nchord sequence, we would not compromise the overall chord progression and phrasing.\n9\n\f3. Proposed Dataset\nFor the purpose of this study, we firstly collect a new dataset called the Hooktheory Lead Sheet Dataset (HLSD), which consists of lead sheet samples scraped from\nthe online music theory forum called TheoryTab, hosted by Hooktheory (https://\nwww.hooktheory.com/theorytab), a company that produces pedagogical music software and books. The majority of lead sheet samples found on TheoryTab are usercontributed.1 Each piece contains high-quality, human-transcribed melodies alongside\ntheir corresponding chord progressions, which are specified by both literal chord symbols (e.g., Gmaj7), and chord functions (e.g., VI7) relative to the provided key.Chord\nsymbols specify inversion if applicable, and the full set of chord extensions (e.g., #9,\nb11). The metric timing/placement of the chords is also provided. Due to copyright\nconcerns, TheoryTab prohibits uploading full length songs. Instead, users upload snippets of a song (here referred to as lead sheet samples), which they voluntarily annotate\nwith structural labels (e.g. \u201cIntro,\u201d \u201cVerse,\u201d and \u201cChorus\u201d) and genre labels. A music\npiece can be associated with multiple genres.\nAs the samples in this dataset are segments of pop songs, e.g., a verse or a chorus,\ntemporary changes of the tonal center should be rare.\nWe note that HLSD contains music of various genres, and only a few of them are\nclassical music.2 As discussed in (de Clercq & Temperley, 2011), the rules of classical\nharmony are much less often followed in pop music. In addition, melodies in pop/rock\nmusic are more independent of the harmony than the case in classical music (Nobile,\n2015; Temperley, 2007). It therefore remains to be studied whether the consideration\nof functional harmony improves our task here.\nHLSD contains 11,329 lead sheets samples, all in 4/4 time signature. It contains up\nto 704 different chord classes, which is deemed too many for the current study. We\ntherefore take the following steps to process and simplify HLSD, resulting in the final\nHTPD3 dataset employed in the performance study.\n\u2022 We remove lead sheet samples that do not contain a sufficient number of notes.\nSpecifically, we remove samples whose melodies comprise of more than 40% rests\n(relative to their lengths). One can think of this as correcting class imbalance,\nanother common issue for machine learning models\u2014if the model sees too much\nof a single event, it may overfit and only produce or classify that event.\n\u2022 We then filter out lead sheets that are less than 4 bars and longer than 32 bars, so\nthat 4 \u2264 T \u2264 32. This is done because 4 bars is commonly seen as the minimum\nlength for a complete musical phrase in 4/4 time signature. At the other end, 32\nbars is a common length for a full lead sheet, one that is relatively long. Hence,\nas the majority of our dataset consists of mere song sections, we are inclined for\nnot including samples longer than 32 bars.\n\u2022 The HLSD provides the key signatures of every samples. We transpose every\nsamples to either C major or c minor based on the provided key signatures.\n\u2022 In general, a chord label can be specified by the pitch class of its root note (among\n1We note that we do not own the copyrights of the lead sheets so we cannot further redistribute them. We\ncollected the lead sheets only for academic research.\n2Here is a random sample of 10 songs from the dataset: Love Grows Where My Rosemary Goes by Edison\nLighthouse (1972), La Bamba by Ritchie Valen (1987), Palm Tree Paradise-Wario Land 4 by Ryoji Yoshitomi\n(2001), Forever and Always by Taylor Swift (2008), Trails of the Past by Sbtrkt (2011), I\u2019ve Run Away to\nJoin the Fairies by Magnetic Fields (2012), Semi Automatic by Twenty One Pilots (2013), Adventure of A\nLifetime by Coldplay (2015), Same Drugs by Chance the Rapper (2016), Feel Good-Brooks Remix by Gryffin\nAnd Illenium (2017).\n10\n\f12 possible pitch classes, i.e., C, C#, . . . , B, in a chromatic scale), and its chord\nquality, such as \u2018triad\u2019, \u2018sixths\u2019, \u2018sevenths\u2019, and \u2018suspended.\u2019 HLSD contains 704\npossible chord labels, including inversions. However, the distribution of these\nlabels is highly skewed. In order to even out the distribution and simplify our\ntask, we reduce the chord vocabulary by converting each label to its root position\ntriad form, i.e., the major, minor, diminished, and augmented chords without\n7ths or additional extensions. Suspended chords are mapped to the major and\nminor chords. As a result, only 48 chord labels (i.e., 12 root notes by 4 qualities)\nand N.C. are considered (i.e., |C| = 49).\n\u2022 We standardize the dataset so that a chord change can occur only every bar or\nevery half bar.\nWe do admit that this simplification can decrease the chord color and reduce the\nintensity of tension/release patterns, and can sometimes convert a vibrant, subtle\nprogression into a monotonous one (e.g., because both CMaj7 and C7 are mapped to\nC chord). We plan to make full use of the original chord vocabulary in future works.\nHaving pre-defined train and test splits helps to facilitate the use of HTPD3 for\nevaluating new models of melody harmonization via the standardization of training\nprocedure. As HTPD3 includes paired melody and chord sequences, it can also be\nused to evaluate models for chord-conditioned melody generation as well. With these\nuse cases in mind, we split the dataset so that the training set contains 80% of the\npieces, and the test set contains 10% of the pieces. There are in total 923 lead sheet\nsamples in the test set. The remaining 10% is reserved for future use. When splitting,\nwe imposed the additional requirement that lead sheet samples from the same song\nare in the same subset.\n4. Proposed Objective Metrics\nTo our knowledge, there are at present no standardized, objective evaluation metrics\nfor the melody harmonization task. The only objective metric adopted by (Lim et al.,\n2017), in evaluating the models they built is a categorical cross entropy-based chord\nprediction error, representing the discrepancy between the ground truth chords Y\u2217\nand predicted chords \u02c6Y\u2217 = f(X\u2217). The chord prediction error is calculated for each\nhalf bar individually and then got averaged, not considering the chord sequence as\na whole. In addition, it does not directly measure how the generated chord sequence\nfits with the given melody. What\u2019s more, when calculating the chord prediction error,\nthe underlying assumption is that the \u201cground truth\u201d chord sequence Y\u2217 is the only\nfeasible one to harmonize the given melody X\u2217. This is not true in general.\nFor the comparative study, we introduce here a set of six objective metrics defined\nbelow. These metrics are split into two categories, namely three chord progression\nmetrics and three chord/melody harmonicity metrics. Please note that we do not\nevaluate the melody itself, as the melody is provided by the ground truth data.\nChord progression metrics evaluate each chord sequence as a whole, independent\nfrom the melody, and relate to the distribution of chord labels in a sequence.\n\u2022 Chord histogram entropy (CHE): Given a chord sequence, we create a histogram of chord occurrences with |C| bins. Then, we normalize the counts to sum\n11\n\fto 1, and calculate its entropy:\nH = \u2212\n|C|\n\ufffd\ni=1\npi log pi ,\n(10)\nwhere pi is the relative probability of the i-th bin. The entropy is greatest when\nthe histogram follows a uniform distribution, and lowest when the chord sequence\nuses only one chord throughout.\n\u2022 Chord coverage (CC): The number of chord labels with non-zero counts in the\nchord histogram in a chord sequence.\n\u2022 Chord tonal distance (CTD): The tonal distance proposed by (Harte et al.,\n2006) is a canonical way to measure the closeness of two chords. It is calculated by\nfirstly calculating the PCP features of two chords, projecting the PCP features to\na derived 6-D tonal space, and finally calculating the Euclidean distance between\nthe two 6-D feature vectors. CTD is the average value of the tonal distance\ncomputed between every pair of adjacent chords in a given chord sequence. The\nCTD is highest when there are abrupt changes in the chord progression (e.g.,\nfrom C chord to B chord).\nChord/melody harmonicity metrics, on the other hand, aims to evaluate the degree\nto which a generated chord sequence successfully harmonizes a given melody sequence.\n\u2022 Chord tone to non-chord tone ratio (CTnCTR): In reference to the chord\nsequence, we count the number of chord tones, and non-chord tones in the melody\nsequence. Chord tones are defined as melody notes whose pitch class are part of\nthe current chord (i.e., one of the three pitch classes that make up a triad) for\nthe corresponding half bar. All the other melody notes are viewed as non-chord\ntones. One way to measure the harmonicity is to simply computing the ratio\nof the number of the chord tones (nc) to the number of the non-chord tones\n(nn). However, we find it useful to further take into account the number of a\nsubset of non-chord tones (np) that are two semitones within the notes which\nare right after them, where subscript p denotes a \u201cproper\u201d non-chord tone. We\ndefine CTnCTR as\nnc + np\nnc + nn\n.\n(11)\nCTnCTR equals one when there are no non-chord tones at all, or when np = nn.\n\u2022 Pitch consonance score (PCS): For each melody note, we calculate a consonance score with each of the three notes of its corresponding chord label. The\nconsonance scores are computed based on the musical interval between the pitch\nof the melody notes and the chord notes, assuming that the pitch of the melody\nnotes is always higher. This is always the case in our implementation, because we\nalways place the chord notes lower than the melody notes. The consonance score\nis set to 1 for consonance intervals including unison, major/minor 3rd, perfect\n5th, major/minor 6th, set to 0 for a perfect 4th, and set to \u20131 for other intervals,\nwhich are considered dissonant. PCS for a pair of melody and chord sequences\nis computed by averaging these consonance scores across a 16th-note windows,\nexcluding rest periods.\n\u2022 Melody-chord tonal distance (MCTD): Extending the idea of tonal distance,\nwe represent a melody note by a PCP feature vector (which would be a one-hot\n12\n\fFigure 3.\nA harmonization example (in major key) from The Beatles: Hey Jude. We can see that, while the\nnon-deep learning models change the harmonization in different phrases, the MTharmonizer generates a V-I\nprogression nicely to close the phrase.\nvector) and compare it against the PCP of a chord label in the 6-D tonal space\n(Harte et al., 2006) to calculate the closeness between a melody note and a chord\nlabel. MCTD is the average of the tonal distance between every melody note and\ncorresponding the chord label calculated across a melody sequence, with each\ndistance weighted by the duration of the corresponding melody note.\n5. Comparative Study\nWe train all the five models described in Section 2 using the training split of HTPD3\nand then apply them to the test split of HTPD3 to get the predicted chord sequences\nfor each melody sequence. Examples of the harmonization result of the evaluated\nmodels can be found in Figures 3 and 4.\nWe note that, since one cannot judge the full potential of each algorithm only\nfrom our simplified setting of melody harmonization, we do not intend to find what\nmethod is the best in general. We rather attempt a challenge to compare different\nharmonization method which have not been directly compared because of the different\ncontext that each approach assumes.\nIn what follows, we use the harmonization result for a random subset of the test\nset comprising 100 pieces in a user study for subjective evaluation. The result of\nthis subjective evaluation is presented in Section 5.1. Then, in Section 5.2, we report\nthe results of an objective evaluation wherein we compute the mean values of the\nchord/melody harmonicity and chord progression metrics presented in Section 4 for\nthe harmonization results for each test set piece.\n13\n\fFigure 4.\nA harmonization example (in minor key) from ABBA: Gimme Gimme Gimme A Man After\nMidnight. Similar to the example shown in Figure 3, the result of the MTHarmonizer appears to be more\ndiverse and functionally correct. We also see that the result of GA is quite \u201cinteresting\u201d\u2014e.g., with nondiatonic chord D flat Major and close the music phrase with Picardy third (i.e., a major chord of the tonic at\nthe end of a chord sequence that is in a minor key). We also see that the non-deep learning methods seem to\nbe weaker in handling the tonality of music.\n5.1. Subjective Evaluation\nWe conducted an online survey where we invited human subjects to listen to and assess\nthe harmonization results of different models. The subjects evaluated the harmonizations in terms of the following criteria:\n\u2022 Harmonicity: The extent to which a chord progression successfully or pleasantly harmonizes a given melody. This is designed to correspond to what the\nmelody/chord harmonicity metrics described in Section 4 aim to measure.\n\u2022 Interestingness: The extent to which a chord progression sounds exciting, unexpected and/or generates \u201cpositive\u201d stimulation. This criterion corresponds to\nthe chord-related metrics described in Section 4. Please note that we use a less\ntechnical term \u201cinterestingness\u201d here since we intend to solicit feedback from\npeople either with or without musical backgrounds.\n\u2022 The Overall quality of the given harmonization.\nGiven a melody sequence, we have in total six candidate chord sequences to accompany it: those generated by the five models presented in Section 2, and the humancomposed, ground-truth progression retrieved directly from the test set. We intend\nto compare the results of the automatically generated progression with the original\nhuman-composed progression. Yet, given the time and cognitive load required, it was\nnot possible to ask each subject to evaluate the results of every model for every piece\nof music in the test set (there are 6 \u00d7 923 = 5, 538 sequences in total). We describe\nbelow how our user study is designed to make the evaluation feasible.\n14\n\f5.1.1. Design of the User Study\nFirst, we randomly select 100 melodies from the test set of HTPD3. For each human\nsubject, we randomly select three melody sequences from this pool, and present to the\nsubject the harmonization results of two randomly selected models for each melody\nsequence. For each of the three melodies, the subject listens to the melody without\naccompaniment first, and then the sequence with two different harmonizations. Thus,\nthe subject has to listen to nine music pieces in total: three melody sequences and the\nsix harmonized ones. As we have six methods for melody harmonization (including\nthe original human-composed harmonization), we select methods for each set of music\nsuch that each method is presented once and only once to each subject. The subjects\nare not aware of which harmonization is generated by which method, but are informed\nthat at least one of the harmonized sequence is human-composed.\nIn each set, the subject has to listen to the two harmonized sequences and decide\nwhich version is better according to the three criteria mentioned earlier. This ranking\ntask is mandatory. In addition, the subject can choose to further grade the harmonized\nsequences in a five-point Likert scale with respect to the criteria mentioned earlier.\nHere, we break \u201charmonicity\u201d into the following two criteria in order to get more\nfeedback from subjects:\n\u2022 Coherence: the coherence between the melody and the chord progression in\nterms of harmonicity and phrasing.\n\u2022 Chord Progression: how coherent, pleasant, or reasonable the chord progression is on its own, independent of the melody.\nThis optional rating task thus has four criteria in total.\nThe user study opens to an \u201cinstructions\u201d page, that informs the subjects that we\nconsider only root-positioned triad chords in the survey. Moreover, they are informed\nthat there is no \u201cground truth\u201d in melody harmonization\u2014the task is by nature subjective. After collecting a small amount of relevant personal information from the\nsubjects, we present them with a random audio sample and encourage them to put\non their headsets and adjust the volume to a comfortable level. After that, they are\nprompted to begin evaluating the three sets (i.e., one set for each melody sequence),\none-by-one on consecutive pages.\nWe spread the online survey over the Internet openly, without restriction, to solicit voluntary, non-paid participation. The webpage of the survey can be found at\nhttps://musicai.citi.sinica.edu.tw/survey mel harm/.\n5.1.2. User Study Results\nIn total, 202 participants from 16 countries took part in the survey. We had more\nmale participants than female (ratio of 1.82:1), and the average age of participants\nwas 30.8 years old. 122 participants indicated that they have music background, and\n69 of them are familiar with or expertise in the harmonic theory. The participants\ntook on average 14.2 minutes to complete the survey.\nWe performed the following two data cleaning steps: First, we discarded both the\nranking and rating results from participants who spent less than 3 minutes to complete\nthe survey, which is considered too short. Second, we disregarded rating results when\nthe relative ordering of the methods contradicted that from the ranking results. As a\nresult, 9.1% and 21% of the ranking and rating records were removed, respectively.\nWe first discuss the results of the pairwise ranking task, which is shown in Figure\n5. The following observations are made:\n15\n\f(a) Harmonicities\n(b) Interestingness\n(c) Overall\nFigure 5.\n\u201cWin probabilities\u201d of different model pairs. Each entry represents the probability that the model\nin that column scores higher than the model in that row.\n16\n\fFigure 6.\nThe mean rating scores in subjective evaluation, along with the standard deviation (the error bars).\n\u2022 The human-composed progressions have the highest \u201cwin probabilities\u201d on average in all the three ranking criteria. It performs particularly well in Harmonicity.\n\u2022 In general, the deep learning methods have higher probabilities to win over the\nnon-deep learning methods in Harmonicity and Overall.\n\u2022 For Interestingness, GA performs the best among the five automatic methods,\nwhich we suspect stems from its entropy term (Eq. (6)).\n\u2022 Among the two deep learning methods, the MTHarmonizer consistently outperforms the BiLSTM in all ranking criteria, especially for Interestingness. We\n(subjectively) observe that MTHarmonizer indeed generates more diverse chord\nprogressions compared to the vanilla BiLSTM, perhaps due to the consideration\nof functions.\nThe results of the rating task shown in Figure 6, on the other hand, lead to the\nfollowing observations:\n\u2022 Congruent with the results of the ranking task, the MTHarmonzer model\nachieves the second best performance here, only losing out to the original humancomposed chord progressions. The MTHarmonzier consistently outperforms the\nother four automatic methods in all the four metrics. With a paired t-test, we\nfind that there is significant performance difference between the MTHarmonzer\nprogressions and the original human-composed progressions in terms of Coherence and Chord Progression (p-value<0.005), but no significant difference in\nterms of Interestingness and Overall.\n\u2022 Among the four metrics, the original human-composed progressions score higher\nin Coherence (3.81) and Overall (3.78), and the lowest in Interestingness (3.43).\nThis suggests that the way we simplify the data (e.g., using only root-positioned\ntriad chords) may have limited the perceptual qualities of the music, in particular\nits diversity.\n\u2022 Generally speaking, the results in Chord Progression (i.e., the coherence of the\nchord progression on its own) seems to correlate better with the results in Coherence (i.e., the coherence between the melody and chord sequences) than the\nInterestingness of the chord progression. This suggests that a chord progression\nrated as being interesting may not sound coherent.\n\u2022 Although the GA performs worse than the MTHarmonizer on all the four metrics, it actually performs fairly well in Interestingness (3.23), as we have observed\nfrom the ranking result. A paired t-test showed no significant performance difference between the GA generated progressions and original human-composed\nprogressions in Interestingness. A hybrid model that combines GA and deep\nlearning may be a promising direction for future research.\nFrom the rating and ranking tasks, we see that, in terms of harmonicity, automatic\n17\n\fMelody/chord harmonicity metrics\nCTnCTR\nPCS\nMCTD\nHuman-composed\n0.74\n1.42\n1.03\nTemplate matching\n0.91\n1.97\n0.83\nHMM (adapted from (Lim et al., 2017))\n0.89\n1.93\n0.85\nGA-based (adapted from (Kitahara et al., 2018))\n0.74\n0.43\n1.31\nBiLSTM (adapted from (Lim et al., 2017))\n0.87\n1.84\n0.91\nMTHarmonizer (proposed here)\n0.82\n1.77\n0.94\nChord progression metrics\nCHE\nCC\nCTD\nHuman-composed\n1.28\n2.62\n0.88\nTemplate matching\n1.01\n1.70\n0.65\nHMM (adapted from (Lim et al., 2017))\n0.88\n1.89\n0.56\nGA-based (adapted from (Kitahara et al., 2018))\n1.58\n2.47\n0.96\nBiLSTM (adapted from (Lim et al., 2017))\n1.07\n2.07\n0.71\nMTHarmonizer (proposed here)\n1.29\n2.31\n1.02\nTable 1.\nObjective evaluation scores for different melody harmonization models. The closer the values to that\nof the human-composed samples, the better the model is in modeling the training data. The bold values indicate\nthe closet value to that of the human-composed samples per metric. And, 1) higher values in CTnCTR and PCS\nand lower values in MCTD may suggest that the melody/chord harmonicity is high; 2) higher values in CHE\nand CC and lower values in CTD may suggest that the diversity (which can be related to the interestingness)\nof the chord progression is high. See Section 4 for the definitions of the metrics.\nmethods still fall behind the human composition. However, the results of the two deep\nlearning based methods are closer to that of the human-composed ones.\n5.2. Objective Evaluation\nThe results are displayed in Table 1. We discuss the result of the melody/chord harmonicity metrics first. We can see that the results for the two deep learning methods\nare in general closer to the results for the original human-composed progressions than\nthose of the three non-deep learning methods for all three harmonicity metrics, most\nsignificantly on the latter two. The template matching-based and HMM-based methods scores high in PCS and low in MCTD, indicating that the harmonization these two\nmethods generate may be too conservative. In contrast, the GA scores low in PCS and\nhigh in MCTD, indicating overly low harmonicity. These results are consistent with\nthe subjective evaluation, suggesting that these metrics can perhaps reflect human\nperception of the harmonicity between melody and chords.\nFrom the result of the chord progression metrics, we also see from CHE and CC that\nthe progressions generated by the template matching-based and HMM-based methods\nseem to lack diversity. In contrast, the output of GA features high diversity.\nAs the GA based method was rated lower than the template matching and HMM\nmethods in terms of the Overall criterion in our subjective evaluation, it seems that\nthe subjects care more about the harmonicity than the diversity of chord progressions.\nComparing the two deep learning methods, we see that the MTHarmonizer uses\nmore non-chord tones (smaller CTnCTR) and uses a greater number of unique chords\n18\n\f(larger CC) than the BiLSTM model. The CHE of the MTHarmonizer is very close\nto that of the original human-composed progressions.\nIn general, the results of the objective evaluation appear consistent with those of the\nsubjective evaluation. It is difficult to quantify which metrics are better for what purposes, and how useful and accurate these metrics are overall. Therefore, our suggestion\nis to use them mainly to gain practical insights into the results of automatic melody\nharmonization models, rather than to judge their quality. As pointed out by (Dong et\nal., 2018), objective metrics can be used to track the performance of models during\ndevelopment, before committing to running the user study. Yet, human evaluations\nare still needed to evaluate the quality of the generated music.\nFinally, although we have argued earlier that there is no ground truth in melody\nharmonization and that it is not adequate to rely solely on chord prediction error to\nevaluate the models, we find that the MTHarmonizer also achieves the lowest chord\nprediction error (i.e., a 48-class classification problem) and chord function prediction\nerror (a 3-class classification problem). On the test set, the chord prediction accuracy\nfor the five models (template matching, HMM, GA, BiLSTM, and MTHarmonizer) is\n29%, 31%, 20%, 35%, and 38%, respectively, while the accuracy for a random guess\nbaseline is only 2%. And, the chord function prediction accuracy is 62%, 61%, 55%,\n65%, 69%, respectively, while the accuracy for a random guess baseline is 51%.\n6. Discussions\nWe admit that the comparative study presented above has some limitations. First,\nbecause of the various preprocessing steps taken for data cleaning and for making\nthe melody harmonization task manageable (cf. Section 3), the \u201chuman-composed\u201d\nharmonizations are actually simplified versions of those found on TheoryTab. We considered triad chords only, and we did not consider performance-level attributes such\nas velocity and rhythmic pattern of chords. This limits the perceptual quality of the\nhuman-composed chord progression, and therefore also limits the results that can be\nachieved by automatic methods. The reduction from extended chords to triads reduces\nthe \u201ccolor\u201d of the chords and creates many innacurate chord repetitions in the dataset\n(e.g., both the alternated CMaj7 and C7 will be reduced to C triad chord). We believe\nit is important to properly inform the human subjects of such limitations as we did in\nthe instruction phase of our user study. We plan to compile other datasets from HLSD\nto extend the comparative study in the future.\nSecond, in our user study we asked human subjects to rank and rate the results\nof two randomly chosen methods in each of the three presented sets. After analyzing\nthe results, we found that the subject\u2019s ratings are in fact relative. For example, the\nMTHarmonizer\u2019s average score in Overall is 3.04 when presented alongside the humancomposed progressions, and 3.57 when confronted with the genetic algorithm-based\nmodel. We made sure in our user study that all the methods are equally likely to be\npresented together with every other method, so the average rating scores presented in\nFigure 6 do not favor a particular method. Still, caution is needed when interpreting\nthe rating scores. Humans may not have a clear idea of how to consistently assign a\nscore to a harmonization. While it is certainly easier to objectively compare multiple\nmethods with the provided rating scores, we still recommended asking human subjects\nto make pairwise rankings in order to make the result more reliable.\nThird, as the aim of this paper is to sample representative models from the literature, the current setting cannot decouple the effects of the model architectures (e.g.,\n19\n\fHMMs, GAs and BiLSTMs) and the music knowledge induced into the model (e.g.,\nthe concept of functional harmonic in MTHarmonizer). Moreover, for similar reasons,\nthe models we implemented in this paper do not include extensions that might lead\nto better performance. For example, we could further improve the HMM model by\nusing trigrams or extending the hidden layers as discussed in the literature (Paiement\net al., 2006; Temperley, 2009; Tsushima et al., 2017). It may also be possible to incorporate some of the proposed objective metrics (such as the chord tone to non-chord\ntone ratio) as additional loss terms. The aim of this paper is to observe how different\ncategories of models characterize the harmonization results rather than to explore the\nfull potentials of each presented model.\nReviewing the properties of harmonization algorithms which imitate styles in a\ndataset as in our research still holds its importance, although recent music generation research is shifting towards measuring how systems can generate content that\nextrapolates meaningfully from what the model have learned (Zacharakis, KaliakatsosPapakostas, Tsougras, & Cambouropoulos, 2018). Extrapolation could be based on the\nmodel which also achieves interpolation or maintaining particular styles among data\npoints. We believe we can further discuss extrapolation based on the understanding\nof how methods imitate data.\n7. Conclusion\nIn this paper, we have presented a comparative study implementing and evaluating a\nnumber of canonical methods and one new method for melody harmonization, including deep learning and non-deep learning based approaches. The evaluation has been\ndone using a lead sheet dataset we newly collected for training and evaluating melody\nharmonization. In addition to conducting a subjective evaluation, we employed in total six objective metrics with which to evaluate a chord progression given a melody.\nOur evaluation shows that deep learning models indeed perform better than non-deep\nlearning ones in a variety of aspects, including harmonicity and interestingness. Moreover, a deep learning model that takes the function of chords into account reaches the\nbest result among the evaluated models.\nFuture work can be directed toward at least the following three directions. First, it is\nimportant to extend the chord vocabulary to include more complicated chords. Second,\nas self-attention based neural sequence models such as the Transformers (Vaswani\net al., 2017) have been shown powerful alternatives to RNNs for various automatic\nmusic generation tasks (Y.-H. Chen, Huang, Hsiao, & Yang, 2020; Donahue, Mao, Li,\nCottrell, & McAuley, 2019; Y.-S. Huang & Yang, 2020; Ren et al., 2020), it might be\ninteresting to investigate Transformer-based models for melody harmonization. Finally,\nother than the melody harmonization task (i.e., generating chords given a melody)\naddressed in the paper, it would also be interesting to study chord-conditioned melody\ngeneration (i.e., generating a melody given chords) (Genchel, Pati, & Lerch, 2019; Trieu\n& Keller, 2018; Yang, Chou, & Yang, 2017), or simultaneously generating both melody\nand harmony from scratch (Jiang, Xia, Carlton, Anderson, & Miyakawa, 2020; Liu &\nYang, 2018; Wu & Yang, 2020).\nReferences\nAllan, M., & Williams, C. K. I. (2005). Harmonising chorales by probabilistic inference. In\n20\n\fProc. Advances in Neural Information Processing Systems.\nBriot, J.-P., Hadjeres, G., & Pachet, F. (2017). Deep learning techniques for music generation:\nA survey. arXiv preprint arXiv:1709.01620.\nChen, T.-P., & Su, L. (2018). Functional harmony recognition of symbolic music data with\nmulti-task recurrent neural networks. In Proc. Int. Soc. Music Information Retrieval Conf.\n(pp. 90\u201397).\nChen, Y.-H., Huang, Y.-S., Hsiao, W.-Y., & Yang, Y.-H. (2020). Automatic composition of\nguitar tabs by Transformers and groove modeling. In Proc. Int. Soc. Music Information\nRetrieval Conf.\nChuan, C.-H., & Chew, E. (2007). A hybrid system for automatic generation of style-specific\naccompaniment. In Proc. Int. Joint Workshop on Computational Creativity.\nde Clercq, T., & Temperley, D. (2011). A corpus analysis of rock harmony. Popular Music,\n30(1), 47\u201370.\nDe Haas, W. B., Magalh\u02dcaes, J. P., Wiering, F., & Veltkamp, R. C. (2014). Automatic functional\nharmonic analysis. Computer Music Journal, 37(4), 37\u201353.\nde Le\u00b4on, P. J. P., I\u02dcnesta, J. M., Calvo-Zaragoza, J., & Rizo, D. (2016). Data-based melody\ngeneration through multi-objective evolutionary computation. J. Mathematics and Music,\n10(2), 173-192.\nDonahue, C., Mao, H. H., Li, Y. E., Cottrell, G. W., & McAuley, J.\n(2019).\nLakhNES:\nImproving multi-instrumental music generation with cross-domain pre-training. In Proc.\nInt. Soc. Music Information Retrieval Conf. (pp. 685\u2013692).\nDong, H.-W., Hsiao, W.-Y., Yang, L.-C., & Yang, Y.-H. (2018). MuseGAN: Symbolic-domain\nmusic generation and accompaniment with multi-track sequential generative adversarial\nnetworks. In Proc. AAAI Conf. Artificial Intelligence.\nEbcio\u02c7glu, K. (1988). An expert system for harmonizing four-part chorales. Computer Music\nJournal, 12(3), 43\u201351.\nFern\u00b4andez, J. D., & Vico, F. (2013). AI methods in algorithmic composition: A comprehensive\nsurvey. J. Artificial Intelligence Research, 48(1), 513\u2013582.\nForney, G. D. (1973). The viterbi algorithm. Proceedings of the IEEE, 61, 268\u2013278.\nFujishima, T. (1999). Realtime chord recognition of musical sound: A system using common\nLisp. In Proc. Int. Computer Music Conf. (pp. 464\u2013467).\nGenchel, B., Pati, A., & Lerch, A. (2019). Explicitly conditioned melody generation: A case\nstudy with interdependent rnns. In Proc. Computer Simulation of Music Creativity Conf.\nHadjeres, G., & Pachet, F. (2017). DeepBach: a steerable model for Bach chorales generation.\nIn Proc. Int. Conf. Machine Learning.\nHarte, C., Sandler, M., & Gasser, M. (2006). Detecting harmonic change in musical audio. In\nProc. Int. Soc. Music Information Retrieval Conf.\nHinton, G., Deng, L., Yu, D., Dahl, G., Mohamed, A., Jaitly, N., . . . Kingsbury, B. (2012).\nDeep neural networks for acoustic modeling in speech recognition. IEEE Signal Processing\nMagazine, 29(6), 82-97.\nHochreiter, S., & Schmidhuber, J. (1997). Long short-term memory. Neural Computing, 9(8),\n1735\u20131780.\nHuang, C.-Z. A., Cooijmans, T., Roberts, A., Courville, A., & Eck, D. (2017). Counterpoint\nby convolution. In Proc. Int. Soc. Music Information Retrieval Conf. (pp. 211\u2013218).\nHuang, Y.-S., & Yang, Y.-H.\n(2020).\nPop Music Transformer: Beat-based modeling and\ngeneration of expressive Pop piano compositions. In Proc. ACM Multimedia.\nJacoby, N., Tishby, N., & Tymoczko, D. (2015). An information theoretic approach to chord\ncategorization and functional harmony. J. New Music Research, 44(3), 219\u2013244.\nJiang, J., Xia, G. G., Carlton, D. B., Anderson, C. N., & Miyakawa, R. H. (2020). Transformer\nVAE: A hierarchical model for structure-aware and interpretable music representation learning. In Proc. Int. Conf. Acoustics, Speech and Signal Processing (p. 516-520).\nKitahara, T., Giraldo, S., & Ramirez, R. (2018). JamSketch: Improvisation support system\nwith GA-based melody creation from user\u2019s drawing. In Proc. Int. Symp. Computer Music\nMultidisciplinary Research (pp. 509\u2013521).\n21\n\fLim, H., Rhyu, S., & Lee, K. (2017). Chord generation from symbolic melody using BLSTM\nnetworks. In Proc. Int. Soc. Music Information Retrieval Conf. (pp. 621\u2013627).\nLiu, H.-M., & Yang, Y.-H. (2018). Lead sheet generation and arrangement by conditional\ngenerative adversarial network. In Proc. IEEE Int. Conf. Machine Learning And Applications.\nMakris, D., Kayrdis, I., & Sioutas, S. (2016). Automatic melodic harmonization: An overview,\nchallenges and future directions. In Trends in Music Information Seeking, Behavior, and\nRetrieval for Creativity (pp. 146\u2013165). IGI Global.\nNobile, D. F. (2015). Counterpoint in rock music: Unpacking the \u201cmelodic-harmonic divorce\u201d.\nMusic Theory Spectrum, 37(2), 189\u2013203.\nPaiement, J.-F., Eck, D., & Bengio, S. (2006). Probabilistic melodic harmonization. In Proc.\nConf. Canadian Society for Computational Studies of Intelligence (pp. 218\u2013229).\nPhon-Amnuaisuk, S., & Wiggins, G. (1999). The four-part harmonisation problem: a comparison between genetic algorithms and a rule-based system. In Proc. AISB Symp. Musical\nCreativity.\nRaczy\u00b4nski, S., Fukayama, S., & Vincent, E. (2013). Melody harmonisation with interpolated\nprobabilistic models. J. New Music Research, 42, 223-235.\nRaphael, C., & Stoddard, J. (2004). Harmonic analysis with probabilistic graphical models.\nComputer Music Journal, 28(3), 45\u201352.\nRen, Y., He, J., Tan, X., Qin, T., Zhao, Z., & Liu, T.-Y.\n(2020).\nPopMAG: Pop music\naccompaniment generation. In Proc. ACM Int. Conf. Multimedia.\nRiemann, H. (1893). Vereinfachte harmonielehre, oder die lehre von den tonalen funktionen\nder akkorde. 1896. Tr. H. Bewerunge.\nRohrmeier, M., & Cross, I. (2008). Statistical properties of tonal harmony in bach\u2019s chorales.\nIn Proc. Int. Conf. Music Perception and Cognition (pp. 619\u2013627).\nSheh, A., & Ellis, D. P. (2003). Chord segmentation and recognition using EM-trained hidden\nMarkov models. In Proc. Int. Soc. Music Information Retrieval Conf. (pp. 185\u2013191).\nSimon, I., Morris, D., & Basu, S. (2008). MySong: Automatic accompaniment generation for\nvocal melodies. In Proc. SIGCHI Conf. Human Factors in Computing Systems (p. 725-734).\nSrivastava, N., Hinton, G., Krizhevsky, A., Sutskever, I., & Salakhutdinov, R. (2014). Dropout:\nA simple way to prevent neural networks from overfitting. J. Machine Learning Research,\n15(1), 1929\u20131958.\nTemperley, D. (2007). The melodic-harmonic \u2018divorce\u2019 in rock. Popular Music, 26(2), 323\u2013342.\nTemperley, D. (2009). A unified probabilistic model for polyphonic music analysis. J. New\nMusic Research, 38(1), 3\u201318.\nTrieu, N., & Keller, R. M. (2018). JazzGAN: Improvising with generative adversarial networks.\nIn Proc. Int. Workshop on Musical Metacreation.\nTsushima, H., Nakamura, E., Itoyama, K., & Yoshii, K. (2017). Function- and rhythm-aware\nmelody harmonization based on tree-structured parsing and split-merge sampling of chord\nsequences. In Proc. Int. Soc. Music Information Retrieval Conf.\nTsushima, H., Nakamura, E., Itoyama, K., & Yoshii, K. (2018). Generative statistical models\nwith self-emergent grammar of chord sequences. J. New Music Research, 47(3), 226\u2013248.\nVaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., . . . Polosukhin,\nI. (2017). Attention is all you need. In Proc. Advances in Neural Information Processing\nSystems (pp. 5998\u20136008).\nWu, S.-L., & Yang, Y.-H. (2020). The Jazz Transformer on the front line: Exploring the\nshortcomings of ai-composed music through quantitative measures. In Proc. Int. Soc. Music\nInformation Retrieval Conf.\nYang, L.-C., Chou, S.-Y., & Yang, Y.-H. (2017). MidiNet: A convolutional generative adversarial network for symbolic-domain music generation. In Proc. Int. Soc. Music Information\nRetrieval Conf.\nZacharakis, A., Kaliakatsos-Papakostas, M., Tsougras, C., & Cambouropoulos, E.\n(2018).\nMusical blending and creativity: An empirical evaluation of the CHAMELEON melodic\nharmonisation assistant. Musicae Scientiae, 11(1), 119-144.\n22\n\f", "text_mmd": "# Automatic Melody Harmonization with Triad Chords:\n\nA Comparative Study\n\nYin-Cheng Yeh, Wen-Yi Hsiao, Satoru Fukayama, Tetsuro Kitahara, Benjamin Genchel, Hao-Min Liu, Hao-Wen Dong, Yian Chen, Terence Leong, and Yi-Hsuan Yang\n\n###### Abstract\n\nSeveral prior works have proposed various methods for the task of automatic melody harmonization, in which a model aims to generate a sequence of chords to serve as the harmonic accompaniment of a given multiple-bar melody sequence. In this paper, we present a comparative study evaluating and comparing the performance of a set of canonical approaches to this task, including a template matching based model, a hidden Markov based model, a genetic algorithm based model, and two deep learning based models. The evaluation is conducted on a dataset of 9,226 melody/chord pairs we newly collect for this study, considering up to 48 triad chords, using a standardized training/test split. We report the result of an objective evaluation using six different metrics and a subjective study with 202 participants.\n\nS +\nFootnote \u2020: Yeh, Hsiao, Liu, Dong and Yang are with Academia Sinica, Taiwan ({ycyeb, wayne391, paul115236, salu133445, yang}@citi.sinica.edu.tw); Fukayama is with National Institute of Advanced Industrial Science and Technology, Japan (satoru s.fukayama@aist.go.jp); Kitahara is with Nihon University, Japan (kitahara@chs.nihon-u.ac.jp); Genchel is with Georgia Institute of Technology, USA (ben-jigenchel@gmail.com); Chen and Leong are with KKBOX Inc., Taiwan (annchen@kkbox.com, terenceleong@kkboxgroup.com)\n\nSymbolic music generation; automatic melody harmonization; functional harmony\n\n## 1 Introduction\n\nAutomatic melody harmonization, a sub-task of automatic music generation (Fernandez and Vico, 2013), refers to the task of creating computational models that can generate a harmonic accompaniment for a given melody (Chuan and Chew, 2007; Simon et al., 2008). Here, the term harmony, or harmonization, is used to refer to chordal accompaniment, where an accompaniment is defined relative to the melody as the supporting section of the music. Figure 1 illustrates the inputs and outputs for a melody harmonization model.\n\nMelody harmonization is a challenging task as there are multiple ways to harmonize the same melody; what makes a particular harmonization pleasant is subjective, and often dependent on musical genre and other contextual factors. Tonal music, which encompasses most of Western music, defines specific motivic relations between chords based on scales such as those defined in functional harmony (Riemann, 1893). While these relations still stand and are taught today, their application towards creatingpleasant music often depends on subtleties, long term dependencies and cultural contexts which may be readily accessible to a human composer, but very difficult to learn and detect for a machine. While a particular harmonization may be deemed technically correct in some cases, it can also be seen as uninteresting in a modern context.\n\nThere have been several efforts made towards this task in the past (Makris, Kayrdis, & Sioutas, 2016). Before the rise of deep learning, the most actively employed approach is based on hidden Markov models (HMMs). For example, Paiement, Eck, and Bengio (2006) proposed a tree-structured HMM that allows for learning the non-local dependencies of chords, and encoded probabilities for chord substitution taken from psycho-acoustics. They additionally presented a novel representation for chords that encodes relative scale degrees rather than absolute note values, and included a subgraph in their model specifically for processing it. Tsushima, Nakamura, Itoyama, and Yoshii (2017) similarly presented a hierarchical tree-structured model combining probabilistic context-free grammars (PCFG) for chord symbols and HMMs for chord rhythms. Temperley (2009) presented a statistical model that would generate and analyze music along three sub-structures: metrical structure, harmonic structure, and stream structure. In the generative portion of this model, a metrical structure defining the emphasis of beats and sub-beats is first generated, and then harmonic structure and progression are generated conditioned on that metrical structure.\n\nThere are several previous works which attempt to formally and probabilistically analyze tonal harmony and harmonic structure. For example, Rohrmeier and Cross (2008) applied a number of statistical techniques to harmony in Bach chorales in order to uncover a proposed underlying harmonic syntax that naturally produces common perceptual and music theoretic patterns including functional harmony. Jacoby, Tishby, and Tymoczko (2015) attempted to categorize common harmonic symbols (scale degrees, roman numerals, or sets of simultaneous notes) into higher level functional\n\nFigure 1: Diagram of the slightly modified version of the bidirectional long short-term memory network (BiLSTM) based model (Lim et al., 2017) for melody harmonization. The input to the model is a melody sequence. With two layers of BiLSTM and one fully-connected (FC) layer, the model generates as output a sequence of chord labels (e.g., Cm or B chords), one for each half bar. See Section 2.4 for details.\n\ngroups, seeking underlying patterns that produce and generalize functional harmony. Tsushima, Nakamura, Itoyama, and Yoshii (2018) used unsupervised learning in training generative HMM and PCFG models for harmonization, showing that the patterns learned by these models match the categorizations presented by functional harmony.\n\nMore lately, people have begun to explore the use of deep learning for a variety of music generation tasks (Briot, Hadjeres, & Pachet, 2017). For melody harmonization, Lim et al. (2017) proposed a model that employed two bidirectional long short-term memory (BiLSTM) recurrent layers (Hochreiter & Schmidhuber, 1997) and one fully-connected layer to learn the correspondence between pairs of melody and chord sequences. The model architecture is depicted in Figure 1. According to the experiments reported in (Lim et al., 2017), this model outperforms a simple HMM model and a more complicated DNN-HMM model (Hinton et al., 2012) for melody harmonization with major and minor triad chords.\n\nMoreover, melody harmonization is also relevant to four-part chorale harmonization (Allan & Williams, 2005; Ebcioglu, 1988; Hadjeres & Pachet, 2017; C.-Z. A. Huang, Cooijmans, Roberts, Courville, & Eck, 2017) and accompaniment generation (Chuan & Chew, 2007; Dong, Hsiao, Yang, & Yang, 2018; Simon et al., 2008). Although these three tasks share the same input, monophonic melodies, they have distinct outputs--lead sheets, four-part chorales and full arrangements, respectively. Another relevant topic is harmonic analysis (T.-P. Chen & Su, 2018; De Haas, Magalhaes, Wiering, & Veltkamp, 2014; Harte, Sandler, & Gasser, 2006; Raphael & Stoddard, 2004; Temperley, 2009). Despite having similar input and output spaces, melody harmonization is fundamentally different from harmonic analysis. On one hand, harmonic analysis takes polyphonic music as inputs, while melody harmonization takes monophonic melodies as inputs and is considered more difficult as less harmonic information is given. On the other hand, there is in general a correct answer for harmonic analysis, while there are no strict answers for melody harmonization.\n\nWe note that, while many new models are being proposed for melody harmonization, at present there is no comparative study evaluating a wide array of different approaches for this task, using the same training set and test set. Comparing models trained on different training sets is problematic as it is hard to have a standardized definition of improvement and quality. Moreover, as there is to date no standardized test set for this task, it is hard to make consistent comparison between different models.\n\nIn this paper, we aim to bridge this gap with the following three contributions:\n\n1. We implement in total five melody harmonization models that span a number of canonical approaches to the task, including template matching, hidden Markov model (HMM) (Simon et al., 2008), genetic algorithm (GA) (Kitahara, Giraldo, & Ramirez, 2018), and two variants of deep recurrent neural network (RNN) models (Lim et al., 2017). We then present a comparative study comparing the performance of these models. To our best knowledge, a comparative study that considers such a diverse set of approaches for melody harmonization using a standardized dataset has not been attempted before.\n\nAs we follow fairly faithfully the implementation proposed in the original publications, these models differ in terms of not only the model architectures but also the employed features. Therefore, we have to admit that our study cannot decouple the effects of the model architectures and the features. Yet, we note that the comparison of the first four models is an architecture-vs-architecture comparison, while the comparison of the two RNN models is a feature-vs-feature comparison.\n\n2. We compile a new dataset, called the Hooktheory Pianoroll Triad Dataset (HTPD3), to evaluate the implemented models over well-annotated lead sheet samples of music. A lead sheet is a form of musical notation that specifies the essential elements of a song--the melody, harmony, and where present, lyrics (Liu Yang, 2018). HTPD3 provides melody lines and accompanying chords specifying both chord symbol and harmonic function useful for our study. We consider 48 triad chords in this study, including major, minor, diminished, and augmented triad chords. We use the same training split of HTPD3 to train the implemented models and evaluate them on the same test split.\n3. We employ six objective metrics for evaluating the performance of melody harmonization models. These metrics consider either the distribution of chord labels in a chord sequence, or how the generated chord sequence fits with the given melody. In addition, we conduct an online user study and collect the feedback from 202 participants around the world to assess the quality of the generated chordal accompaniment.\n\nWe discuss the findings of comparative study, hoping to gain insights into the strength and weakness of the evaluated methods. Moreover, we show that incorporating the idea of functional harmony (T.-P. Chen and Su, 2018) while harmonizing melodies greatly improves the result of the model presented by (Lim et al., 2017).\n\nIn what follows, we present in Section 2 the models we consider and evaluate in this comparative study. Section 3 provides the details of the HTPD3 dataset we build for this study, and Section 4 the objective metrics we consider. Section 5 presents the setup and result of the study. We discuss the findings and limtiations of this study in Section 6, and then conclude the paper in Section 7.\n\n## 2 Automatic Melody Harmonization Models\n\nA melody harmonization model takes a melody sequence of \\(T\\) bars as input and generates a corresponding chord sequence as output. _Chord Sequence_ is defined here as a series of chord labels \\(Y=y_{1},y_{2},\\ldots,y_{M}\\), where \\(M\\) denotes the length of the sequence. In this work, each model predicts a chord label for every half bar, i.e. \\(M=2T\\). Each label \\(y_{j}\\) is chosen from a finite chord vocabulary \\(\\mathcal{C}\\). To reduce the complexity of this task, we consider here only the triad chords, i.e., chords composed of three notes. Specifically, we consider major, minor, diminished, and augmented triad chords, all in root position. We also consider _No Chord_ (N.C.), or rest, so the size of the chord vocabulary is \\(|\\mathcal{C}|=49\\). _Melody Sequence_ is a time-series of monophonic musical notes in MIDI format. We compute a sequence of features as \\(X=\\mathbf{x}_{1},\\mathbf{x}_{2},\\ldots,\\mathbf{x}_{N}\\) to represent the melody and use them as the inputs to our models. Unless otherwise specified, we set \\(N=M\\), computing a feature vector for each half bar.\n\nGiven a set of melody and corresponding chord sequences, a melody harmonization model \\(f(\\cdot)\\) can be trained by minimizing the loss computed between the ground truth \\(Y_{*}\\) and the model output \\(\\hat{Y}_{*}=f(X_{*})\\), where \\(X_{*}\\) is the input melody.\n\nWe consider three non-deep learning based and two deep learning based models in this study. While the majority are adaptation of existing methods, one (deep learning based) is a novel method which we introduce in this paper (see Section 2.5). All models are carefully implemented and trained using the training split of HTPD3. We present the technical details of these models below.\n\n### Template Matching-based Model\n\nThis model is based on an early work on audio-based chord recognition (Fujishima, 1999). The model segments training melodies into half-bars, and constructs a _pitch profile_ for each segment. The chord label for a new segment is then selected based on the label for the training segment whose pitch profile it most closely matches. When there is more than one possible chord template that has the highest matching score, we choose a chord randomly based on uniform distribution among the possibilities. We refer to this model as _template matching-based_ as the underlying method compares the profile of a given melody segment with those of the _template_ chords.\n\nWe use Fujishima's _pitch class profile_ (PCP) (Fujishima, 1999) as the pitch profile representing respectively the melody and chord for each half-bar. A PCP is a 12-dimensional feature vector \\(\\mathbf{x}\\in[0,1]^{12}\\) where each element corresponds to the activity of a pitch class. The PCP for each of the \\(|\\mathcal{C}|\\) chord labels is constructed by setting the elements corresponding to the pitch classes that are part of the chord to one, and all the others to zero. Because we consider only triad chords in this work, there will be exactly three one's in the PCP of a chord label for each half bar. The PCP for melody is constructed similarly, but additionally considering the duration of notes. Specifically, the activity of the \\(k\\)-th pitch class, i.e., \\(x_{k}\\in[0,1]\\), is set by the ratio of time the pitch class is active during the corresponding half bar.\n\nThe result of this model are more conservative by design, featuring intensive use of chord tones. And, this model sets the chord label independently for each half bar, without considering the neighboring chord labels, or the chord progression over time.\n\nWe note that, to remove the effect of the input representations on the harmonization result, we use PCP as the model input representation for all the other models we implement for melody harmonizationm.\n\n### HMM-based Model\n\nHMM is a probabilistic framework for modeling sequences with latent or hidden variables. Our HMM-based harmonization model regards chord labels as latent variables and estimates the most likely chord sequence for a given set of melody notes. Unlike the template matching-based model, this model considers the relationship between neighboring chord labels. HMM-based models similar to this one were widely used in chord generation and melody harmonization research before the current era of deep learning (Raczynski, Fukayama, & Vincent, 2013; Simon et al., 2008).\n\nWe adopt a simple HMM architecture employed in (Lim et al., 2017). This model makes the following assumptions:\n\n1. The observed melody sequence \\(X=\\mathbf{x}_{1},\\ldots,\\mathbf{x}_{M}\\) is statistically biased due to the hidden chord sequence \\(Y=y_{1},\\ldots,y_{M}\\), which is to be estimated.\n2. \\(\\mathbf{x}_{m}\\) depends on only \\(y_{m}\\), \\(\\forall m\\in[1,M]\\).\n3. \\(y_{m}\\) depends on only \\(y_{m-1}\\), \\(\\forall m\\in[2,M]\\).\n\nThe task is to estimate the most likely hidden sequence \\(\\hat{Y}=\\hat{y}_{1},\\ldots,\\hat{y}_{M}\\) given \\(X\\). This amounts to maximizing the posterior probability:\n\n\\[\\hat{Y} = \\arg\\max_{Y}P(Y|X)\\ =\\ \\arg\\max_{Y}P(X|Y)P(Y) \\tag{1}\\] \\[= \\arg\\max_{Y}\\prod_{m=1}^{M}P(\\mathbf{x}_{m}|y_{m})P(y_{m}|y_{m-1 }),\\]where \\(P(y_{1}|y_{0})\\) is equal to \\(P(y_{1})\\). The term \\(P(\\mathbf{x}_{m}|y_{m})\\) is also called the emission probability, and the term \\(P(y_{m}|y_{m-1})\\) is called the transition probability. This optimization problem can be solved by the Viterbi algorithm (Forney, 1973).\n\nDeparting from the HMM in (Lim et al., 2017), our implementation uses the PCPs described in Section 2.1 to represent melody notes, i.e., to compute \\(\\mathbf{x}_{m}\\). Accordingly, we use multivariate Gaussian distributions to model the emission probabilities, as demonstrated by Fujishima (Sheh & Ellis, 2003). For each chord label, we set the covariance matrix of the corresponding Gaussian distribution to be a diagonal matrix, and calculate the mean and variance for each dimension from the PCP features of melody segments that are associated with that chord label in the training set.\n\nTo calculate the transition probabilities, we count the number of transitions between successive chord labels (i.e., bi-grams), then normalize those counts to sum to one for each preceding chord label. A uniform distribution is used when there is no bi-gram count for the preceding chord label. To avoid zero probabilities, we smooth the distribution by interpolating \\(P(y_{m}|y_{m-1})\\) with the prior probability \\(P(y_{m})\\) as follows,\n\n\\[P^{\\prime}(y_{m}|y_{m-1})=(1-\\beta)P(y_{m})+\\beta P(y_{m}|y_{m-1})\\,, \\tag{2}\\]\n\nyielding the revised transition probability \\(P^{\\prime}(y_{m}|y_{m-1})\\). The hyperparameter \\(\\beta\\) is empirically set to 0.08 via experiments on a random 10% subset of the training set.\n\n### Genetic Algorithm (GA)-based Model\n\nA GA is a flexible algorithm that generally maximizes an objective function or _fitness function_. GAs have been used for melody generation and harmonization in the past (de Leon, Inesta, Calvo-Zaragoza, & Rizo, 2016; Phon-Amnuaisuk & Wiggins, 1999), justifying their inclusion in this study. A GA can be used in both rule-based and probabilistic approaches. In the former case, we need to design a rule set of what conditions must be satisfied for musically acceptable melodies or harmonies--the fitness function is formulated based on this rule set. In the latter, the fitness function is formulated based on statistics of a data set.\n\nHere, we design a GA-based melody harmonization model by adapting the GA-based melody generation model proposed by (Kitahara et al., 2018). Unlike the other implemented models, the GA-based model takes as input a computed feature vector for every 16-th note (i.e., 1/4 beats). Thus, the melody representation has a temporal resolution 8 times that of the chord progression (i.e., \\(N=8M\\)). This means that \\(\\mathbf{x}_{8m}\\) and \\(y_{m}\\) point to the same temporal position.\n\nOur model uses a probabilistic approach, determining a fitness function based on the following elements. First, the (logarithmic) conditional probability of the chord progression given the melody is represented as:\n\n\\[F_{1}(X,Y)=\\sum_{n=1}^{N}\\log P(y_{\\lceil n/8\\rceil}|\\mathbf{x}_{n}), \\tag{3}\\]\n\nwhere \\(\\lceil\\ \\ \\rceil\\) is the ceiling function. The chord transition probability is computed as:\n\n\\[F_{2}(Y)=\\sum_{m=3}^{M}\\log P(y_{m}|y_{m-2},y_{m-1})\\,. \\tag{4}\\]The conditional probability of each chord given its temporal position is defined as:\n\n\\[F_{3}(Y)=\\sum_{m=1}^{M}\\log P(y_{m}|\\text{Pos}_{m})\\,, \\tag{5}\\]\n\nwhere \\(\\text{Pos}_{m}\\) is the temporal position of the chord \\(y_{m}\\). For simplicity, we defined \\(\\text{Pos}_{m}=\\text{mod}(m,8)\\), where mod is the modulo function. With this term, the model may learn that the tonic chord tends to appear at the first half of the first bar, while the dominant (\\(V\\)) chord tends to occur at the second half of the second bar.\n\nFinally, we use the entropy to evaluate a chord sequence's complexity, which should not be too low as to avoid monotonous chord sequences. The entropy is defined as \\(E(Y)=-\\sum_{c_{i}\\in\\mathcal{C}}P(Y=c_{i})\\log P(Y=c_{i})\\). In the fitness function, we evaluate how likely this entropy \\(E(Y)\\) is in a given data set.\n\n\\[F_{4}(Y)=\\log P(E=E(Y))\\,, \\tag{6}\\]\n\nwhere \\(E\\) is the random variable of the entropy of chord progressions and is discritized by \\(0.25\\). Its probability distribution is obtained from the training data.\n\nThe fitness function \\(F(Y)\\) is calculated as:\n\n\\[F(Y)=w_{1}F_{1}(X,Y)+w_{2}F_{2}(Y)+w_{3}F_{3}(Y)+w_{4}F_{4}(Y)\\,. \\tag{7}\\]\n\nWe simply set all the weights \\(w_{1},w_{2},w_{3},w_{4}\\) to \\(1.0\\) here.\n\n### Deep BiLSTM-based Model\n\nThis first deep learning model is adapted from the one proposed by (Lim et al., 2017), which uses BiLSTM layers. This model extracts contextual information from the melody sequentially from both the positive and negative time directions. The original model makes chord prediction for every bar, using a vocabulary of only the major and minor triad chords (i.e., \\(|\\mathcal{C}|=24\\)). We slightly extend this model such that the harmonic rhythm is a half bar, and the output chord vocabulary includes diminished and augmented chords, and the N.C. symbol (i.e., \\(|\\mathcal{C}|=49\\)).\n\nAs shown in Figure 1, this model has two BiLSTM layers, followed by a fully-connected layer. Dropout (Srivastava, Hinton, Krizhevsky, Sutskever, & Salakhutdinov, 2014) is applied with probability \\(0.2\\) at the output layer. This dropout rate, as well as the number of hidden layers and hidden units, are empirically chosen by maximizing the chord prediction accuracy on a random held-out subset of the training set. We train the model using minibatch gradient descent with categorical cross entropy as the the cost function. We use Adam as the optimizer and regularize by early stopping at the 10-th epoch to prevent over-fitting.\n\n### Deep Multitask Model: MTHarmorizer\n\nFrom our empirical observation on the samples generated by the aforementioned BiLSTM model, we find that the model has two main defects for longer phrases:\n\n1. **overuse of common chords**--common chords like C, F, and G major are repeated and overused, making the chord progression monotonous.\n\n2. **incorrect phrasing**--non-congruent phrasing between the melody and chords similarly results from the frequent occurrence of common chords. The resulting frequent occurrence of progressions like F\\(\\rightarrow\\)C or G\\(\\rightarrow\\)C in generated sequences implies a musical cadence in an unfit location, potentially bringing an unnecessary sense of ending in the middle of a chord sequence.\n\nWe propose an extension of the BiLSTM model to address these two defects. The core idea is to train the model to predict not only the chord labels but also the _chord functions_ (T.-P. Chen & Su, 2018), as illustrated in Figure 2. We call the resulting model a deep multitask model, or _MTHarmonizer_, since it deals with two tasks at the same time. We note that the use of the chord functions for melody harmonization has been found useful by Tsushima et al. (2018), using an HMM-based model.\n\nFunctional harmony elaborates the relationship between chords and scales, and describes how harmonic motion guides musical perception and emotion (T.-P. Chen & Su, 2018). While a chord progression consisting of randomly selected chords generally feels aimless, chord progressions which follow the rules of functional harmony establish or contradict a tonality. Music theorists annotate each scale degree into functions, such as tonic and dominant, based on the association between chord and degree in a particular scale. These functions explain the role a given scale degree, and its associated chord relative to the scale, plays in musical phrasing and composition. Specifically, we consider the following functions:\n\n* The _tonic_ function serves to stabilize and reinforce the tonal center.\n* The _dominant_ function provides a strong sense of motion back to tonal center. For example, a progression that moves from a dominant function scale degree chord to a tonal scale degree chord first creates tension, then resolves it.\n* The _others_ that encompasses all the other chords that are neither tonic nor dominant, such as the subdominant chords.\n\nAs will be introduced in Section 3, all the pieces in HTPD3 are in either C Major or c minor. Therefore, all chords share the same tonal center. We can directly map the chords into 'tonic,' 'dominant,' and 'others' functional groups, by name, without worrying about their relative functions in other keys, for other tonal centers. Specifically, we consider C, Am, Cm, A as _tonic_ chords, and G and B diminished as _dominant_ chords. The other chords all fall into the _others_ category.\n\nWe identify two potential benefits of adding chord functions to the target output. First, in contrast to the distribution of chord labels, the distribution of chord functions is relatively balanced, making it easier for the model to learn the chord functions. Second, as the chord functions and chord labels are interdependent, adding the chord functions as a target informs the model which chord labels share the same function and may therefore be interchangeable. We hypothesize that this multi-task learning will help our model learn proper functional progression, which in turn will produce better harmonic phrasing relative to the melody. Specifically, the loss function is defined as:\n\n\\[L_{*} = L_{\\text{chord}}+\\gamma L_{\\text{function}} \\tag{8}\\] \\[= H(\\hat{Y}_{\\text{chord}},Y_{\\text{chord}})+\\gamma H(\\hat{Y}_{ \\text{function}},Y_{\\text{function}})\\] \\[= H(f(X),Y_{\\text{chord}})+\\gamma H(g(X),Y_{\\text{function}})\\,,\\]\n\nwhere \\(H(\\cdot)\\) denotes the categorical cross entropy function, \\(f(\\cdot)\\) the chord label prediction branch, and \\(g(\\cdot)\\) the chord function prediction branch. When \\(\\gamma=0\\), the model reduces to the uni-task model proposed by Lim et al. (2017), and we can simply write \\(Y_{\\rm chord}\\) as \\(Y\\). In our work, we set \\(\\gamma=1.5\\) to ensure the loss value from \\(L_{\\rm chord}\\) and \\(L_{\\rm function}\\) are equally scaled. The two branches \\(f\\) and \\(g\\) share the two BiLSTM layers but not the fully-connected layer. Empirically, we found that if \\(\\gamma\\) is too small, the model will tend to harmonize the melody with the chords with tonic and dominant functions; the resulting chord sequences would therefore lack diversity.\n\nThe outputs of \\(f\\) and \\(g\\) are likelihood values for each chord label and chord function given an input melody. As Figure 2 shows, in predicting the final chord sequence, we rely on a weighted combination of the outputs of \\(f\\) and \\(g\\) in the following way:\n\n\\[\\hat{Y}=\\operatorname*{arg\\,max}_{\\hat{y}_{1},\\hat{y}_{2},\\ldots,\\hat{y}_{M}} \\prod_{m=1}^{M}\\left(P(\\hat{y}_{m}=f(\\mathbf{x}_{m}))*\\alpha_{m}P(\\hat{y}_{m}=h (g(\\mathbf{x}_{m})))\\right), \\tag{9}\\]\n\nwhere \\(h(\\cdot)\\) is simply a look-up table that maps the three chord functions to the \\(|\\mathcal{C}|\\) chord labels, and \\(\\alpha_{m}\\) is a pre-defined hyperparameter that allows us to boost the importance of correctly predicting the chord function over that of correctly predicting the chord label, for each chord. In our implementation, we set \\(\\alpha_{m}=1.0\\) for the tonic and dominant chords, and \\(\\alpha_{m}=1.8\\) for the other chords, to encourage the model to select chord labels that have lower likelihood, i.e., to use the \"others\" chords. This would more likely affect the middle part of a chord sequence, because this is where the likelihood to observe a chord from the three functions to be likely similar, so applying different \\(\\alpha_{m}\\) makes a difference. In contrast, in the beginning or the end of a phrase, the likelihood of observing the \"others\" chords would tend to be low anyway, even after we boost it with \\(\\alpha_{m}\\). As we will mainly add diversity to the middle part of a chord sequence, we would not compromise the overall chord progression and phrasing.\n\nFigure 2: Diagram of the proposed MTHarmonizer, a deep multitask model extended from the model (Lim et al., 2017) depicted in Figure 1. See Section 2.5 for details.\n\n## 3 Proposed Dataset\n\nFor the purpose of this study, we firstly collect a new dataset called the Hooktheory Lead Sheet Dataset (HLSD), which consists of lead sheet samples scraped from the online music theory forum called TheoryTab, hosted by Hooktheory ([https://www.hooktheory.com/theorytab](https://www.hooktheory.com/theorytab)), a company that produces pedagogical music software and books. The majority of lead sheet samples found on TheoryTab are user-contributed.1 Each piece contains high-quality, human-transcribed melodies alongside their corresponding chord progressions, which are specified by both literal chord symbols (e.g., Gmaj7), and chord functions (e.g., VI7) relative to the provided key.Chord symbols specify inversion if applicable, and the full set of chord extensions (e.g., #9, b11). The metric timing/placement of the chords is also provided. Due to copyright concerns, TheoryTab prohibits uploading full length songs. Instead, users upload snippets of a song (here referred to as lead sheet samples), which they voluntarily annotate with structural labels (e.g. \"Intro,\" \"Verse,\" and \"Chorus\") and genre labels. A music piece can be associated with multiple genres.\n\nFootnote 1: We note that we do not own the copyrights of the lead sheets so we cannot further redistribute them. We collected the lead sheets only for academic research.\n\nAs the samples in this dataset are segments of pop songs, e.g., a verse or a chorus, temporary changes of the tonal center should be rare.\n\nWe note that HLSD contains music of various genres, and only a few of them are classical music.2 As discussed in (de Clercq & Temperley, 2011), the rules of classical harmony are much less often followed in pop music. In addition, melodies in pop/rock music are more independent of the harmony than the case in classical music (Nobile, 2015; Temperley, 2007). It therefore remains to be studied whether the consideration of functional harmony improves our task here.\n\nFootnote 2: Here is a random sample of 10 songs from the dataset: _Love Grows Where My Rosemary Goes_ by Edison Lighthouse (1972), _La Bamba_ by Ritchie Valen (1987), _Palm Tree Paradise-Wario Land 4_ by Ryoji Yoshitomi (2001), _Forever and Always_ by Taylor Swift (2008), _Trails of the Past_ by Sbtrkt (2011), _I\u2019ve Run Away to Join the Fairies_ by Magnetic Fields (2012), _Semi Automatic_ by Twenty One Pilots (2013), _Adventure of A Lifetime_ by Coldplay (2015), _Same Drugs_ by Chance the Rapper (2016), _Feel Good-Brooks Remix_ by Gryffin And Illenium (2017).\n\nHLSD contains 11,329 lead sheets samples, all in 4/4 time signature. It contains up to 704 different chord classes, which is deemed too many for the current study. We therefore take the following steps to process and simplify HLSD, resulting in the final HTPD3 dataset employed in the performance study.\n\n* We remove lead sheet samples that do not contain a sufficient number of notes. Specifically, we remove samples whose melodies comprise of more than 40% rests (relative to their lengths). One can think of this as correcting class imbalance, another common issue for machine learning models--if the model sees too much of a single event, it may overfit and only produce or classify that event.\n* We then filter out lead sheets that are less than 4 bars and longer than 32 bars, so that \\(4\\leq T\\leq 32\\). This is done because 4 bars is commonly seen as the minimum length for a complete musical phrase in 4/4 time signature. At the other end, 32 bars is a common length for a full lead sheet, one that is relatively long. Hence, as the majority of our dataset consists of mere song sections, we are inclined for not including samples longer than 32 bars.\n* The HLSD provides the key signatures of every samples. We transpose every samples to either C major or c minor based on the provided key signatures.\n* In general, a chord label can be specified by the pitch class of its root note (among12 possible pitch classes, i.e., C, C#,..., B, in a chromatic scale), and its chord quality, such as 'triad','sixths','sevenths', and'suspended.' HLSD contains 704 possible chord labels, including inversions. However, the distribution of these labels is highly skewed. In order to even out the distribution and simplify our task, we reduce the chord vocabulary by converting each label to its root position triad form, i.e., the major, minor, diminished, and augmented chords without 7ths or additional extensions. Suspended chords are mapped to the major and minor chords. As a result, only 48 chord labels (i.e., 12 root notes by 4 qualities) and N.C. are considered (i.e., \\(|\\mathcal{C}|=49\\)).\n* We standardize the dataset so that a chord change can occur only every bar or every half bar.\n\nWe do admit that this simplification can decrease the chord color and reduce the intensity of tension/release patterns, and can sometimes convert a vibrant, subtle progression into a monotonous one (e.g., because both CMaj7 and C7 are mapped to C chord). We plan to make full use of the original chord vocabulary in future works.\n\nHaving pre-defined train and test splits helps to facilitate the use of HTTPD3 for evaluating new models of melody harmonization via the standardization of training procedure. As HTTPD3 includes paired melody and chord sequences, it can also be used to evaluate models for chord-conditioned melody generation as well. With these use cases in mind, we split the dataset so that the **training set** contains 80% of the pieces, and the **test set** contains 10% of the pieces. There are in total 923 lead sheet samples in the test set. The remaining 10% is reserved for future use. When splitting, we imposed the additional requirement that lead sheet samples from the same song are in the same subset.\n\n## 4 Proposed Objective Metrics\n\nTo our knowledge, there are at present no standardized, objective evaluation metrics for the melody harmonization task. The only objective metric adopted by (Lim et al., 2017), in evaluating the models they built is a categorical cross entropy-based chord prediction error, representing the discrepancy between the ground truth chords \\(Y_{*}\\) and predicted chords \\(\\hat{Y}_{*}=f(X_{*})\\). The chord prediction error is calculated for each half bar individually and then got averaged, not considering the chord sequence as a whole. In addition, it does not directly measure how the generated chord sequence fits with the given melody. What's more, when calculating the chord prediction error, the underlying assumption is that the \"ground truth\" chord sequence \\(Y_{*}\\) is the _only_ feasible one to harmonize the given melody \\(X_{*}\\). This is not true in general.\n\nFor the comparative study, we introduce here a set of six objective metrics defined below. These metrics are split into two categories, namely three chord progression metrics and three chord/melody harmonicity metrics. Please note that we do not evaluate the melody itself, as the melody is provided by the ground truth data.\n\n_Chord progression metrics_ evaluate each chord sequence as a whole, independent from the melody, and relate to the distribution of chord labels in a sequence.\n\n* **Chord histogram entropy** (CHE): Given a chord sequence, we create a histogram of chord occurrences with \\(|\\mathcal{C}|\\) bins. Then, we normalize the counts to sum to 1, and calculate its entropy: \\[H=-\\sum_{i=1}^{|\\mathcal{C}|}p_{i}\\log p_{i}\\,,\\] (10) where \\(p_{i}\\) is the relative probability of the \\(i\\)-th bin. The entropy is greatest when the histogram follows a uniform distribution, and lowest when the chord sequence uses only one chord throughout.\n* **Chord coverage** (CC): The number of chord labels with non-zero counts in the chord histogram in a chord sequence.\n* **Chord tonal distance** (CTD): The _tonal distance_ proposed by (Harte et al., 2006) is a canonical way to measure the closeness of two chords. It is calculated by firstly calculating the PCP features of two chords, projecting the PCP features to a derived 6-D tonal space, and finally calculating the Euclidean distance between the two 6-D feature vectors. CTD is the average value of the tonal distance computed between every pair of adjacent chords in a given chord sequence. The CTD is highest when there are abrupt changes in the chord progression (e.g., from C chord to B chord).\n\n_Chord/melody harmonicity metrics_, on the other hand, aims to evaluate the degree to which a generated chord sequence successfully harmonizes a given melody sequence.\n\n* **Chord tone to non-chord tone ratio** (CTnCTR): In reference to the chord sequence, we count the number of _chord tones_, and _non-chord tones_ in the melody sequence. Chord tones are defined as melody notes whose pitch class are part of the current chord (i.e., one of the three pitch classes that make up a triad) for the corresponding half bar. All the other melody notes are viewed as non-chord tones. One way to measure the harmonicity is to simply computing the ratio of the number of the chord tones (\\(n_{c}\\)) to the number of the non-chord tones (\\(n_{n}\\)). However, we find it useful to further take into account the number of a subset of non-chord tones (\\(n_{p}\\)) that are two semitones within the notes which are right after them, where subscript \\(p\\) denotes a \"proper\" non-chord tone. We define CTnCTR as \\[\\frac{n_{c}+n_{p}}{n_{c}+n_{n}}.\\] (11) CTnCTR equals one when there are no non-chord tones at all, or when \\(n_{p}=n_{n}\\).\n* **Pitch consonance score** (PCS): For each melody note, we calculate a _consonance score_ with each of the three notes of its corresponding chord label. The consonance scores are computed based on the musical interval between the pitch of the melody notes and the chord notes, assuming that the pitch of the melody notes is always higher. This is always the case in our implementation, because we always place the chord notes lower than the melody notes. The consonance score is set to 1 for consonance intervals including unison, major/minor 3rd, perfect 5th, major/minor 6th, set to 0 for a perfect 4th, and set to -1 for other intervals, which are considered dissonant. PCS for a pair of melody and chord sequences is computed by averaging these consonance scores across a 16th-note windows, excluding rest periods.\n* **Melody-chord tonal distance** (MCTD): Extending the idea of tonal distance, we represent a melody note by a PCP feature vector (which would be a one-hotvector) and compare it against the PCP of a chord label in the 6-D tonal space (Harte et al., 2006) to calculate the closeness between a melody note and a chord label. MCTD is the average of the tonal distance between every melody note and corresponding the chord label calculated across a melody sequence, with each distance weighted by the duration of the corresponding melody note.\n\n## 5 Comparative Study\n\nWe train all the five models described in Section 2 using the training split of HTPD3 and then apply them to the test split of HTPD3 to get the predicted chord sequences for each melody sequence. Examples of the harmonization result of the evaluated models can be found in Figures 3 and 4.\n\nWe note that, since one cannot judge the full potential of each algorithm only from our simplified setting of melody harmonization, we do not intend to find what method is the best in general. We rather attempt a challenge to compare different harmonization method which have not been directly compared because of the different context that each approach assumes.\n\nIn what follows, we use the harmonization result for a random subset of the test set comprising 100 pieces in a user study for subjective evaluation. The result of this subjective evaluation is presented in Section 5.1. Then, in Section 5.2, we report the results of an objective evaluation wherein we compute the mean values of the chord/melody harmonicity and chord progression metrics presented in Section 4 for the harmonization results for each test set piece.\n\nFigure 3: A harmonization example (in major key) from The Beatles: _Hey Jude_. We can see that, while the non-deep learning models change the harmonization in different phrases, the MTharmonizer generates a V-I progression nicely to close the phrase.\n\n### Subjective Evaluation\n\nWe conducted an online survey where we invited human subjects to listen to and assess the harmonization results of different models. The subjects evaluated the harmonizations in terms of the following criteria:\n\n* **Harmonicity**: The extent to which a chord progression successfully or pleasantly harmonizes a given melody. This is designed to correspond to what the melody/chord harmonicity metrics described in Section 4 aim to measure.\n* **Interestingness**: The extent to which a chord progression sounds exciting, unexpected and/or generates \"positive\" stimulation. This criterion corresponds to the chord-related metrics described in Section 4. Please note that we use a less technical term \"interestingness\" here since we intend to solicit feedback from people either with or without musical backgrounds.\n* The **Overall** quality of the given harmonization.\n\nGiven a melody sequence, we have in total six candidate chord sequences to accompany it: those generated by the five models presented in Section 2, and the _human-composed_, ground-truth progression retrieved directly from the test set. We intend to compare the results of the automatically generated progression with the original human-composed progression. Yet, given the time and cognitive load required, it was not possible to ask each subject to evaluate the results of every model for every piece of music in the test set (there are \\(6\\times 923=5,538\\) sequences in total). We describe below how our user study is designed to make the evaluation feasible.\n\nFigure 4: A harmonization example (in minor key) from ABBA: _Gimme Gimme Gimme A Man After Midnight_. Similar to the example shown in Figure 3, the result of the MTHarmonizer appears to be more diverse and functionally correct. We also see that the result of GA is quite \u201cinteresting\u201d\u2014e.g., with non-diatonic chord D flat Major and close the music phrase with Picardy third (i.e., a major chord of the tonic at the end of a chord sequence that is in a minor key). We also see that the non-deep learning methods seem to be weaker in handling the tonality of music.\n\n#### 5.1.1 Design of the User Study\n\nFirst, we randomly select 100 melodies from the test set of HTPD3. For each human subject, we randomly select three melody sequences from this pool, and present to the subject the harmonization results of two randomly selected models for each melody sequence. For each of the three melodies, the subject listens to the melody without accompaniment first, and then the sequence with two different harmonizations. Thus, the subject has to listen to nine music pieces in total: three melody sequences and the six harmonized ones. As we have six methods for melody harmonization (including the original human-composed harmonization), we select methods for each set of music such that each method is presented once and only once to each subject. The subjects are not aware of which harmonization is generated by which method, but are informed that at least one of the harmonized sequence is human-composed.\n\nIn each set, the subject has to listen to the two harmonized sequences and decide which version is better according to the three criteria mentioned earlier. This _ranking_ task is mandatory. In addition, the subject can choose to further grade the harmonized sequences in a five-point Likert scale with respect to the criteria mentioned earlier. Here, we break \"harmonicity\" into the following two criteria in order to get more feedback from subjects:\n\n* **Coherence**: the coherence between the melody and the chord progression in terms of harmonicity and phrasing.\n* **Chord Progression**: how coherent, pleasant, or reasonable the chord progression is on its own, independent of the melody.\n\nThis optional _rating_ task thus has four criteria in total.\n\nThe user study opens to an \"instructions\" page, that informs the subjects that we consider only root-positioned triad chords in the survey. Moreover, they are informed that there is no \"ground truth\" in melody harmonization--the task is by nature subjective. After collecting a small amount of relevant personal information from the subjects, we present them with a random audio sample and encourage them to put on their headsets and adjust the volume to a comfortable level. After that, they are prompted to begin evaluating the three sets (i.e., one set for each melody sequence), one-by-one on consecutive pages.\n\nWe spread the online survey over the Internet openly, without restriction, to solicit voluntary, non-paid participation. The webpage of the survey can be found at [https://musicai.citi.sinica.edu.tw/survey_mel_harm/](https://musicai.citi.sinica.edu.tw/survey_mel_harm/).\n\n#### 5.1.2 User Study Results\n\nIn total, 202 participants from 16 countries took part in the survey. We had more male participants than female (ratio of 1.82:1), and the average age of participants was 30.8 years old. 122 participants indicated that they have music background, and 69 of them are familiar with or expertise in the harmonic theory. The participants took on average 14.2 minutes to complete the survey.\n\nWe performed the following two data cleaning steps: First, we discarded both the ranking and rating results from participants who spent less than 3 minutes to complete the survey, which is considered too short. Second, we disregarded rating results when the relative ordering of the methods contradicted that from the ranking results. As a result, 9.1% and 21% of the ranking and rating records were removed, respectively.\n\nWe first discuss the results of the pairwise ranking task, which is shown in Figure 5. The following observations are made:Figure 5: \u201cWin probabilities\u201d of different model pairs. Each entry represents the probability that the model in that column scores higher than the model in that row.\n\n* The human-composed progressions have the highest \"win probabilities\" on average in all the three ranking criteria. It performs particularly well in _Harmonicity_.\n* In general, the deep learning methods have higher probabilities to win over the non-deep learning methods in _Harmonicity_ and _Overall_.\n* For _Interestingness_, GA performs the best among the five automatic methods, which we suspect stems from its entropy term (Eq. (6)).\n* Among the two deep learning methods, the MTHarmonizer consistently outperforms the BiLSTM in all ranking criteria, especially for _Interestingness_. We (subjectively) observe that MTHarmonizer indeed generates more diverse chord progressions compared to the vanilla BiLSTM, perhaps due to the consideration of functions.\n\nThe results of the rating task shown in Figure 6, on the other hand, lead to the following observations:\n\n* Congruent with the results of the ranking task, the MTHarmonzer model achieves the second best performance here, only losing out to the original human-composed chord progressions. The MTHarmonzer consistently outperforms the other four automatic methods in all the four metrics. With a paired t-test, we find that there is significant performance difference between the MTHarmonzer progressions and the original human-composed progressions in terms of _Coherence_ and _Chord Progression_ (p-value\\(<\\)0.005), but no significant difference in terms of _Interestingness_ and _Overall_.\n* Among the four metrics, the original human-composed progressions score higher in _Coherence_ (3.81) and _Overall_ (3.78), and the lowest in _Interestingness_ (3.43). This suggests that the way we simplify the data (e.g., using only root-positioned triad chords) may have limited the perceptual qualities of the music, in particular its diversity.\n* Generally speaking, the results in _Chord Progression_ (i.e., the coherence of the chord progression on its own) seems to correlate better with the results in _Coherence_ (i.e., the coherence between the melody and chord sequences) than the _Interestingness_ of the chord progression. This suggests that a chord progression rated as being interesting may not sound coherent.\n* Although the GA performs worse than the MTHarmonizer on all the four metrics, it actually performs fairly well in _Interestingness_ (3.23), as we have observed from the ranking result. A paired t-test showed no significant performance difference between the GA generated progressions and original human-composed progressions in _Interestingness_. A hybrid model that combines GA and deep learning may be a promising direction for future research.\n\nFrom the rating and ranking tasks, we see that, in terms of harmonicity, automatic\n\nFigure 6: The mean rating scores in subjective evaluation, along with the standard deviation (the error bars).\n\nmethods still fall behind the human composition. However, the results of the two deep learning based methods are closer to that of the human-composed ones.\n\n### Objective Evaluation\n\nThe results are displayed in Table 1. We discuss the result of the melody/chord harmonicity metrics first. We can see that the results for the two deep learning methods are in general closer to the results for the original human-composed progressions than those of the three non-deep learning methods for all three harmonicity metrics, most significantly on the latter two. The template matching-based and HMM-based methods scores high in PCS and low in MCTD, indicating that the harmonization these two methods generate may be too conservative. In contrast, the GA scores low in PCS and high in MCTD, indicating overly low harmonicity. These results are consistent with the subjective evaluation, suggesting that these metrics can perhaps reflect human perception of the harmonicity between melody and chords.\n\nFrom the result of the chord progression metrics, we also see from CHE and CC that the progressions generated by the template matching-based and HMM-based methods seem to lack diversity. In contrast, the output of GA features high diversity.\n\nAs the GA based method was rated lower than the template matching and HMM methods in terms of the _Overall_ criterion in our subjective evaluation, it seems that the subjects care more about the harmonicity than the diversity of chord progressions.\n\nComparing the two deep learning methods, we see that the MTHarmonizer uses more non-chord tones (smaller CTnCTR) and uses a greater number of unique chords\n\n\\begin{table}\n\\begin{tabular}{l c c c} \\hline \\hline\n**Melody/chord harmonicity metrics** & CTnCTR & PCS & MCTD \\\\ \\hline Human-composed & 0.74 & 1.42 & 1.03 \\\\ Template matching & 0.91 & 1.97 & 0.83 \\\\ HMM (adapted from (Lim et al., 2017)) & 0.89 & 1.93 & 0.85 \\\\ GA-based (adapted from (Kitahara et al., 2018)) & **0.74** & 0.43 & 1.31 \\\\ BiLSTM (adapted from (Lim et al., 2017)) & 0.87 & 1.84 & 0.91 \\\\ MTHarmonizer (proposed here) & 0.82 & **1.77** & **0.94** \\\\ \\hline\n**Chord progression metrics** & CHE & CC & CTD \\\\ \\hline Human-composed & 1.28 & 2.62 & 0.88 \\\\ Template matching & 1.01 & 1.70 & 0.65 \\\\ HMM (adapted from (Lim et al., 2017)) & 0.88 & 1.89 & 0.56 \\\\ GA-based (adapted from (Kitahara et al., 2018)) & 1.58 & **2.47** & **0.96** \\\\ BiLSTM (adapted from (Lim et al., 2017)) & 1.07 & 2.07 & 0.71 \\\\ MTHarmonizer (proposed here) & **1.29** & 2.31 & 1.02 \\\\ \\hline \\hline \\end{tabular}\n\\end{table}\nTable 1: Objective evaluation scores for different melody harmonization models. The closer the values to that of the human-composed samples, the better the model is in modeling the training data. The bold values indicate the closet value to that of the human-composed samples per metric. And, 1) higher values in CTnCTR and PCS and lower values in MCTD may suggest that the melody/chord harmonicity is high; 2) higher values in CHE and CC and lower values in CTD may suggest that the diversity (which can be related to the interestingness) of the chord progression is high. See Section 4 for the definitions of the metrics.\n\n(larger CC) than the BiLSTM model. The CHE of the MTHarmonizer is very close to that of the original human-composed progressions.\n\nIn general, the results of the objective evaluation appear consistent with those of the subjective evaluation. It is difficult to quantify which metrics are better for what purposes, and how useful and accurate these metrics are overall. Therefore, our suggestion is to use them mainly to gain practical insights into the results of automatic melody harmonization models, rather than to judge their quality. As pointed out by (Dong et al., 2018), objective metrics can be used to track the performance of models during development, before committing to running the user study. Yet, human evaluations are still needed to evaluate the quality of the generated music.\n\nFinally, although we have argued earlier that there is no ground truth in melody harmonization and that it is not adequate to rely solely on chord prediction error to evaluate the models, we find that the MTHarmonizer also achieves the lowest chord prediction error (i.e., a 48-class classification problem) and chord function prediction error (a 3-class classification problem). On the test set, the chord prediction accuracy for the five models (template matching, HMM, GA, BiLSTM, and MTHarmonizer) is 29%, 31%, 20%, 35%, and 38%, respectively, while the accuracy for a random guess baseline is only 2%. And, the chord function prediction accuracy is 62%, 61%, 55%, 65%, 69%, respectively, while the accuracy for a random guess baseline is 51%.\n\n## 6 Discussions\n\nWe admit that the comparative study presented above has some limitations. First, because of the various preprocessing steps taken for data cleaning and for making the melody harmonization task manageable (cf. Section 3), the \"human-composed\" harmonizations are actually simplified versions of those found on TheoryTab. We considered triad chords only, and we did not consider performance-level attributes such as velocity and rhythmic pattern of chords. This limits the perceptual quality of the human-composed chord progression, and therefore also limits the results that can be achieved by automatic methods. The reduction from extended chords to triads reduces the \"color\" of the chords and creates many innacurate chord repetitions in the dataset (e.g., both the alternated CMaj7 and C7 will be reduced to C triad chord). We believe it is important to properly inform the human subjects of such limitations as we did in the instruction phase of our user study. We plan to compile other datasets from HLSD to extend the comparative study in the future.\n\nSecond, in our user study we asked human subjects to rank and rate the results of two randomly chosen methods in each of the three presented sets. After analyzing the results, we found that the subject's ratings are in fact _relative_. For example, the MTHarmonizer's average score in _Overall_ is 3.04 when presented alongside the human-composed progressions, and 3.57 when confronted with the genetic algorithm-based model. We made sure in our user study that all the methods are equally likely to be presented together with every other method, so the average rating scores presented in Figure 6 do not favor a particular method. Still, caution is needed when interpreting the rating scores. Humans may not have a clear idea of how to consistently assign a score to a harmonization. While it is certainly easier to objectively compare multiple methods with the provided rating scores, we still recommended asking human subjects to make pairwise rankings in order to make the result more reliable.\n\nThird, as the aim of this paper is to sample representative models from the literature, the current setting cannot decouple the effects of the model architectures (e.g.,HMMs, GAs and BiLSTMs) and the music knowledge induced into the model (e.g., the concept of functional harmonic in MTHarmonizer). Moreover, for similar reasons, the models we implemented in this paper do not include extensions that might lead to better performance. For example, we could further improve the HMM model by using trigrams or extending the hidden layers as discussed in the literature (Paiement et al., 2006; Temperley, 2009; Tsushima et al., 2017). It may also be possible to incorporate some of the proposed objective metrics (such as the chord tone to non-chord tone ratio) as additional loss terms. The aim of this paper is to observe how different categories of models characterize the harmonization results rather than to explore the full potentials of each presented model.\n\nReviewing the properties of harmonization algorithms which imitate styles in a dataset as in our research still holds its importance, although recent music generation research is shifting towards measuring how systems can generate content that extrapolates meaningfully from what the model have learned (Zacharakis, Kaliakatsospapakostas, Tsougras, & Cambouropoulos, 2018). Extrapolation could be based on the model which also achieves interpolation or maintaining particular styles among data points. We believe we can further discuss extrapolation based on the understanding of how methods imitate data.\n\n## 7 Conclusion\n\nIn this paper, we have presented a comparative study implementing and evaluating a number of canonical methods and one new method for melody harmonization, including deep learning and non-deep learning based approaches. The evaluation has been done using a lead sheet dataset we newly collected for training and evaluating melody harmonization. In addition to conducting a subjective evaluation, we employed in total six objective metrics with which to evaluate a chord progression given a melody. Our evaluation shows that deep learning models indeed perform better than non-deep learning ones in a variety of aspects, including harmonicity and interestingness. Moreover, a deep learning model that takes the function of chords into account reaches the best result among the evaluated models.\n\nFuture work can be directed toward at least the following three directions. First, it is important to extend the chord vocabulary to include more complicated chords. Second, as self-attention based neural sequence models such as the Transformers (Vaswani et al., 2017) have been shown powerful alternatives to RNNs for various automatic music generation tasks (Y.-H. Chen, Huang, Hsiao, & Yang, 2020; Donahue, Mao, Li, Cottrell, & McAuley, 2019; Y.-S. Huang & Yang, 2020; Ren et al., 2020), it might be interesting to investigate Transformer-based models for melody harmonization. Finally, other than the melody harmonization task (i.e., generating chords given a melody) addressed in the paper, it would also be interesting to study chord-conditioned melody generation (i.e., generating a melody given chords) (Genchel, Pati, & Lerch, 2019; Trieu & Keller, 2018; Yang, Chou, & Yang, 2017), or simultaneously generating both melody and harmony from scratch (Jiang, Xia, Carlton, Anderson, & Miyakawa, 2020; Liu & Yang, 2018; Wu & Yang, 2020).\n\n## References\n\n* Allan & Williams (2005) Allan, M., & Williams, C. K. I. (2005). Harmonising chorales by probabilistic inference. In_Proc. Advances in Neural Information Processing Systems._\n\nBriot, J.-P., Hadjeres, G., & Pachet, F. (2017). Deep learning techniques for music generation: A survey. _arXiv preprint arXiv:1709.01620_.\n\nChen, T.-P., & Su, L. (2018). Functional harmony recognition of symbolic music data with multi-task recurrent neural networks. In _Proc. Int. Soc. Music Information Retrieval Conf._\n\n(pp. 90-97).\n\nChen, Y.-H., Huang, Y.-S., Hsiao, W.-Y., & Yang, Y.-H. (2020). Automatic composition of guitar tabs by Transformers and groove modeling. In _Proc. Int. Soc. Music Information Retrieval Conf._\n\nChuan, C.-H., & Chew, E. (2007). A hybrid system for automatic generation of style-specific accompaniment. In _Proc. Int. Joint Workshop on Computational Creativity._\n\nde Clercq, T., & Temperley, D. (2011). A corpus analysis of rock harmony. _Popular Music_, _30_(1), 47-70.\n\nDe Haas, W. B., Magalhaes, J. P., Wiering, F., & Veltkamp, R. C. (2014). Automatic functional harmonic analysis. _Computer Music Journal_, _37_(4), 37-53.\n\nde Leon, P. J. P., Inesta, J. M., Calvo-Zaragoza, J., & Rizo, D. (2016). Data-based melody generation through multi-objective evolutionary computation. _J. Mathematics and Music_, _10_(2), 173-192.\n\nDonahue, C., Mao, H. H., Li, Y. E., Cottrell, G. W., & McAuley, J. (2019). LakhNES: Improving multi-instrumental music generation with cross-domain pre-training. In _Proc. Int. Soc. Music Information Retrieval Conf._\n\n(pp. 685-692).\n\nDong, H.-W., Hsiao, W.-Y., Yang, L.-C., & Yang, Y.-H. (2018). MuseGAN: Symbolic-domain music generation and accompaniment with multi-track sequential generative adversarial networks. In _Proc. AAAI Conf. Artificial Intelligence._\n\nEbcioglu, K. (1988). An expert system for harmonizing four-part chorales. _Computer Music Journal_, _12_(3), 43-51.\n\nFernandez, J. D., & Vico, F. (2013). AI methods in algorithmic composition: A comprehensive survey. _J. Artificial Intelligence Research_, _48_(1), 513-582.\n\nForney, G. D. (1973). The viterbi algorithm. _Proceedings of the IEEE_, _61_, 268-278.\n\nFujishima, T. (1999). Realtime chord recognition of musical sound: A system using common Lisp. In _Proc. Int. Computer Music Conf._\n\n(pp. 464-467).\n\nGenchel, B., Pati, A., & Lerch, A. (2019). Explicitly conditioned melody generation: A case study with interdependent rnns. In _Proc. Computer Simulation of Music Creativity Conf._\n\nHadjeres, G., & Pachet, F. (2017). DeepBach: a steerable model for Bach chorales generation. In _Proc. Int. Conf. Machine Learning._\n\nHarte, C., Sandler, M., & Gasser, M. (2006). Detecting harmonic change in musical audio. In _Proc. Int. Soc. Music Information Retrieval Conf._\n\nHinton, G., Deng, L., Yu, D., Dahl, G., Mohamed, A., Jaitly, N.,... Kingsbury, B. (2012). Deep neural networks for acoustic modeling in speech recognition. _IEEE Signal Processing Magazine_, _29_(6), 82-97.\n\nHochreiter, S., & Schmidhuber, J. (1997). Long short-term memory. _Neural Computing_, _9_(8), 1735-1780.\n\nHuang, C.-Z. A., Cooijmans, T., Roberts, A., Courville, A., & Eck, D. (2017). Counterpoint by convolution. In _Proc. Int. Soc. Music Information Retrieval Conf._\n\n(pp. 211-218).\n\nHuang, Y.-S., & Yang, Y.-H. (2020). Pop Music Transformer: Beat-based modeling and generation of expressive Pop piano compositions. In _Proc. ACM Multimedia._\n\nJacoby, N., Tishby, N., & Tymoczko, D. (2015). An information theoretic approach to chord categorization and functional harmony. _J. New Music Research_, _44_(3), 219-244.\n\nJiang, J., Xia, G. G., Carlton, D. B., Anderson, C. N., & Miyakawa, R. H. (2020). Transformer VAE: A hierarchical model for structure-aware and interpretable music representation learning. In _Proc. Int. Conf. Acoustics, Speech and Signal Processing_\n\n(p. 516-520).\n\nKitahara, T., Giraldo, S., & Ramirez, R. (2018). JamSketch: Improvisation support system with GA-based melody creation from user's drawing. In _Proc. Int. Symp. Computer Music Multidisciplinary Research_\n\n(pp. 509-521).\n\nLim, H., Rhyu, S., & Lee, K. (2017). Chord generation from symbolic melody using BLSTM networks. In _Proc. Int. Soc. Music Information Retrieval Conf._ (pp. 621-627).\n* Liu & Yang (2018) Liu, H.-M., & Yang, Y.-H. (2018). Lead sheet generation and arrangement by conditional generative adversarial network. In _Proc. IEEE Int. Conf. Machine Learning And Applications._\n* Makris et al. (2016) Makris, D., Kayrdis, I., & Sioutas, S. (2016). Automatic melodic harmonization: An overview, challenges and future directions. In _Trends in Music Information Seeking, Behavior, and Retrieval for Creativity_ (pp. 146-165). IGI Global.\n* Nobile (2015) Nobile, D. F. (2015). Counterpoint in rock music: Unpacking the \"melodic-harmonic divorce\". _Music Theory Spectrum_, _37_(2), 189-203.\n* Paiement et al. (2006) Paiement, J.-F., Eck, D., & Bengio, S. (2006). Probabilistic melodic harmonization. In _Proc. Conf. Canadian Society for Computational Studies of Intelligence_ (pp. 218-229).\n* Phon-Amnuaisuk & Wiggins (1999) Phon-Amnuaisuk, S., & Wiggins, G. (1999). The four-part harmonisation problem: a comparison between genetic algorithms and a rule-based system. In _Proc. AISB Symp. Musical Creativity._\n* Raczynski et al. (2013) Raczynski, S., Fukayama, S., & Vincent, E. (2013). Melody harmonisation with interpolated probabilistic models. _J. New Music Research_, _42_, 223-235.\n* Raphael & Stoddard (2004) Raphael, C., & Stoddard, J. (2004). Harmonic analysis with probabilistic graphical models. _Computer Music Journal_, _28_(3), 45-52.\n* Ren et al. (2020) Ren, Y., He, J., Tan, X., Qin, T., Zhao, Z., & Liu, T.-Y. (2020). PopMAG: Pop music accompaniment generation. In _Proc. ACM Int. Conf. Multimedia._\n* Riemann (1893) Riemann, H. (1893). Vereinfachte harmonielehre, oder die lehre von den tonalen funktionen der akkorde. 1896. _Tr. H. Bewerunge._\n* Rohrmeier & Cross (2008) Rohrmeier, M., & Cross, I. (2008). Statistical properties of tonal harmony in bach's chorales. In _Proc. Int. Conf. Music Perception and Cognition_ (pp. 619-627).\n* Sheh & Ellis (2003) Sheh, A., & Ellis, D. P. (2003). Chord segmentation and recognition using EM-trained hidden Markov models. In _Proc. Int. Soc. Music Information Retrieval Conf._ (pp. 185-191).\n* Simon et al. (2008) Simon, I., Morris, D., & Basu, S. (2008). MySong: Automatic accompaniment generation for vocal melodies. In _Proc. SIGCHI Conf. Human Factors in Computing Systems_ (p. 725-734).\n* Srivastava et al. (2014) Srivastava, N., Hinton, G., Krizhevsky, A., Sutskever, I., & Salakhutdinov, R. (2014). Dropout: A simple way to prevent neural networks from overfitting. _J. Machine Learning Research_, _15_(1), 1929-1958.\n* Temperley (2007) Temperley, D. (2007). The melodic-harmonic 'divorce' in rock. _Popular Music_, _26_(2), 323-342.\n* Temperley (2009) Temperley, D. (2009). A unified probabilistic model for polyphonic music analysis. _J. New Music Research_, _38_(1), 3-18.\n* Trieu & Keller (2018) Trieu, N., & Keller, R. M. (2018). JazzGAN: Improvising with generative adversarial networks. In _Proc. Int. Workshop on Musical Metacreation._\n* Tsushima et al. (2017) Tsushima, H., Nakamura, E., Itoyama, K., & Yoshii, K. (2017). Function- and rhythm-aware melody harmonization based on tree-structured parsing and split-merge sampling of chord sequences. In _Proc. Int. Soc. Music Information Retrieval Conf._\n* Tsushima et al. (2018) Tsushima, H., Nakamura, E., Itoyama, K., & Yoshii, K. (2018). Generative statistical models with self-emergent grammar of chord sequences. _J. New Music Research_, _47_(3), 226-248.\n* Vaswani et al. (2017) Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N.,... Polosukhin, I. (2017). Attention is all you need. In _Proc. Advances in Neural Information Processing Systems_ (pp. 5998-6008).\n* Wu & Yang (2020) Wu, S.-L., & Yang, Y.-H. (2020). The Jazz Transformer on the front line: Exploring the shortcomings of ai-composed music through quantitative measures. In _Proc. Int. Soc. Music Information Retrieval Conf._\n* Yang et al. (2017) Yang, L.-C., Chou, S.-Y., & Yang, Y.-H. (2017). MidiNet: A convolutional generative adversarial network for symbolic-domain music generation. In _Proc. Int. Soc. Music Information Retrieval Conf._\n* Zacharakis et al. (2018) Zacharakis, A., Kaliakatsos-Papakostas, M., Tsougras, C., & Cambouropoulos, E. (2018). Musical blending and creativity: An empirical evaluation of the CHAMELEON melodic harmonisation assistant. _Musicae Scientiae_, _11_(1), 119-144.\n* Zhang et al. (2018)"}, "BIBREF316": {"title": "The nus sung and spoken lyrics corpus: A quantitative comparison of singing and speech", "authors": [{"first": "Zhiyan", "middle": [], "last": "Duan", "suffix": ""}, {"first": "Haotian", "middle": [], "last": "Fang", "suffix": ""}, {"first": "Bo", "middle": [], "last": "Li", "suffix": ""}, {"first": "Khe", "middle": ["Chai"], "last": "Sim", "suffix": ""}, {"first": "Ye", "middle": [], "last": "Wang", "suffix": ""}], "venue": "2013 Asia-Pacific Signal and Information Processing Association Annual Summit and Conference", "volume": "", "issue": "", "pages": "1--9", "text_pymu": "The NUS Sung and Spoken Lyrics Corpus: \nA Quantitative Comparison of Singing and Speech \nZhiyan Duan, Haotian Fang, Bo Li, Khe Chai Sim and Ye Wang \nSchool of Computing, National University of Singapore, Singapore. \nE-mail: [zhiyan, fanght, li-bo, simkc, wangye]@comp.nus.edu.sg  \n \n \nAbstract\u2014 Despite a long-standing effort to characterize \nvarious aspects of the singing voice and their relations to speech, \nthe lack of a suitable and publicly available dataset has \nprecluded any systematic study on the quantitative difference \nbetween singing and speech at the phone level. We hereby \npresent the NUS Sung and Spoken Lyrics Corpus (NUS-48E \ncorpus) as the first step toward a large, phonetically annotated \ncorpus for singing voice research. The corpus is a 169-min \ncollection of audio recordings of the sung and spoken lyrics of 48 \n(20 unique) English songs by 12 subjects and a complete set of \ntranscriptions and duration annotations at the phone level for all \nrecordings of sung lyrics, comprising 25,474 phone instances.  \nUsing the NUS-48E corpus, we conducted a preliminary, \nquantitative study on the comparison between singing voice and \nspeech.  The study includes duration analyses of the sung and \nspoken lyrics, with a primary focus on the behavior of \nconsonants, and experiments aiming to gauge how acoustic \nrepresentations of spoken and sung phonemes differ, as well as \nhow duration and pitch variations may affect the Mel Frequency \nCepstral Coefficients (MFCC) features.  \nI. \nINTRODUCTION \nIn audio signal analysis, it is important to understand the \ncharacteristics of singing voice and their relation to speech.  A \nwide range of research problems, such as singing and speech \ndiscrimination and singing voice recognition, evaluation, and \nsynthesis, \nstand \nto \nbenefit \nfrom \na \nmore \nprecise \ncharacterization of the singing voice.  Better solutions to these \nresearch problems could then lead to technological \nadvancements in numerous application scenarios, from music \ninformation retrieval and music edutainment to language \nlearning [1] and speech therapy [2]. \nGiven the similarity between singing and speech, many \nresearchers classify the former as a type of the latter and try to \nutilize the well-established automatic speech recognition \n(ASR) framework to handle the singing voice [3][4][5].  Due \nto the lack of phonetically annotated singing datasets, models \nhave been trained on speech corpora and then adapted to the \nsinging voice.  This approach, however, is intrinsically \nlimited because the differences between singing and speech \nsignals are not captured.  Thus, a quantitative comparison of \nsinging voice and speech could potentially improve the \ncapability and robustness of current ASR systems in handling \nsinging voice.   \nDespite long-standing efforts to characterize various \naspects of singing voice and their relations to speech [7][8], \nthe lack of a suitable dataset has precluded any systematic \nquantitative study.  Given that most existing models are \nstatistics-based, an ideal dataset should not only have a large \nsize but also exhibit sufficient diversity within the data. To \nexplore the quantitative differences of singing and speech at \nthe phone level, the research community needs a corpus of \nphonetically annotated recordings of sung and spoken lyrics \nby a diverse group of subjects. \nIn this paper, we introduce the NUS Sung and Spoken \nLyrics Corpus (NUS-48E corpus for short), 48 English songs \nthe lyrics of which are sung and read out by 12 subjects \nrepresenting a variety of voice types and accents. There are 20 \nunique songs, each of which covered by at least one male and \none female subject. The total length of audio recordings is \n115 min for the singing data and 54 min for the speech data. \nAll singing recordings have been phonetically transcribed \nwith duration boundaries, and the total number of annotated \nphones is 25,474. The corpus marks the first step toward a \nlarge, phonetically annotated dataset for singing voice \nresearch. \nUsing the new corpus, we conducted a preliminary study on \nthe quantitative comparison between sung and spoken lyrics.  \nUnlike in speech, the durations of syllables and phonemes in \nsinging are constrained by the music score. They have much \nlarger variations and often undergo stretching.  While vowel \nstretching is largely dependent on the tempo, rhythm, and \narticulation specified in the score, consonant stretching is \nmuch less well understood.  We thus conducted duration \nanalyses of the singing and speech data, primarily focusing on \nconsonants.  We also hope to better understand how one can \nborrow from and improve upon the state-of-the-art speech \nprocessing techniques to handle singing data.  We thus carried \nout experiments to quantify how the acoustic representations \nof spoken and sung phonemes differ, as well as how \nvariations in duration and pitch may affect the Mel Frequency \nCepstral Coefficients (MFCC) features.  The results of both \nthe duration and spectral analyses are hereby presented and \ndiscussed. \nThe remainder of this paper is organized as follows. \nSection II provides an overview of existing datasets and \nrelated works on the differences between singing and speech.  \nSection III describes the collection, annotation, and \ncomposition of the NUS-48E corpus.  Section IV and V \npresent the results of the duration analyses and spectral \ncomparisons, respectively.  Finally, Section VI and VII \nconclude this paper and suggest future work. \nII. \nRELATED WORK \n\fA. \nSinging Voice Dataset \nSinging datasets of various sizes and annotated contents are \navailable for research purposes.  To the best of our knowledge, \nhowever, none has duration annotations at the phoneme level.  \nMesaros and Virtanen conducted automatic recognition of \nsung lyrics using 49 singing clips, 19 of which are from male \nsingers and 30 from female singers [4].  Each clip is 20-30 \nseconds long, and the complete dataset amounts to \napproximately 30 minutes.  Although a total of 4770 phoneme \ninstances are present, the lyrics of each singing clip are \nmanually transcribed only at the word level, without any \nduration boundaries.  \nThe MIR-1K dataset [6] is a larger dataset consisting of \n1000 clips from 110 unique Chinese songs as sung by 19 \namateur singers, 8 of whom female.  The total length of the \nsinging clips is 133 minutes.  Since this dataset is intended for \nsinging voice separation, annotations consist of pitch, lyrics, \nunvoiced frame types, and vocal/non-vocal segmentation, but \ndo not contain segmentation on the word level or below. \nAIST Humming Database (AIST-HDB) [9] is a large \ndatabase for singing and humming research.  The database \ncontains a total of 125.9 hours of humming/singing/reading \nmaterials, recorded from 100 subjects. Each subject produced \n100 excerpts of 50 songs chosen from the RWC Music \nDatabase (RWC-MDB) [16].  While the lyrics of the songs \nare known, neither the AIST-HDB nor the RWC-MDB \nprovides any phoneme or word boundary annotation. \nB. \nDifferences of Singing and Speech \nObservations on differences of singing and speech have \nbeen reported and studied [7][8].  The three main differences \nlie in phoneme duration, pitch, and power.  Constrained by \nthe music score and performance conventions, the singing \nvoice stretches phonemes, stabilizes pitches, and roams within \na wider pitch range.  The power changes with pitch in singing \nbut not in speech. \nOhishi et al. studied the human capability in discriminating \nsinging and speaking voices [10].  They reported that human \nsubjects could distinguish singing and speaking with 70.0% \naccuracy for 200-ms signals and 99.7% for one-second \nsignals. The results suggest that both temporal characteristics \nand short-term spectral features contribute to perceptual \njudgment. The same research group also investigated shortterm MFCC features and long-term contour of the \nfundamental frequency (F0) in order to improve machine \nperform on singing-speaking discrimination [8].  F0 contour \nworks better for signals longer than one second, while MFCC \nperforms better on shorter signals.  The combination of the \nshort-term and long-term features achieved more than 90% \naccuracy for two-second signals.  \nSince singing and speech are similar from various aspects, \nfinding the right set of features to discriminate the two is \ncrucial.  A set of features derived from harmonic coefficient \nand its 4Hz modulation values are proposed in [11]. While in \n[12], a feature selection solution among 276 features is \nintroduced. \nC. \nConversion between Singing and Speech \nThe conversion between speaking and singing has also \nattracted research interest.  A system for speech-to-singing \nsynthesis is described in [13]. By modifying the F0, phoneme \nduration, and spectral characteristics, the system can \nsynthesize \na \nsinging \nvoice \nwith \nnaturalness \nalmost \ncomparable to a real singing voice using a speaking voice and \nthe corresponding text as input.  A similar system is \ndeveloped in [14] to convert spoken vowels into singing \nvowels.  On the other hand, the SpeakBySinging [15] system \nconverts a singing voice into a speaking voice while retaining \nthe timbre of the singing voice.  \nIII. THE NUS SUNG AND SPOKEN LYRICS CORPUS \nA. \nAudio Data Collection \nSong Selection. We selected twenty songs in English as the \nbasis of our corpus (see Table I).  They include well-known \ntraditional songs and popular songs that have been regional \nand international hits, as well as several songs that may be \nless familiar but are chosen for their phonemic richness and \nease of learning.  In addition, lyrics of some songs, such as \nJingle Bells and Twinkle Twinkle Little Star, are expanded to \ninclude verses other than the most familiar ones to further \nenhance the phonemic richness of the corpus, while overly \nrepetitive lines or instances of scat singing, such as those \nfound in Far Away from Home and Lemon Tree, are excised \nto better preserve phonemic balance.  The list of songs and \ntheir selected lyrics are posted on our study website1. \nSubject Profile. We recruited 21 subjects, 9 males and 12 \nfemales, from the National University of Singapore (NUS) \nChoir and the amateur vocal community at NUS.  All subjects \nare enrolled students or staff of the university.  They are 21 to \n27 years of age and come with a wide range of musical \nexposure, from no formal musical training to more than 10 \nyears of vocal ensemble experience and vocal training.  All \nfour major voice types (soprano, alto, tenor, and bass) are \nrepresented, as well as a spectrum of English accents, from \nNorth American to the various accents commonly found in \nSingapore.  Local accents tend to be less apparent in singing \nthan in speaking, a phenomenon that becomes more marked \nas the subject\u2019s vocal experience increases.  Subjects are all \nproficient speakers of English, if not native speakers.  \nCollection Procedure. Subjects visited the study website \nto familiarize with the lyrics of all twenty songs before \ncoming to our sound-proof recording studio (STC 50+) for \ndata collection.  An Audio-Technica 4050 microphone with \npop filter was used for the recording.  Audio data were \ncollected at 16-bit and 44.1kHz using Pro Tools 9, which also \ngenerated a metronome with downbeat accent to set the tempi \nand to serve as a guide for singing.  The metronome was fed \nto the subject via the headphone.  The selected lyrics for all \nsongs were printed and placed on a music stand by the \n                                                             \n1 http://singingevaluation.wordpress.com/2012/11/22/songs-to-pick/ \n\fmicrophone for the subject\u2019s reference.  Except metronome \nbeats heard through the headphone, no other accompaniment \nwas provided, and subjects were recorded a cappella. \nFor each song, the selected lyrics were sung first.  While \nthe tempo was set, the subject could choose a comfortable key \nand were free to make small alterations to rhythm and pitch.  \nThen, the subject\u2019s reading of the lyrics was recorded on a \nseparate track.  When a track with all the lyrics clearly sung \nor spoken was obtained, the subject proceeded to the next \nsong.  A few pronunciation errors were allowed as long as the \nutterance remained clear.  Except the occasional rustles of the \nlyric printouts, miscellaneous noise was avoided or excised \nfrom the recording as much as possible. \nFor each subject, an average of 65 minutes of audio data \nwas thus collected in 20 singing (~45min) and 20 reading \ntracks (~20min).  Each track was then bounced from Pro \nTools as a wav file for subsequent storage, annotation, and \naudio analyses.  At the end of the recording session, we \nreimbursed each subject with a S$50 gift voucher for the \nuniversity co-op store. \nB. \nData Annotation \nWe adopted the 39-phoneme set used by the CMU \nDictionary (see Table II) for phonetic annotation [17].  Three \nannotators used Audacity to create a label track for each audio \nfile, and labeled phones and their timestamps are exported as \na text file.  Phones were labeled not according to their \ndictionary pronunciation in American English but as they had \nbeen uttered.  This was done to better capture the effect of \nsinging as well as the singer\u2019s accent on the standard \npronunciation.  We also included two extra labels, sil and sp, \nto mark the lengths of silence or inhalation between words \n(and, occasionally, between phones mid-word) and all \nduration-less word boundaries, respectively (see Fig. 1).  \nLabels of one annotator were checked by another to ensure \ninter-rater consistency. \nC. \nCorpus Composition \nDue to the time-consuming nature of phonetic transcription \nand the limitations on manpower, for the first version of the \ncorpus we only manually annotated the singing data of 12 \nsubjects.  They include 6 males and 6 females and represent \nall voice types and accent types (see Table III).  For each \nsubject, we selected 4 songs to annotate.  To ensure that all 20 \nsongs were annotated at least once for both genders and that \nthe number of annotated phones for each subject remained \nroughly equal, we ranked the songs by the number of phones \nestimated using the CMU Dictionary and assigned them \naccordingly (see Table I).  At this stage, each subject has \n \nTABLE   I \nSONGS IN THE NUS CORPUS \n \nSong Name \nArtist / Origin (Year) \nTempo \n(bpm) \nAudio Length \nEstimate (s) \nPhone Count \nEstimate \nFemale \nSubjecta \nMale \nSubjecta \nEdelweiss \nThe Sound of Music (1959) \nMed (96) \n65 \n140 \n03 \n11 \nDo Re Mi \nThe Sound of Music (1959) \nFast (120) \n67 \n280 \n05 \n08 \nJingle Bells \nPopular Christmas Carol \nFast (120) \n85 \n630 \n05 \n08 \nSilent Night \nPopular Christmas Carol \nSlow (80) \n165 \n340 \n01 \n09 \nWonderful Tonight \nEric Clapton (1976) \nSlow (80) \n180  \n450 \n02 & 06 \n07 & 10 \nMoon River \nBreakfast at Tiffany's (1961) \nSlow (88) \n160 \n380 \n05 \n08 \nRhythm of the Rain \nThe Cascades (1962) \nMed (116) \n85 \n460 \n04 \n12 \nI Have a Dream \nABBA (1979) \nMed (112) \n135 \n390 \n06 \n10 \nLove Me Tender \nElvis Presley (1956) \nSlow (72) \n140 \n310 \n03 \n11 \nTwinkle Twinkle Little Star \nPopular Children's Song \nFast (150) \n115 \n640 \n01 \n09 \nYou Are My Sunshine \nJimmy Davis (1940) \nSlow (84) \n167 \n620 \n02 & 06 \n07 & 10 \nA Little Love \nJoey Yung (2004) \nSlow (84) \n53 \n250 \n01 \n09 \nProud of You \nJoey Yung (2003) \nSlow (84) \n140 \n680 \n03 \n11 \nLemon Tree \nFool's Garden (1995) \nFast (150) \n160 \n900 \n05 \n08 \nCan You Feel the Love Tonight \nElton John (1994) \nSlow (68) \n175 \n540 \n04 & 06 \n10 & 12 \nFar Away from Home \nGroove Coverage (2002) \nMed (112) \n140 \n680 \n04 \n12 \nSeasons in the Sun \nTerry Jacks (1974); Westlife (1999) \nMed (100) \n175 \n920 \n01 \n09 \nThe Show \nLenka (2008) \nFast (132) \n200 \n980 \n03 \n11 \nThe Rose \nBette Midler (1979) \nSlow (68) \n175 \n450 \n02 \n07 \nRight Here Waiting \nRichard Marx (1989) \nSlow (88) \n160 \n550 \n02 & 04 \n07 & 12 \na Number in these columns are code identifications of subject singers. See Table III \n\faround 2100 phones annotated, and the corpus contains a total \nof 25,474 phone instances.  \nAnnotation for spoken lyrics is generated by aligning the \nmanually-labeled phone strings of the sung lyrics to the \nspoken lyrics using conventional Gaussian Mixture Model \n(GMM) \u2013 Hidden Markov Model (HMM) system trained on \nthe Wall Street Journal (WSJ0) corpus (see Sec. 5 for details).  \nWhile numerous discrepancies might exist between the actual \nsung and spoken versions, arising from the articulatory \npeculiarities of subjects and the differing methods of \nalignment, the annotated spoken lyrics allow us to make broad \nand preliminary observations about the extent of phonemic \nstretching between sung and spoken lyrics.  As part of our \nfuture work, we will expand our corpus to include manual \nannotations of the spoken lyrics. \nIV. DURATION ANALYSIS \nA. \nConsonants Stretching \nIn singing, vowels are stretched to maintain musical notes \nfor certain durations, and their durations are to a large extent \ndictated by the score.  While the stretching of vowels is much \nmore pronounced, consonants are nevertheless stretched at a \nnon-trivial level (see Fig. 2).  As the factors influencing \nconsonant duration are less apparent than those for vowels, \nwe will explore not only how much stretching takes place but \nalso what may affect the amount of stretching.  \n \nThe stretching ratio is computed as follows, \n \nsr = Tsinging / Tspeech ,                            (1) \n \nwhere sr is the stretching ratio and Tsinging and Tspeech the \ndurations of the phoneme in singing and the corresponding \nspeech, respectively.  The higher the sr value, the more the \nphoneme is stretched in singing. \nIn the speech-to-singing conversion system developed in \n[13], the authors use fixed ratios for different types of \nconsonants.  The ratios used are experimentally determined \nfrom observations of singing and speech signals.  Using the \nNUS-48E corpus, we analyzed the stretching ratio of \n \nFig. 2   Comparison on Duration Stretching  \nof Vowels and Consonants in singing \n \nFig. 1  SIL and SP labels denoting boundaries \nTABLE   II \nPHONEMES AND PHONEME CATEGORIES \n \nClass \nCMU Phonemes  \nVowels \nAA, AE, AH, AO, AW, AY, EH, ER, EY, \nIH, IY, OW, OY, UH, UW \nSemivowels \nW, Y \nStops \nB, D, G, K, P, T \nAffricates \nCH, JH \nFricatives \nDH, F, S, SH, TH, V, Z, ZH \nAspirates \nHH \nLiquids \nL, R \nNasals \nM, N, NG \n \nTABLE   III \nSUBJECTS IN THE NUS CORPUS \n \nCode \nGender \nVoice Type \nSung Accent \nSpoken Accent \n01 \nF \nSoprano \nNorth American \nNorth American \n02 \nF \nSoprano \nNorth American \nNorth American \n03 \nF \nSoprano \nNorth American \nMild Local \nSingaporean \n04 \nF \nAlto \nMild Malay \nMild Malay \n05 \nF \nAlto \nMalay \nMalay \n06 \nF \nAlto \nMild Malay \nMild Malay \n07 \nM \nTenor \nMild Local \nSingaporean \nMild Local \nSingaporean \n08 \nM \nTenor \nNorthern Chinese \nNorthern Chinese \n09 \nM \nBaritone \nNorth American \nNorth American \n10 \nM \nBaritone \nNorth American \nStandard \nSingaporean \n11 \nM \nBaritone \nNorth American \nNorth American \n12 \nM \nBass \nLocal Singaporean \nLocal Singaporean \n \n\fconsonants.  Given that the phoneme alignment on speech \ndata is automatically generated with a speech recognizer \nwhile the phoneme boundaries on singing data are manually \nannotated, the results remain preliminary observations. \nAs shown in Fig. 3, among the 7 types of consonants \ncompared, liquids, semivowels, and nasals exhibit larger \nstretching ratios (2.2371, 1.9852, and 1.7027, respectively.)  \nThis result conforms to the intuition that these types of \nsonorants could be sustained and articulated for a longer \nperiod of time than others types such as stops and affricates.  \nAnother interesting question is how the consonants are \nstretched in syllables of various lengths.  The length of the \nsyllables may have an effect on the length of consonants.  As \nshown in Fig. 4, when syllable length starts to grow, the \nstretching ratio of semivowels increases accordingly. After \nthe syllable length reaches around 1 second, however, the \nstretching ratio of semivowels tends to decrease. Not \nsurprisingly, since vowels are the dominant constituent of \nsyllables, the stretching ratio of vowels keeps growing when \nsyllables become longer.  \nObservations on other types of consonants are similar to \nthat discussed above for semivowels. \nB. \nSubject Variations on Consonants Stretching \nAs observations in the previous section only describe an \noverarching trend across all consonants for all subjects, it is \nimportant to check whether individual subjects follow such a \ntrend consistently.  We first investigated the differences with \nrespect to gender.  Fig. 5 shows the probability density \nfunctions (PDF) for the stretching ratios of both gender \ngroups.  The difference between them is negligible, \nsuggesting that consonant stretching ratio is genderindependent. Next, we compared individual subjects.  For \nexample, subjects 05 and 08 contributed the same 4 songs, Do \nRe Mi, Jingle Bells, Moon River, and Lemon Tree.  Subject 05 \nis a female with Malay accent and has had two years of choral \nexperience at the time of recording, while subject 06 is a male \nwith northern Chinese accent and had no vocal training \nwhatsoever.  As Fig. 6 shows, the distributions of the \nconsonant stretching ratios of the two subjects remain roughly \nthe same despite individual differences in accent and musical \nexposure. Therefore, the extent of consonant stretching may \nbe attributed more to the act of singing itself than any \ndiscrepancy in the vocal practice of the singers.  \nC. \nSyllabic Proportions of Consonants \nSyllabic proportions are calculated as quotients of the \nconsonant durations and the syllable durations.  A phone with \nlonger duration might not take up a higher proportion as it \nmay be part of a long syllable. \nFigure 7 shows the syllabic proportion for all consonant \ntypes and both gender groups.  Overall, semivowels have the \nhighest proportion while aspirates and stops have the lowest.  \nWith aspirates as the lone exception, the syllabic proportions \nof all consonant types are higher in males than in females.  \n \nFig. 4   Comparison on Duration Stretching Ratio across Different Length of \nSyllables for Vowels and Semivowels \n \n \nFig. 3  Average Stretching Ratios of Seven Types of Consonants \n\fFurther observation confirms that the absolute duration \nlengths of both consonants and syllables are larger in male \nsubjects.  This is an unexpected and interesting phenomenon \ngiven the observation made in the last subsection, namely that \nconsonant durations seem to be stretched to similar extents in \nsubjects of both genders.   \nThree factors could contribute to such a phenomenon.  First, \nmale and female subjects may have somewhat different \nduration distributions for consonants and vowels within the \nspoken syllables to begin with.  Second, the stretching of sung \nvowels could exhibit gender-related discrepancies.  Lastly, \nstructure of the same syllable in the lyrics could be different \nbetween speech and singing, especially for subjects who \nwould sing in a different accent.  A dropped consonant or a \ndiphthongized vowel could alter syllable makeup and affect \nsyllable length.  Once we have expanded our corpus to \ninclude phonetic annotations for the spoken lyrics, we plan to \nfurther our comparison study to examine these factors.  \nD. \nConsonant Position and its Effect on Proportion \n Within a syllable, consonants may appear at different \npositions.  For example, in the word love (/l/ /ah/ /v/), \nconsonant /l/ is located at the beginning of the word; while in \nsoul (/s/ /ow/ /l/), it is at the end. We are interested to see \nwhether this positioning has any effect on the syllabic \nproportion. We first defined four consonant positions: \n1. Starting: at the beginning of a word, e.g. /g/ in go \n2. Preceding: preceding a vowel, but not at the beginning \nof a word, e.g. /m/ in small \n3. Succeeding: succeeding a vowel, but not at the end of \na word, e.g. /l/ in angels \n4. Ending: at the end of a word, e.g. /t/ in at \nWe compared the syllabic proportions for the seven \nconsonant categories with respect to positioning. The results \nare shown in Fig. 8.  Semivowels and stops at the starting \nposition are much more prominent than those at the end, \nwhile the opposite is observed for affricates and nasals.  The \nsyllabic proportions of fricatives, aspirates and liquids are \nlargely similar between the starting and ending position.  \nFor all consonants, the proportion for preceding position is \nsignificantly lower than that of the starting one.  The \nphenomenon is mirrored for the succeeding and ending \npositions, in which the latter is much more prominent than the \nformer. \nV. \nSPECTRAL ANALYSIS \nAlthough we could build a conventional Gaussian Mixture \nModel (GMM) \u2013 Hidden Markov Model (HMM) system \nusing the NUS-48E corpus, the performance is expected to be \nlow mainly due to the following two factors: the limited \namount of speech data and the variation of accents among the \nsubjects. While few large, high-quality singing corpora are \navailable for academic research, there are numerous standard \nspeech corpora. We adopted the Wall Street Journal (WSJ0) \ncorpus, a large collection of read speech with texts drawn \nfrom a machine-readable corpus of Wall Street Journal news, \n \nFigure 7  Mean syllabic proportions for different types of consonants \n \nFigure 8  Proportion comparison of consonants in different positions \n \nFig. 5   Comparison on Probability Density Function of Consonants Duration \nStretching Ratio with Respect to Gender \n \nFig. 6   Comparison on Consonants Duration Stretching Ratio of Subject 05 \nand Subject 08 \n\fto train our speech GMM-HMM system, which is built to \nmaximize the likelihood of the training data using the Hidden \nMarkov Model Toolkit (HTK). The system adopts the CMU \nphoneme set used in the NUS-48E corpus and has a total of \n2419 tied triphone states to model the various phoneme \nrealizations in different acoustic contexts. Each state is \nmodeled by a GMM with 16 components. On the benchmark \n5k close vocabulary speech recognition task, our model has a \nword error rate (WER) of 5.51% when decoding with the \nbigram language model.  \nFor comparison purpose, we also built a simple monophone \nbased GMM-HMM system using the singing data of the \nNUS-48E corpus. Instead of the doing automatic alignment of \nthe training data, we fixed the phoneme boundary according \nto the human annotations during training. Similarly, this \nsinging GMM-HMM system also has 16 Gaussian for each \nstate.  \nBoth the speaking and singing waveform signals are \nprocessed with a 25ms time window and a shift of 10ms. \nTwelve dimensional MFCC features together with an energy \nterm are extracted from each time window. These 13 terms, \nalong with their first order and second order derivatives, make \nup the final, 39-dimensional feature vector.  \nA. \nPhoneme likelihood score comparison \nThe GMM-HMM system trained on the WSJ0 corpus \ncaptures the spectral characteristics of the speech signals, and \nwe used it to perform alignment on both the speech and \nsinging data in the NUS-48E corpus.  The alignment on \nsinging data was restricted with the manually labeled \nboundaries.  During both alignment tasks, the likelihood score \ngenerated by the GMM-HMM system were stored.  Since the \nsystem is trained on a speech corpus, it is expected to perform \nworse on singing data.  However, the difference between the \nlikelihood scores of singing and speech phonemes carries \nuseful information.  It can serve as an indirect measure of the \ndistance between the acoustic representation of the singing \nphoneme and that of the speech phoneme, i.e. a higher \ndifference between the likelihood scores implies greater \ndiscrepancy between the acoustic characteristics of the two \nsignals. \nThe likelihood score for each phoneme is a cumulative \nscore on all frames contained in that phoneme.  As durations \nof different phones vary significantly, the cumulative scores \ncould be misleading.  Thus we use the average likelihood \nscore, which is computed by dividing the cumulative score by \nthe frame count. \nThen, we define the Likelihood Difference (LD) as  \n \nLD = abs(ALSsinging \u2013 ALSspeech),                  (2) \n \nwhere ALSsinging and ALSspeech are the average likelihood \nscore for the singing phoneme and speech phoneme, \nrespectively.  As we only wished to gauge the extent of the \nlikelihood differences, the absolute value of the difference is \nused to avoid negative scores cancelling out positive ones. \nThe comparison of likelihood differences between singing \nand speech phonemes of all phoneme types are shown in Fig. \n9.  Results show that females have higher likelihood \ndifferences for all phoneme types, especially liquids, which \nimplies that there may be more differences in terms of \naccoustic features on female singing.  \nThe likelihood differences of affricates and fricatives are \nlower than the other categories, suggesting that the accoustic \nfeatures of these two phoneme types may be more similar \nbetween singing and speech. \nWhile the 39-dimentional MFCC feature vector preserves \nthe identity of the phoneme in question, it might have \nneglected information indicative of the difference between \nsinging and speech.  Therefore, likelihood difference is by no \nmeans a definitive measure on the differences of singing and \nspeech phonemes. However, our observations may provide \nclues for further studies. \nB. \nUnderstanding the effects of duration on MFCCs \nAs variations in phoneme duration is one of the major \ndifferences between speaking and singing, we conducted \npreliminary experiments to see if they affect the MFCC \nfeatures commonly used for speech analysis.  \nFor simplicity, we converted duration into a discrete \nvariable by dividing its whole value range into 10 bins with \nequal cumulative probability mass, i.e. each bin contains \naround 10% of the samples. Binning is carried out for each \nand every phoneme. We then estimate a single Gaussian to \nmodel the MFCC feature distribution for each bin of the \nphoneme. Ideally, there should be 390 different models, i.e. \n39 phonemes each having 10 duration bins.  Because the sung \nand spoken instances of a phoneme are binned together, the \nduration range of the sung instances could make it so that the \nspoken instances might not be distributed into all 10 bins, and \nvice versa. In the end, we obtained 348 separate models for \nspeech and 366 for singing.  \nWe then built decision trees to cluster these models \ntogether by asking questions based on the durations. For each \nphoneme, the 10 bins require 9 boundary values to split and \nhence 9 questions on the decision tree. The speech models \nand singing models are clustered separately. Clustering is \ncarried out at each step by selecting the question that \nincreases the data likelihood the most. If changes in a \nphoneme\u2019s MFCC features are affected by its duration, it \nwould be more difficult to reduce the number of model \nclusters across the duration range, resulting in a lower \nreduction rate after clustering. After the decision tree \n \nFig. 9  Mean Differences of Likelihood Scores for All Phoneme Categories \n\fclustering, we obtained 140 clusters for speech models and \n177 clusters for singing models. The relative model reduction \nrate is 59.78% and 51.64%, respectively.  \nC. \nUnderstanding the effects of pitch on MFCCs \nWe conducted the same set of experiments to evaluate the \neffects of pitch on the MFCC features. We also used 10 bins \nto discretize the pitch values and to ensure that all the bins \nhave balanced cumulative density masses. After binning, we \nobtained 334 models for speech and 342 for singing. After \ndecision tree building and clustering, the number of models \nwas reduced to 182 for speech and 259 for singing, yielding \nreduction rates of 45.51% and 24.27%, respectively. The \nreduction rate for singing data is much lower than that of \nspeaking data, especially when compared to the duration \nbased clustering, suggesting that pitch differences can bring \nmore variations to MFCC features. \nVI. CONCLUSION \nIn this paper, we introduce the NUS Sung and Spoken \nLyrics Corpus (NUS-48E Corpus), which is an ongoing effort \ntoward a comprehensive, well-annotated dataset for singing \nvoice related research.  The corpus contains: 12 subjects \nrepresenting various accents and extents of musical \nbackground; 48 songs with reasonably balanced phoneme \ndistribution.  To the best of our knowledge, the NUS-48E \ncorpus is the first singing voice dataset to offer annotations on \nthe phone level. \nUsing our corpus, we conducted a comparative study of \nsung and spoken lyrics.  Specifically, we investigated the \nduration and spectral characteristics of the phonemes in \nsinging and speech.  A preliminary analysis on the stretching \nratio of sung phonemes is presented.  Differences among \nstretching ratios of seven consonant categories are compared \nand the variations among subjects discussed.  We investigated \nthe syllabic proportion of consonants in sung lyrics with \nrespect to consonants types as well as consonant positions \nwithin the syllable.  Using a GMM-HMM system trained on a \nlarge speech corpus, we studied the difference between \nsinging and speech phonemes in terms of MFCC features. The \neffects of duration and pitch on acoustic features are also \ndiscussed.  The level of difference was measured through \nLikelihood Difference, which is based on the likelihood score \ngenerated by the GMM-HMM system. The effects of duration \nand pitch on MFCC features are examined by clustering \nacoustic models with decision trees. \nVII. FUTURE WORK \nWhile the NUS-48E corpus contains only 48 annotated \nsongs due to limitations on time and qualified manpower, we \nhave recorded a total of 420 song samples (21 subjects, each \nsinging all 20 songs in Table I).  On the one hand, we will \ncontinue to enlarge our corpus by annotating the remaining \nsongs. On the other hand, we will begin annotating the spoken \ndata in order to provide the ground truth for future \ncomparison studies.  Using the enlarged corpus, we would \nalso like to repeat some of the works mentioned in Section II \nto provide quantitative verifications for the observations \nreported in the literature. \nAs the comparison study presented in this paper is \npreliminary in nature, its results could be further explored and \nanalyzed.  Subsequent experiments will aim to answer the \nquestion and test the theory raised by the current observations, \nsuch as the differing syllabic proportions of consonants in \nmale subjects.  In the process, we hope to unearth new \nobservations and raise new questions that could advance the \ncommunity\u2019s understanding of the relationship between \nsinging voice and speech. Eventually, we seek to combine the \nknowledge gained from the corpus and the literature to better \nadapt state-of-the-art speech evaluation technologies for the \nsinging voice. \nACKNOWLEDGMENT \nThe authors deeply appreciate the assistance of Kenny \nYang and Amelia Dizon with phonetic annotation.  \nThis research is supported by the Singapore National \nResearch Foundation under its International Research Centre \n@ Singapore Funding Initiative and administered by the IDM \nProgramme Office.  \nREFERENCES \n[1] S. L. Medina, \u201cThe Effects of Music upon Second Language \nVocabulary Acquisition,\u201d Annual Meeting of the Teachers of \nEnglish to Speakers of Other Languages, March 1990. \n[2] M. L. Albert, R. W. Sparks, and N. A. Helm, \u201cMelodic \nintonation therapy for aphasia,\u201d Arch. Neurol., vol. 29, issue 2, \npp. 130-131, August 1973. \n[3] M. Mehrabani and J. H. Hansen, \u201cSinging speaker clustering \nbased on subspace learning in the GMM mean supervector space,\u201d \nSpeech Commun., vol. 55, issue 5, pp. 653-666, June 2013. \n[4] A. Mesaros and T. Virtanen, \u201cAutomatic recognition of lyrics in \nsinging,\u201d EURASIP J. Audio Speech Music Process., vol. 2010, \nFebruary 2010. \n[5] A. Loscos, P. Cano, and J. Bonada, \u201cLow-delay singing voice \nalignment to text,\u201d Proc. Int. Comput. Music Conf., vol. 1999, \npp. 437-440, 1999. \n[6] C.-L. Hsu and J.-S. R. Jang, \u201cOn the improvement of singing \nvoice separation for monaural recordings using the MIR-1K \ndataset,\u201d IEEE Trans. Audio Speech Lang. Process., vol. 18, \nissue 2, pp.310-319, February 2010. \n[7] J. Sundberg, The Science of the Singing Voice. DeKalb, IL: \nNorthern Illinois University Press, 1987. \n[8] Y. Ohishi, M. Goto, K. Itou, and K. Takeda, \u201cDiscrimination \nbetween singing and speaking voices,\u201d Proc. Eurospeech, vol. \n2005, pp. 1141-1144, September 2005. \n[9] M. Goto and T. Nishimura, \u201cAIST Humming Database: Music \ndatabase for singing research,\u201d The Special Interest Group \nNotes of IPSJ (MUS), vol. 82, pp.7-12, 2005. (in Japanese) \n[10] Y. Ohishi, M. Goto, K. Itou, and K. Takeda. \"On the human \ncapability and acoustic cues for discriminating the singing and \nthe speaking voices,\" Proc. Int. Conf. Music Percept. Cog., vol. \n2006, pp. 1831-1837, August 2006. \n[11] C. Wu and L. Gu. \"Robust singing detection in speech/music \ndiscriminator design,\" IEEE Int. Conf. Acoust. Speech Signal \nProcess. 2001, vol. 2, pp. 865-868, May 2001. \n[12] B. Schuller, B. J. B. Schmitt, D. Arsic, S. Reiter, M. Lang, and G. \nRigoll, \"Feature selection and stacking for robust discrimination \n\fof speech, monophonic singing, and polyphonic music,\" IEEE \nInt. Conf. Multimedia Expo, vol. 2005, pp.840-843, July 2005. \n[13] T. Saitou, M. Goto, M. Unoki, and M. Akagi. \"Speech-to-\nsinging synthesis: converting speaking voices to singing voices \nby controlling acoustic features unique to singing voices,\" IEEE \nWorks. Appl. Signal Process. Audio Acoust., vol. 2007, pp. 215218, October 2007. \n[14] T. L. New, M. Dong, P. Chan, X. Wang, B. Ma, and H. Li, \"Voice \nconversion: From spoken vowels to singing vowels,\" IEEE Int. \nConf. Multimedia Expo, vol. 2010, pp.1421-1426, July 2010. \n[15] S. Aso, T. Saitou, M. Goto, K. Itoyama, T. Takahashi, K. \nKomatani, T. Ogata, and H. G. Okuno, \"SpeakBySinging: \nConverting singing voices to speaking voices while retaining \nvoice timbre,\" Proc. Int. Conf. Digital Audio Effects (DAFx-10), \nvol. 2010, September 2010. \n[16] M. Goto, H. Hashiguchi, T. Nishimura, and R. Oka. \"RWC \nmusic database: Popular, classical, and jazz music databases,\" \nProc. Int. Conf. Music Inform. Retrieval (ISMIR), vol. 2, pp. \n287-288, October 2002. \n[17] CMU Pronouncing Dictionary, www.speech.cs.cmu.edu/cgi-\nbin/cmudict. \n\f", "text_mmd": "# The NUS Sung and Spoken Lyrics Corpus:\n\nA Quantitative Comparison of Singing and Speech\n\nZhiyan Duan, Haotian Fang, Bo Li, Khe Chai Sim and Ye Wang\n\nSchool of Computing, National University of Singapore, Singapore.\n\nE-mail: [zhiyan, fanght, li-bo, simkc, wangye]@comp.nus.edu.sg\n\n###### Abstract\n\nDespite a long-standing effort to characterize various aspects of the singing voice and their relations to speech, the lack of a suitable and publicly available dataset has precluded any systematic study on the quantitative difference between singing and speech at the phone level. We hereby present the NUS Sung and Spoken Lyrics Corpus (NUS-48E corpus) as the first step toward a large, phonetically annotated corpus for singing voice research. The corpus is a 169-min collection of audio recordings of the sung and spoken lyrics of 48 (20 unique) English songs by 12 subjects and a complete set of transcriptions and duration annotations at the phone level for all recordings of sung lyrics, comprising 25,474 phone instances. Using the NUS-48E corpus, we conducted a preliminary, quantitative study on the comparison between singing voice and speech. The study includes duration analyses of the sung and spoken lyrics, with a primary focus on the behavior of consonants, and experiments aiming to gauge how acoustic representations of spoken and sung phonemes differ, as well as how duration and pitch variations may affect the Mel Frequency Cepstral Coefficients (MFCC) features.\n\n## I Introduction\n\nIn audio signal analysis, it is important to understand the characteristics of singing voice and their relation to speech. A wide range of research problems, such as singing and speech discrimination and singing voice recognition, evaluation, and synthesis, stand to benefit from a more precise characterization of the singing voice. Better solutions to these research problems could then lead to technological advancements in numerous application scenarios, from music information retrieval and music edutainment to language learning [1] and speech therapy [2].\n\nGiven the similarity between singing and speech, many researchers classify the former as a type of the latter and try to utilize the well-established automatic speech recognition (ASR) framework to handle the singing voice [3][4][5]. Due to the lack of phonetically annotated singing datasets, models have been trained on speech corpora and then adapted to the singing voice. This approach, however, is intrinsically limited because the differences between singing and speech signals are not captured. Thus, a quantitative comparison of singing voice and speech could potentially improve the capability and robustness of current ASR systems in handling singing voice.\n\nDespite long-standing efforts to characterize various aspects of singing voice and their relations to speech [7][8], the lack of a suitable dataset has precluded any systematic quantitative study. Given that most existing models are statistics-based, an ideal dataset should not only have a large size but also exhibit sufficient diversity within the data. To explore the quantitative differences of singing and speech at the phone level, the research community needs a corpus of phonetically annotated recordings of sung and spoken lyrics by a diverse group of subjects.\n\nIn this paper, we introduce the NUS Sung and Spoken Lyrics Corpus (NUS-48E corpus for short), 48 English songs the lyrics of which are sung and read out by 12 subjects representing a variety of voice types and accents. There are 20 unique songs, each of which covered by at least one male and one female subject. The total length of audio recordings is 115 min for the singing data and 54 min for the speech data. All singing recordings have been phonetically transcribed with duration boundaries, and the total number of annotated phones is 25,474. The corpus marks the first step toward a large, phonetically annotated dataset for singing voice research.\n\nUsing the new corpus, we conducted a preliminary study on the quantitative comparison between sung and spoken lyrics. Unlike in speech, the durations of syllables and phonemes in singing are constrained by the music score. They have much larger variations and often undergo stretching. While vowel stretching is largely dependent on the tempo, rhythm, and articulation specified in the score, consonant stretching is much less well understood. We thus conducted duration analyses of the singing and speech data, primarily focusing on consonants. We also hope to better understand how one can borrow from and improve upon the state-of-the-art speech processing techniques to handle singing data. We thus carried out experiments to quantify how the acoustic representations of spoken and sung phonemes differ, as well as how variations in duration and pitch may affect the Mel Frequency Cepstral Coefficients (MFCC) features. The results of both the duration and spectral analyses are hereby presented and discussed.\n\nThe remainder of this paper is organized as follows. Section II provides an overview of existing datasets and related works on the differences between singing and speech. Section III describes the collection, annotation, and composition of the NUS-48E corpus. Section IV and V present the results of the duration analyses and spectral comparisons, respectively. Finally, Section VI and VII conclude this paper and suggest future work.\n\n### _Singing Voice Dataset_\n\nSinging datasets of various sizes and annotated contents are available for research purposes. To the best of our knowledge, however, none has duration annotations at the phoneme level.\n\nMesaros and Virtanen conducted automatic recognition of sung lyrics using 49 singing clips, 19 of which are from male singers and 30 from female singers [4]. Each clip is 20-30 seconds long, and the complete dataset amounts to approximately 30 minutes. Although a total of 4770 phoneme instances are present, the lyrics of each singing clip are manually transcribed only at the word level, without any duration boundaries.\n\nThe MIR-1K dataset [6] is a larger dataset consisting of 1000 clips from 110 unique Chinese songs as sung by 19 amateur singers, 8 of whom female. The total length of the singing clips is 133 minutes. Since this dataset is intended for singing voice separation, annotations consist of pitch, lyrics, unvoiced frame types, and vocal/non-vocal segmentation, but do not contain segmentation on the word level or below.\n\nAIST Humming Database (AIST-HDB) [9] is a large database for singing and humming research. The database contains a total of 125.9 hours of humming/singing/reading materials, recorded from 100 subjects. Each subject produced 100 excerpts of 50 songs chosen from the RWC Music Database (RWC-MDB) [16]. While the lyrics of the songs are known, neither the AIST-HDB nor the RWC-MDB provides any phoneme or word boundary annotation.\n\n### _Differences of Singing and Speech_\n\nObservations on differences of singing and speech have been reported and studied [7][8]. The three main differences lie in phoneme duration, pitch, and power. Constrained by the music score and performance conventions, the singing voice stretches phonemes, stabilizes pitches, and roams within a wider pitch range. The power changes with pitch in singing but not in speech.\n\nOhishi et al. studied the human capability in discriminating singing and speaking voices [10]. They reported that human subjects could distinguish singing and speaking with 70.0% accuracy for 200-ms signals and 99.7% for one-second signals. The results suggest that both temporal characteristics and short-term spectral features contribute to perceptual judgment. The same research group also investigated short-term MFCC features and long-term contour of the fundamental frequency (F0) in order to improve machine perform on singing-speaking discrimination [8]. F0 contour works better for signals longer than one second, while MFCC performs better on shorter signals. The combination of the short-term and long-term features achieved more than 90% accuracy for two-second signals.\n\nSince singing and speech are similar from various aspects, finding the right set of features to discriminate the two is crucial. A set of features derived from harmonic coefficient and its 4Hz modulation values are proposed in [11]. While in [12], a feature selection solution among 276 features is introduced.\n\n### _Conversion between Singing and Speech_\n\nThe conversion between speaking and singing has also attracted research interest. A system for speech-to-singing synthesis is described in [13]. By modifying the F0, phoneme duration, and spectral characteristics, the system can synthesize a singing voice with naturalness almost comparable to a real singing voice using a speaking voice and the corresponding text as input. A similar system is developed in [14] to convert spoken vowels into singing vowels. On the other hand, the SpeakBySinging [15] system converts a singing voice into a speaking voice while retaining the timbre of the singing voice.\n\n## III The NUS Sung and Spoken Lyrics Corpus\n\n### _Audio Data Collection_\n\n**Song Selection.** We selected twenty songs in English as the basis of our corpus (see Table I). They include well-known traditional songs and popular songs that have been regional and international hits, as well as several songs that may be less familiar but are chosen for their phonemic richness and ease of learning. In addition, lyrics of some songs, such as _Jingle Bells_ and _Twinkle Twinkle Little Star_, are expanded to include verses other than the most familiar ones to further enhance the phonemic richness of the corpus, while overly repetitive lines or instances of sant singing, such as those found in _Far Away from Home_ and _Lemon Tree_, are excised to better preserve phonemic balance. The list of songs and their selected lyrics are posted on our study website1.\n\nFootnote 1: [http://singingevaluation.wordpress.com/2012/11/22/songs-to-pick/](http://singingevaluation.wordpress.com/2012/11/22/songs-to-pick/)\n\n**Subject Profile.** We recruited 21 subjects, 9 males and 12 females, from the National University of Singapore (NUS) Choir and the amateur vocal community at NUS. All subjects are enrolled students or staff of the university. They are 21 to 27 years of age and come with a wide range of musical exposure, from no formal musical training to more than 10 years of vocal ensemble experience and vocal training. All four major voice types (soprano, alto, tenor, and bass) are represented, as well as a spectrum of English accents, from North American to the various accents commonly found in Singapore. Local accents tend to be less apparent in singing than in speaking, a phenomenon that becomes more marked as the subject's vocal experience increases. Subjects are all proficient speakers of English, if not native speakers.\n\n**Collection Procedure.** Subjects visited the study website to familiarize with the lyrics of all twenty songs before coming to our sound-proof recording studio (STC 50+) for data collection. An Audio-Technica 4050 microphone with pop filter was used for the recording. Audio data were collected at 16-bit and 44.1kHz using Pro Tools 9, which also generated a metronome with downbeat accent to set the tempi and to serve as a guide for singing. The metronome was fed to the subject via the headphone. The selected lyrics for all songs were printed and placed on a music stand by themicrophone for the subject's reference. Except metronome beats heard through the headphone, no other accompaniment was provided, and subjects were recorded a cappella.\n\nFor each song, the selected lyrics were sung first. While the tempo was set, the subject could choose a comfortable key and were free to make small alterations to rhythm and pitch. Then, the subject's reading of the lyrics was recorded on a separate track. When a track with all the lyrics clearly sung or spoken was obtained, the subject proceeded to the next song. A few pronunciation errors were allowed as long as the utterance remained clear. Except the occasional rustles of the lyrics printouts, miscellaneous noise was avoided or excised from the recording as much as possible.\n\nFor each subject, an average of 65 minutes of audio data was thus collected in 20 singing (~45min) and 20 reading tracks (~20min). Each track was then bounced from Pro Tools as a wav file for subsequent storage, annotation, and audio analyses. At the end of the recording session, we reimbursed each subject with a SS50 gift voucher for the university co-op store.\n\n### _Data Annotation_\n\nWe adopted the 39-phoneme set used by the CMU Dictionary (see Table II) for phonetic annotation [17]. Three annotators used Audacity to create a label track for each audio file, and labeled phones and their timestamps are exported as a text file. Phones were labeled not according to their dictionary pronunciation in American English but as they had been uttered. This was done to better capture the effect of singing as well as the singer's accent on the standard pronunciation. We also included two extra labels, _sil_ and _sp_, to mark the lengths of silence or inhalation between words (and, occasionally, between phones mid-word) and all duration-less word boundaries, respectively (see Fig. 1). Labels of one annotator were checked by another to ensure inter-rater consistency.\n\n### _Corpus Composition_\n\nDue to the time-consuming nature of phonetic transcription and the limitations on manpower, for the first version of the corpus we only manually annotated the singing data of 12 subjects. They include 6 males and 6 females and represent all voice types and accent types (see Table III). For each subject, we selected 4 songs to annotate. To ensure that all 20 songs were annotated at least once for both genders and that the number of annotated phones for each subject remained roughly equal, we ranked the songs by the number of phones estimated using the CMU Dictionary and assigned them accordingly (see Table I). At this stage, each subject hasaround 2100 phones annotated, and the corpus contains a total of 25,474 phone instances.\n\nAnnotation for spoken lyrics is generated by aligning the manually-labeled phone strings of the sung lyrics to the spoken lyrics using conventional Gaussian Mixture Model (GMM) - Hidden Markov Model (HMM) system trained on the Wall Street Journal (WSJ0) corpus (see Sec. 5 for details). While numerous discrepancies might exist between the actual sung and spoken versions, arising from the articulatory peculiarities of subjects and the differing methods of alignment, the annotated spoken lyrics allow us to make broad and preliminary observations about the extent of phonemic stretching between sung and spoken lyrics. As part of our future work, we will expand our corpus to include manual annotations of the spoken lyrics.\n\n## IV Duration Analysis\n\n### _Consonants Stretching_\n\nIn singing, vowels are stretched to maintain musical notes for certain durations, and their durations are to a large extent dictated by the score. While the stretching of vowels is much more pronounced, consonants are nevertheless stretched at a non-trivial level (see Fig. 2). As the factors influencing consonant duration are less apparent than those for vowels, we will explore not only how much stretching takes place but also what may affect the amount of stretching.\n\nThe stretching ratio is computed as follows,\n\n\\[sr=T_{s\\mathit{s\\mathit{s\\mathit{s\\mathit{s\\mathit{s\\mathit{s\\mathit{s\\mathit{s \\mathit{s\\mathit{s\\mathit{s\\mathit{s\\mathit{s\\mathit{s\\mathit{s\\mathit{s\\mathit{s}}}}}}}}}}}}}}/T_{ speech}\\, \\tag{1}\\]\n\nwhere \\(sr\\) is the stretching ratio and \\(T_{\\mathit{s\\mathit{s\\mathit{s\\mathit{s\\mathit{s\\mathit{s\\mathit{s\\mathit{s \\mathit{s\\mathit{s\\mathit{s\\mathit{s\\mathit{s\\mathit{s\\mathit{s\\mathit{s\\mathit{s \\mathit{s\\mathit{s}}}}}}}}}}}}}}}\\) and \\(T_{\\mathit{speech}}\\) the durations of the phoneme in singing and the corresponding speech, respectively. The higher the \\(sr\\) value, the more the phoneme is stretched in singing.\n\nIn the speech-to-singing conversion system developed in [13], the authors use fixed ratios for different types of consonants. The ratios used are experimentally determined from observations of singing and speech signals. Using the NUS-48E corpus, we analyzed the stretching ratio of\n\nFig. 1: SIL and SP labels denoting boundaries\n\nFig. 2: Comparison on Duration Stretching of Vowels and Consonants in singing consonants. Given that the phoneme alignment on speech data is automatically generated with a speech recognizer while the phoneme boundaries on singing data are manually annotated, the results remain preliminary observations.\n\nAs shown in Fig. 3, among the 7 types of consonants compared, liquids, semivowels, and nasals exhibit larger stretching ratios (2.2371, 1.9852, and 1.7027, respectively.) This result conforms to the intuition that these types of sonorants could be sustained and articulated for a longer period of time than others types such as stops and affricates.\n\nAnother interesting question is how the consonants are stretched in syllables of various lengths. The length of the syllables may have an effect on the length of consonants. As shown in Fig. 4, when syllable length starts to grow, the stretching ratio of semivowels increases accordingly. After the syllable length reaches around 1 second, however, the stretching ratio of semivowels tends to decrease. Not surprisingly, since vowels are the dominant constituent of syllables, the stretching ratio of vowels keeps growing when syllables become longer.\n\nObservations on other types of consonants are similar to that discussed above for semivowels.\n\n### _Subject Variations on Consonants Stretching_\n\nAs observations in the previous section only describe an overarching trend across all consonants for all subjects, it is important to check whether individual subjects follow such a trend consistently. We first investigated the differences with respect to gender. Fig. 5 shows the probability density functions (PDF) for the stretching ratios of both gender groups. The difference between them is negligible, suggesting that consonant stretching ratio is gender-independent. Next, we compared individual subjects. For example, subjects 05 and 08 contributed the same 4 songs, _Do Re Mi_, _Jingle Bells_, _Moon River_, and _Lemon Tree_. Subject 05 is a female with Malay accent and has had two years of choral experience at the time of recording, while subject 06 is a male with northern Chinese accent and had no vocal training whatsoever. As Fig. 6 shows, the distributions of the consonant stretching ratios of the two subjects remain roughly the same despite individual differences in accent and musical exposure. Therefore, the extent of consonant stretching may be attributed more to the act of singing itself than any discrepancy in the vocal practice of the singers.\n\n### _Syllable Proportions of Consonants_\n\nSyllable proportions are calculated as quotients of the consonant durations and the syllable durations. A phone with longer duration might not take up a higher proportion as it may be part of a long syllable.\n\nFigure 7 shows the syllabic proportion for all consonant types and both gender groups. Overall, semivowels have the highest proportion while aspirates and stops have the lowest. With aspirates as the lone exception, the syllabic proportions of all consonant types are higher in males than in females.\n\nFig. 4: Comparison on Duration Stretching Ratio across Different Length of Syllables for Vowels and Semivowels\n\nFig. 3: Average Stretching Ratios of Seven Types of ConsonantsFurther observation confirms that the absolute duration lengths of both consonants and syllables are larger in male subjects. This is an unexpected and interesting phenomenon given the observation made in the last subsection, namely that consonant durations seem to be stretched to similar extents in subjects of both genders.\n\nThree factors could contribute to such a phenomenon. First, male and female subjects may have somewhat different duration distributions for consonants and vowels within the spoken syllables to begin with. Second, the stretching of sung vowels could exhibit gender-related discrepancies. Lastly, structure of the same syllable in the lyrics could be different between speech and singing, especially for subjects who would sing in a different accent. A dropped consonant or a diphthongized vowel could alter syllable makeup and affect syllable length. Once we have expanded our corpus to include phonetic annotations for the spoken lyrics, we plan to further our comparison study to examine these factors.\n\n### _Consonant Position and its Effect on Proportion_\n\nWithin a syllable, consonants may appear at different positions. For example, in the word _love_ (/l /ah/ /v/), consonant /l/ is located at the beginning of the word; while in _soul_ (/s /ow/ /l), it is at the end. We are interested to see whether this positioning has any effect on the syllabic proportion. We first defined four consonant positions:\n\n1. **Starting**: at the beginning of a word, e.g. /g/ in _go_\n2. **Preceding**: preceding a vowel, but not at the beginning of a word, e.g. /m/ in _small_\n3. **Succeeding**: succeeding a vowel, but not at the end of a word, e.g. /l/ in _angels_\n4. **Ending**: at the end of a word, e.g. /t/ in _at_\n\nWe compared the syllabic proportions for the seven consonant categories with respect to positioning. The results are shown in Fig. 8. Semivowels and stops at the starting position are much more prominent than those at the end, while the opposite is observed for affricates and nasals. The syllabic proportions of fricatives, aspirates and liquids are largely similar between the starting and ending position.\n\nFor all consonants, the proportion for preceding position is significantly lower than that of the starting one. The phenomenon is mirrored for the succeeding and ending positions, in which the latter is much more prominent than the former.\n\n## V Spectral Analysis\n\nAlthough we could build a conventional Gaussian Mixture Model (GMM) - Hidden Markov Model (HMM) system using the NUS-48E corpus, the performance is expected to be low mainly due to the following two factors: the limited amount of speech data and the variation of accents among the subjects. While few large, high-quality singing corpora are available for academic research, there are numerous standard speech corpora. We adopted the Wall Street Journal (WSJ0) corpus, a large collection of read speech with texts drawn from a machine-readable corpus of Wall Street Journal news,\n\nFigure 8: Proportion comparison of consonants in different positions\n\nFigure 6: Comparison on Consonants Duration Stretching Ratio of Subject 05 and Subject 08\n\nFigure 7: Mean syllabic proportions for different types of consonants\n\nto train our speech GMM-HMM system, which is built to maximize the likelihood of the training data using the Hidden Markov Model Toolkit (HTK). The system adopts the CMU phoneme set used in the NUS-48E corpus and has a total of 2419 tied triphone states to model the various phoneme realizations in different acoustic contexts. Each state is modeled by a GMM with 16 components. On the benchmark 5k close vocabulary speech recognition task, our model has a word error rate (WER) of 5.51% when decoding with the bigram language model.\n\nFor comparison purpose, we also built a simple monophone based GMM-HMM system using the singing data of the NUS-48E corpus. Instead of the doing automatic alignment of the training data, we fixed the phoneme boundary according to the human annotations during training. Similarly, this singing GMM-HMM system also has 16 Gaussian for each state.\n\nBoth the speaking and singing waveform signals are processed with a 25ms time window and a shift of 10ms. Twelve dimensional MFCC features together with an energy term are extracted from each time window. These 13 terms, along with their first order and second order derivatives, make up the final, 39-dimensional feature vector.\n\n### _Phoneme likelihood score comparison_\n\nThe GMM-HMM system trained on the WSJ0 corpus captures the spectral characteristics of the speech signals, and we used it to perform alignment on both the speech and singing data in the NUS-48E corpus. The alignment on singing data was restricted with the manually labeled boundaries. During both alignment tasks, the likelihood score generated by the GMM-HMM system were stored. Since the system is trained on a speech corpus, it is expected to perform worse on singing data. However, the difference between the likelihood scores of singing and speech phonemes carries useful information. It can serve as an indirect measure of the distance between the acoustic representation of the singing phoneme and that of the speech phoneme, i.e. a higher difference between the likelihood scores implies greater discrepancy between the acoustic characteristics of the two signals.\n\nThe likelihood score for each phoneme is a cumulative score on all frames contained in that phoneme. As durations of different phones vary significantly, the cumulative scores could be misleading. Thus we use the average likelihood score, which is computed by dividing the cumulative score by the frame count.\n\nThen, we define the _Likelihood Difference (LD)_ as\n\n\\[LD=abs(ALS_{\\textit{singing}}-ALS_{\\textit{speech}}), \\tag{2}\\]\n\nwhere \\(ALS_{\\textit{singing}}\\) and \\(ALS_{\\textit{speech}}\\) are the average likelihood score for the singing phoneme and speech phoneme, respectively. As we only wished to gauge the extent of the likelihood differences, the absolute value of the difference is used to avoid negative scores cancelling out positive ones.\n\nThe comparison of likelihood differences between singing and speech phonemes of all phoneme types are shown in Fig. 9. Results show that females have higher likelihood differences for all phoneme types, especially liquids, which implies that there may be more differences in terms of acoustic features on female singing.\n\nThe likelihood differences of affricates and fricatives are lower than the other categories, suggesting that the acoustic features of these two phoneme types may be more similar between singing and speech.\n\nWhile the 39-dimentional MFCC feature vector preserves the identity of the phoneme in question, it might have neglected information indicative of the difference between singing and speech. Therefore, likelihood difference is by no means a definitive measure on the differences of singing and speech phonemes. However, our observations may provide clues for further studies.\n\n### _Understanding the effects of duration on MFCCs_\n\nAs variations in phoneme duration is one of the major differences between speaking and singing, we conducted preliminary experiments to see if they affect the MFCC features commonly used for speech analysis.\n\nFor simplicity, we converted duration into a discrete variable by dividing its whole value range into 10 bins with equal cumulative probability mass, i.e. each bin contains around 10% of the samples. Binning is carried out for each and every phoneme. We then estimate a single Gaussian to model the MFCC feature distribution for each bin of the phoneme. Ideally, there should be 390 different models, i.e. 39 phonemes each having 10 duration bins. Because the sung and spoken instances of a phoneme are binned together, the duration range of the sung instances could make it so that the spoken instances might not be distributed into all 10 bins, and vice versa. In the end, we obtained 348 separate models for speech and 366 for singing.\n\nWe then built decision trees to cluster these models together by asking questions based on the durations. For each phoneme, the 10 bins require 9 boundary values to split and hence 9 questions on the decision tree. The speech models and singing models are clustered separately. Clustering is carried out at each step by selecting the question that increases the data likelihood the most. If changes in a phoneme's MFCC features are affected by its duration, it would be more difficult to reduce the number of model clusters across the duration range, resulting in a lower reduction rate after clustering. After the decision tree\n\nFig. 9: Mean Differences of Likelihood Scores for All Phoneme Categoriesclustering, we obtained 140 clusters for speech models and 177 clusters for singing models. The relative model reduction rate is 59.78% and 51.64%, respectively.\n\n### _Understanding the effects of pitch on MFCCs_\n\nWe conducted the same set of experiments to evaluate the effects of pitch on the MFCC features. We also used 10 bins to discretize the pitch values and to ensure that all the bins have balanced cumulative density masses. After binning, we obtained 334 models for speech and 342 for singing. After decision tree building and clustering, the number of models was reduced to 182 for speech and 259 for singing, yielding reduction rates of 45.51% and 24.27%, respectively. The reduction rate for singing data is much lower than that of speaking data, especially when compared to the duration based clustering, suggesting that pitch differences can bring more variations to MFCC features.\n\n## VI Conclusion\n\nIn this paper, we introduce the NUS Sung and Spoken Lyrics Corpus (NUS-48E Corpus), which is an ongoing effort toward a comprehensive, well-annotated dataset for singing voice related research. The corpus contains: 12 subjects representing various accents and extents of musical background; 48 songs with reasonably balanced phoneme distribution. To the best of our knowledge, the NUS-48E corpus is the first singing voice dataset to offer annotations on the phone level.\n\nUsing our corpus, we conducted a comparative study of sung and spoken lyrics. Specifically, we investigated the duration and spectral characteristics of the phonemes in singing and speech. A preliminary analysis on the stretching ratio of sung phonemes is presented. Differences among stretching ratios of seven consonant categories are compared and the variations among subjects discussed. We investigated the syllabic proportion of consonants in sung lyrics with respect to consonants types as well as consonant positions within the syllable. Using a GMM-HMM system trained on a large speech corpus, we studied the difference between singing and speech phonemes in terms of MFCC features. The effects of duration and pitch on acoustic features are also discussed. The level of difference was measured through _Likelihood Difference_, which is based on the likelihood score generated by the GMM-HMM system. The effects of duration and pitch on MFCC features are examined by clustering acoustic models with decision trees.\n\n## VII Future Work\n\nWhile the NUS-48E corpus contains only 48 annotated songs due to limitations on time and qualified manpower, we have recorded a total of 420 song samples (21 subjects, each singing all 20 songs in Table I). On the one hand, we will continue to enlarge our corpus by annotating the remaining songs. On the other hand, we will begin annotating the spoken data in order to provide the ground truth for future comparison studies. Using the enlarged corpus, we would also like to repeat some of the works mentioned in Section II to provide quantitative verifications for the observations reported in the literature.\n\nAs the comparison study presented in this paper is preliminary in nature, its results could be further explored and analyzed. Subsequent experiments will aim to answer the question and test the theory raised by the current observations, such as the differing syllabic proportions of consonants in male subjects. In the process, we hope to unearth new observations and raise new questions that could advance the community's understanding of the relationship between singing voice and speech. Eventually, we seek to combine the knowledge gained from the corpus and the literature to better adapt state-of-the-art speech evaluation technologies for the singing voice.\n\n## Acknowledgment\n\nThe authors deeply appreciate the assistance of Kenny Yang and Amelia Dizon with phonetic annotation.\n\nThis research is supported by the Singapore National Research Foundation under its International Research Centre _(a)_ Singapore Funding Initiative and administered by the IDM Programme Office.\n\n## References\n\n* [1] S. L. Medina, \"The Effects of Music upon Second Language Vocabulary Acquisition,\" _Annual Meeting of the Teachers of English to Speakers of Other Languages_, March 1990.\n* [2] M. L. Albert, R. W. Sparks, and N. A. Helm, \"Melodic intonation therapy for aphasia,\" _Arch. Neurol._, vol. 29, issue 2, pp. 130-131, August 1973.\n* [3] M. Mehrabani and J. H. Hansen, \"Singing speaker clustering based on subspace learning in the GMM mean supervector space,\" _Speech Commun._, vol. 55, issue 5, pp. 653-666, June 2013.\n* [4] A. Mesaros and T. Virtanen, \"Automatic recognition of lyrics in singing,\" _EURASIP J. Audio Speech Music Process._, vol. 2010, February 2010.\n* [5] A. Loscos, P. Cano, and J. Bonada, \"Low-delay singing voice alignment to text,\" _Proc. Int. Comput. Music Conf._, vol. 1999, pp. 437-440, 1999.\n* [6] C.-L. Hsu and J.-S. R. Jang, \"On the improvement of singing voice separation for monaural recordings using the MIR-1K dataset,\" _IEEE Trans. Audio Speech Lang. Process._, vol. 18, issue 2, pp.310-319, February 2010.\n* [7] J. Sundberg, _The Science of the Singing Voice_. DeKalb, IL: Northern Illinois University Press, 1987.\n* [8] Y. Ohishi, M. Goto, K. Itou, and K. Takeda, \"Discrimination between singing and speaking voices,\" _Proc. Eurospeech_, vol. 2005, pp. 1141-1144, September 2005.\n* [9] M. Goto and T. Nishimura, \"AIST Humming Database: Music database for singing research,\" _The Special Interest Group Notes of IPS/ (MUS)_, vol. 82, pp.7-12, 2005. (in Japanese)\n* [10] Y. Ohishi, M. Goto, K. Itou, and K. Takeda. \"On the human capability and acoustic cues for discriminating the singing and the speaking voices,\" _Proc. Int. Conf. Music Percept. Cog._, vol. 2006, pp. 1831-1837, August 2006.\n* [11] C. Wu and L. Gu. \"Robust singing detection in speech/music discriminator design,\" _IEEE Int. Conf. Acoust. Speech Signal Process. 2001_, vol. 2, pp. 865-868, May 2001.\n* [12] B. Schuller, B. J. B. Schmitt, D. Arsic, S. Reiter, M. Lang, and G. Rigoll, \"Feature selection and stacking for robust discrimination of speech, monophonic singing, and polyphonic music,\" _IEEE Int. Conf. Multimedia Expo_, vol. 2005, pp.840-843, July 2005.\n* [13] T. Saitou, M. Goto, M. Unoki, and M. Akagi. \"Speech-to-singing synthesis: converting speaking voices to singing voices by controlling acoustic features unique to singing voices,\" _IEEE Works. Appl. Signal Process. Audio Acoust._, vol. 2007, pp. 215-218, October 2007.\n* [14] T. L. New, M. Dong, P. Chan, X. Wang, B. Ma, and H. Li, \"Voice conversion: From spoken vowels to singing vowels,\" _IEEE Int. Conf. Multimedia Expo_, vol. 2010, pp.1421-1426, July 2010.\n* [15] S. Aso, T. Saitou, M. Goto, K. Itoyama, T. Takahashi, K. Komatani, T. Ogata, and H. G. Okuno, \"SpeakBySinging: Converting singing voices to speaking voices while retaining voice timbre,\" _Proc. Int. Conf. Digital Audio Effects (DAFx-10)_, vol. 2010, September 2010.\n* [16] M. Goto, H. Hashiguchi, T. Nishimura, and R. Oka. \"RWC music database: Popular, classical, and jazz music databases,\" _Proc. Int. Conf. Music Inform. Retrieval (ISMIR)_, vol. 2, pp. 287-288, October 2002.\n* [17] CMU Pronouncing Dictionary, www.speech.cs.cmu.edu/cgi-bin/cmudict."}, "BIBREF354": {"title": "Virtuosonet: A hierarchical rnn-based system for modeling expressive piano performance", "authors": [{"first": "Dasaem", "middle": [], "last": "Jeong1", "suffix": ""}, {"first": "Taegyun", "middle": [], "last": "Kwon1", "suffix": ""}, {"first": "Yoojin", "middle": [], "last": "Kim1", "suffix": ""}, {"first": "Kyogu", "middle": [], "last": "Lee2", "suffix": ""}, {"first": "Juhan", "middle": [], "last": "Nam1", "suffix": ""}], "venue": "ISMIR", "volume": "", "issue": "", "pages": "908--915", "text_pymu": "VirtuosoNet: A HIERARCHICAL RNN-BASED SYSTEM FOR MODELING\nEXPRESSIVE PIANO PERFORMANCE\nDasaem Jeong1\nTaegyun Kwon1\nYoojin Kim1\nKyogu Lee2\nJuhan Nam1\n1 Graduate School of Culture Technology, KAIST , Korea\n2 Graduate School of Convergence Science and Technology, Seoul National University, Korea\n{jdasam, ilcobo2, luciaicul}@kaist.ac.kr, kglee@snu.ac.kr, juhannam@kaist.ac.kr\nABSTRACT\nIn this paper, we present our application of deep neural\nnetwork to modeling piano performance, which imitates\nthe expressive control of tempo, dynamics, articulations\nand pedaling from pianists. Our model consists of recurrent neural networks with hierarchical attention and conditional variational autoencoder. The model takes a sequence\nof note-level score features extracted from MusicXML as\ninput and predicts piano performance features of the corresponding notes. To render musical expressions consistently\nover long-term sections, we first predict tempo and dynamics in measure-level and, based on the result, refine them\nin note-level. The evaluation through listening test shows\nthat our model achieves a more human-like expressiveness\ncompared to previous models. We also share the dataset we\nused for the experiment.\n1. INTRODUCTION\nMusic performance is one of the most essential activities\nin music. Good performance requires not only translating\nnotes in the score into physical actions with precise timing\nand right pitch on an instrument but also delivering emotions and messages through subtle controls of tempo, dynamics, articulations and other expressive elements.\nThere have been research interests in modeling expressive performance using a computational method. A recent review paper comprehensively summarized the history [4]. While some of previous work exploited computational modeling as a tool for understanding how humans perform [3], or listen to music [10], others focused\non automatically generating expressive performances. The\nprevious methods include rule-based approaches [2, 8], or\nprobabilistic models [17, 29], and an artificial neural network [5,11]. The instrument is mainly limited to piano because it is relatively easy to quantify the performances.\nc\u20dd Dasaem Jeong, Taegyun Kwon, Yoojin Kim, Kyogu Lee,\nJuhan Nam. Licensed under a Creative Commons Attribution 4.0 International License (CC BY 4.0). Attribution: Dasaem Jeong, Taegyun\nKwon, Yoojin Kim, Kyogu Lee, Juhan Nam. \u201cVirtuosoNet: A Hierarchical RNN-based system for modeling expressive piano performance\u201d, 20th\nInternational Society for Music Information Retrieval Conference, Delft,\nThe Netherlands, 2019.\nRecent approaches have attempted to apply deep learning to modeling expressive piano performance, such as\nrendering note velocity and deviation of note onset with\nvanilla recurrent neural network (RNN) [20], or predicting note velocity with a long short-term memory (LSTM)\nRNN [22]. Others introduced DNN models for generating polyphonic music with expressive timing and dynamics [13,24]. While these models can generate performance\nMIDI notes, they are more like music composition models\nrather than expressive performance models that take music scores as input. Besides piano performance, a recent\nwork presented DNN-based system for modeling expressive drum performance [9].\nOne of the bottlenecks in the DNN-based approach is\nthe lack of dataset [4]. Since the task is rendering expressive performances from score inputs, the dataset should\nconsist of music scores and their corresponding performances by human musicians. Furthermore, the pair of\nscore and performance should be aligned in note-level to\neffectively train the model. Also, ideally, the list of music score and performance should cover various composers\nand performance styles.\nIn this paper, we present a hierarchical RNN-based\nmodel for expressive piano performance along with a\ndataset that we organized. The model takes MusicXML\nas input and generates performance MIDI with expressive\ntempo, dynamics, articulation and pedaling. The model\nconsists of RNN with hierarchical attention network and\nconditional variational autoencoder (CVAE). In particular,\nthe model predicts the performance features using a multiscale approach; it first predicts tempo and dynamics in\nmeasure-level and, based on the result, fine-tunes them in\nnote-level. A listening test with professional pianists shows\nthat our model achieves a more human-like expressiveness\ncompared to previous models.\n2. DATASET\n2.1 Performance and Score Data\nAs aforementioned, we need a dataset of human performances with their corresponding music scores to train a\nneural network model. A list of expressive performance\ndatasets are summarized in [4]. Among others, Yamaha\n908\n\fSignature MIDI collection 1 , which are recorded during\nYamaha e-Competitions with computer-controlled pianos,\nis the largest public dataset that provides a substantial\namount of expressive performance MIDI of professional\npianists. Some of the pianists performed the same piece\nmore than once in different rounds of the competition in\ndifferent years. The Yamaha collection has been employed\nin automatic performance generation [24] and automatic\nmusic transcription and audio synthesis [12] as well.\nWhile the Yamaha collection provides high-quality piano performance data in MIDI, it does not contain the corresponding music scores of the pieces. Thus, we collected\nthe score files from another source. Specifically, we downloaded them from MuseScore, a community-based web\nplatform of music score 2 . The scores were transcribed voluntarily by the community users and can be exported in\nMusicXML format. We also included our own transcriptions of scores to the dataset. While MIDI is suitable for\nrepresenting performance, MusicXML aims to represent\nthe Western music notation in its entirety. Therefore, MusicXML can contain various types of musical symbols such\nas rest, slur, beam, barline, key and time signature, articulation, ornament markings and so on, which are excluded\nin MIDI format.\n2.2 Data Matching and Refinement\nSince we collected the performance and score data from\ndifferent sources, we had to match and refine them. In\nparticular, transcription styles in the crowdsourced MusicXML files are not consistent. For example, some of\nthe transcribers add extra expressions such as dynamics markings or tempo change to make the score sounds\nmore expressive. They usually set them to \u201cinvisible objects\u201d to make the transcribed score appear as the reference score. We deleted such extra markings added by transcribers. Also, we manually checked whether the performances followed the repetitions in the scores. If a performance skipped the repetition, we omitted the repetition\nfrom the score so that the performance and the score can\nbe aligned.\nTo train a model with note-level score features and\nperformance features, each note in the score should be\nmatched to that in the performance. We employed a scoreto-performance alignment algorithm proposed by Nakamura et al. [23]. The algorithm automatically handles asynchronously performed notes as well as missing and extra\nnotes in the performance, and returns a list of note-to-note\nmatches. Although the algorithm showed high accuracy in\nour test, a small amount of alignment errors can be critical\nin extracting performance features such as tempo or onset\ndeviation. Since the dataset is too large to make manual\ncorrections, we filtered out some erroneous matches based\non simple rules and excluded them in training the performance model. For example, if a matched performance note\nis too close or even earlier than the previous note in the\nscore, we regarded it as an alignment error. Also, if multi-\n1 http://www.yamahaden.com/midi-files\n2 https://musescore.com\nple notes have the same onset time in the score (e.g., chord\nnotes) but one is too far from other notes in performance,\nwe regarded it as an alignment error as well.\nWe found that this additional refinement made severe\nimprovement on the training result, especially on onset deviation, or micro-timing, of individual notes. The standard\ndeviation of onset deviation decreases from 7.369 to 0.053\nafter the refinement, where the unit is quarter-notes. Without the refinement, the prediction of onset deviation became too noisy that one could not perceive correct rhythm.\nAs a result, we collected music scores of 226 pieces\nby 16 composers in MusicXML and 1,052 piano performances in MIDI. After the matching and refinement, the\nscore and performance data contain a total of 666,918\nnotes and 3,547,683 notes, respectively. Among the performance notes, 131,095 notes were failed to be aligned\nwith score notes, and additional 114,914 notes were excluded by our refinement algorithm. The number of valid\nperformance notes is ten times larger than the Magaloff\ncorpus [7], which is the largest existing dataset for classical piano music [4].\n3. SYSTEM ARCHITECTURE\n3.1 Background\n3.1.1 Input and Output Features\nDesigning input and output features is an important issue in\nperformance modeling because it defines the characteristics of the computational task [4]. We followed the scheme\nwe previously proposed in [15], which covers a wide range\nof score and performance features. The score features include pitch, duration, articulation marking, slur and beam\nstatus, tempo marking, dynamic markings, and so on. The\nperformance features include absolute tempo, velocity, onset deviation, articulation and pedal usages. All the features\nare encoded in the note-level so that each note had the same\ndimension of score features and performance features.\n3.1.2 Hierarchical Attention Network\nRecent research has shown that a hierarchical approach can\nimprove the performance of RNN model in modeling sequential data [6, 30]. It was also demonstrated that the hierarchical approach has advantages in generating symbolic\nmusic data [25]. In this paper, we employ a hierarchical\nattention network (HAN) to predict a sequence of performance features from a sequence of score features.\nThe HAN composes higher-level representations by\nsummarizing lower-level representations in pre-defined hierarchical boundaries using a weighted sum. In our case,\nwe set beat and measure as the hierarchical boundaries so\nthat beat-level attention and measure-level attention summarize note-level and beat-level representations, respectively. Instead of directly implementing the HAN in [30],\nwe combined it with the idea of multi-head attention [28]\nwhich splits the dimension into several heads and applies\ndifferent weights of attention for each split.\nComposing nodes through the attention layers can be\ndescribed as follows. For each hierarchical boundary,\nProceedings of the 20th ISMIR Conference, Delft, Netherlands, November 4-8, 2019\n909\n\fFigure 1. The overview of the proposed system.\nwhich can be a beat or a measure in music score, the notes\nin the boundary can be indexed with t \u2208 [Bf, Bl], where\nBf and Bl represent the index of the first and last notes in\nthe selected boundary B. The lower-level hidden states ht\nfor t in the boundary B are summarized by context attention to compose a higher-level node m. There are a total I\nnumber of attention heads indexed with i.\nut = tanh(Waht + ba)\nui\nt = ut,i:(i+1)d\nhi\nt = ht,i:(i+1)d\n\u03b1\u03b1\u03b1i\nv =\nexp(ui\nt\n\u22baui\nc)\n\ufffd\nt exp(ui\nt\u22bauic)\nmi =\n\ufffd\nt\n\u03b1\u03b1\u03b1i\nt \u2217 hi\nt\nm = Concat(m0, ..., mI)\n(1)\nwhere Wa and ba denote weight and bias parameters of attention, and uc denotes a context vector representing query\nfor importance, which are trainable parameters. The sequence of summarized nodes are fed into a new layer of\nLSTM.\n3.1.3 Conditional VAE\nA music score can be interpreted and performed in various\nstyles, i.e. with a different tempo or phrasing. Therefore it\nis important to enable the performance modeling system to\ngenerate different types of performance. On the other hand,\nthe variation of performance can be an obstacle for training the model, because it has to generate different outputs\nfrom the same input. To solve this problem we employed\na conditional variational autoencoder (CVAE), which we\nproposed in our previous work [14].\nVAE is a widely used generative models based on deep\nneural networks [19]. It is a type of autoencoder, which\ncompresses input information into a lower dimensional latent vector and decodes the original information from the\ncompressed latent vector. The main difference is that VAE\nconstrains its latent vector to be sampled from a probability distribution. VAE consists of an encoder that models\nq(z|x) and decoder to model p(x|z). VAE also models the\nprobability of latent vector p(z), which usually has a normal distribution. The training loss of VAE can be define as\nfollows:\nLVAE = Lrec + \u03b2DKL[(q(z|x)||p(z)]\n(2)\nwhere Lrec is the reconstruction error from AE, DKL is\nKullback-Leibler divergence (KLD), and \u03b2 is a weight for\nthe KLD.\nFigure 2. Diagram for Score Encoder with HAN and RNN\nA conditional VAE (CVAE) provides an additional condition so that the output satisfies the given condition [27].\nIn our system, the condition is the learned score representation, and the target output are the performance features.\nThe idea of employing CVAE for expressive performance\nmodeling was first proposed in [21]. While the previous\nwork encoded the latent vector in note-level, our idea is to\nencode the performance style in a longer-level, such as an\nentire piece.\n3.2 Proposed System\nOur proposed system consists of three parts: score encoder, performance encoder, and performance decoder as\ndepicted in Figure 1.\nThe role of score encoder is to learn score representations C from an input sequence of notes. It consists of three\nhierarchical-levels: note, beat, and measure. Each level has\na corresponding bidirectional LSTM unit with a different\nhidden size and number of layers. The note-level layer consists of two different LSTM units, one taking the input as\na single sequence, and the other taking the input as voiceseparated sequences. The \u201cvoice\u201d means the voice index in\nMusicXML that represents an independent stream of music as depicted with different colors of notes in Figure 2.\nThe hidden representations of the lower-level are summarized through the HAN to compose higher-level nodes. The\noutput of the note-level LSTM is summarized to beat-level\nnodes and then they are fed into the beat-level LSTM. Similarly, we compose the measure-level LSTM. We concatenate the outputs of all the three layers in a note-level as\ndepicted in Figure 2. The output of score encoder is a sequence with the same length as the input. Since we use\nmulti-head attention instead of single-head attention, each\nattention head focuses on the different type of notes as illustrated in Figure 3.\nWe implemented the performance encoder using CVAE\nthat models q(z|C, y) to summarize the given performance\ny in score condition C to a probability distribution of the\nProceedings of the 20th ISMIR Conference, Delft, Netherlands, November 4-8, 2019\n910\n\fFigure 3. Visualization of attention weights from different\nattention heads. a) focuses more on the melody notes while\nb) focuses more on the bass or harmonic notes.\nFigure 4. The figure shows how the beat-level decoder\nand the note-level decoder feed its results to the other. The\ndashed lines in red indicate the edge of beats.\nlatent vector z, which can be regarded as a performance\nstyle vector. C and y are concatenated and fed into a single\ndense layer that contracts the feature dimension. We use\nuni-directional note-level LSTM and measure-level HANLSTM to process the contracted input. The last output of\nthe sequence from the measure-level LSTM is used to infer\n\u00b5 and \u03c3 of q(z|C, y) by a dense layer.\nDuring the actual performance generation from a given\nscore, the performance encoding is bypassed, and the system randomly samples the style vector z from a normal\ndistribution or exploits a pre-encoded z from other performances.\nThe performance decoder uses LSTMs to generate a sequence of performance features \u02c6y for the given condition C\nand the style vector z. Since the tempo is always estimated\nin beat level, we have two different LSTM units, one in\nthe beat-level and the other in the note-level. Both LSTMs\nare in auto-regressive, i.e., take their own output from the\nprevious step as an input, and the outputs of the note-level\ndecoder is fed into the beat-level decoder, and vice versa,\nas presented in Figure 4.\n3.3 Measure-level Module\nOne of the main difficulties in expressive performance\nmodeling is achieving long-term expression such as gradual change of tempo or contrast between loud and quiet\nsections. To solve this problem, we propose an optional\nmeasure-level module that predicts measure-level tempo\nand dynamics as presented in Figure 5. The main idea is\nto make our system predict overall progress of the perfor-\nFigure 5. Diagram for Measure-level modules\nmance in measure-level and then refine it in note-level. A\nsimilar idea achieved a successive result in image generation using GAN, which started training in a low resolution\nand progressively in higher resolutions [16].\nTo train the measure-level module, we have to define measure-level performance features. The measurelevel tempo is defined by elapsed time to play the measure divided by the length of the measure in quarter-notes.\nWe used average velocities of notes in the measure for a\nmeasure-level dynamics. The measure-level module has almost the same architecture with the note-level modules except that the output of the score encoder is the measurelevel states instead of concatenated result of note, beat and\nmeasure hidden states. The performance encoder and decoder are also in measure level.\nIn this hierarchical approach, the note-level module\ntakes not only the score data but also the output of the\nmeasure-level module as a concatenated input. It is possible to combine two modules as a single model or in a\nsingle training process, but we made two modules independent and trained them separately. Therefore, the note-level\nmodule is trained with ground-truth measure-level outputs.\n4. EXPERIMENTS\n4.1 Training\nWe split the dataset into training, validation, and test sets\nso that each set has a size of approximately 8:1:1 in the\nnumber of piece, performance, and notes, while considering the distribution of composers in each set. A single piece\nwas included only in either of one of the splits. For the\ntraining set, we sliced the input sequences at the measure\nboundaries with the least size of 500 notes. When training\nthe measure-level module, the sequence has at least 2000\nnotes or entire notes if the piece is short. The note is ordered by its appearance order and pitch. The features with\ncontinuous value was normalized to have zero mean and\nunit standard deviation.\nWe calculated the loss in mean square error (MSE) between each feature. The loss was calculated for each note\nand each output features, except the tempo, whose loss was\ncalculated in beat level. During the training, the input sequences included all the notes that have non-matching performance notes, because missing notes in the input data\ncan change the context of the other notes in the score. However, these notes were excluded in the loss calculation because we could not extract performance features for the\nnotes. Since the articulation is largely affected by the sustain pedal, we reduced the weight for the articulation loss\nto 0.1 for notes with the sustain pedal pressed at the offset.\nProceedings of the 20th ISMIR Conference, Delft, Netherlands, November 4-8, 2019\n911\n\fModel\nTempo\nVel\nDev\nArtc\nPedal\nBaseline\n0.400\n0.673\n0.773\n0.721\n0.843\nHAN-S\n0.269\n0.607\n0.753\n0.688\n0.820\nHAN-M\n0.220\n0.532\n0.747\n0.754\n0.810\nTable 1. Reconstruction loss of each model on the test set\nin MSE. Vel, Dev and Artc denote velocity, onset deviation\nand articulation, respectively.\nWe used the ADAM optimizer [18] with an initial learning rate of 0.0003 and dropout ratio of 0.1. To avoid that\nthe system bypasses z during the decoding, we use the\nKLD weight annealing as proposed in [1], so that the KLD\nweight started from zero at the beginning of training, and\nincreased to 0.02 gradually.\n4.2 Model Configuration\nThe score encoder of our proposed system has three-layer\ndense network of size 128 with ReLU activation as an embedding layer, two-layer bidirectional(Bi)-LSTMs of size\n128 for note-level and voice-level, two-layer Bi-LSTM of\nsize 64 for beat-level, and one-layer Bi-LSTM of size 64\nfor measure-level. The performance encoder has two-layer\nunidirectional(Uni)-LSTM of size 16 for note-level and\none-layer Uni-LSTM of size 16 for measure-level. The size\nof latent vector z in CVAE is 16. The performance decoder\nconsists of one-layer Uni-LSTMs for beat-level and notelevel both of size 64. The measure-level module has almost\nthe same setting except that every hidden size of the network in the performance encoder is 8 including the latent\nvector z.\nTo compare our approach with HAN architecture and\nmeasure-level modules (HAN-M), we also trained two\nother models. The first model is a baseline model that uses\nonly three-layers LSTM in note-level with hidden size of\n256. The other model, which will be denoted as HAN-S, is\na model that excludes the measure-level module. In HANS, the hidden size of beat-level layer in the score encoder\nand performance decoder was 128.\n5. RESULTS\n5.1 Reconstruction Error\nQuantitative evaluation of modeling expressive performance is a not trivial issue. One of the frequently used\nquantitative evaluation method is calculating MSE of output features [4]. Comparing the predicted outputs with\n\u201ctarget\u201d performance can be arbitrary, because there can be\nvarious ways to perform the score. In our system, however,\nthere is a performance encoder and a latent style vector z\nthat, ideally, makes the output in a style of the target performance. Therefore, comparing output features with the\ntarget performances is more reasonable. Also, as a learning model, it is fair to check the test loss with the same\ncriteria used for training.\nTable 1 shows the reconstruction loss of each model\non the test set which includes 21 pieces and 109 performances. The two HAN models achieved much less reconstruction error than the baseline model. This indicates that\nFigure 6. Average score of the listening test for Schubert\nSonata in 7-point Likert scale. The t-test results between\nour models (HAN-S,M) and Human are marked with ns\nonly if it is not significant. The results between our models\nand the others models are marked only if it is significant.\n\u201c*\u201d and \u201c**\u201d denote \u201cp\u22640.05\u201d and \u201cp\u22640.01\u201d, respectively.\nthe hierarchical approach helps the model to generalize to\nunseen data. Between the two HAN models, HAN-M is\nslightly better than HAN-S. We have tested different parameter sizes for HAN-S so that HAN-S has a similar number of parameters with the sum of two modules in HAN-M,\nbut the result was not much different.\n5.2 Listening Test\nWe also conducted a listening test to evaluate our model\nqualitatively. We asked five students, who are majoring piano at a college of music, to listen to the rendered performances and evaluate them with criteria presented in Figure\n6 in 7-point Likert scale (1 - very bad, 7 - very good) with\nadditional comments on the performance. We chose three\npieces of different styles from our test set: the first movement from Beethoven\u2019s Piano Sonata No. 5 (cut before recapitulation), Chopin\u2019s Etude op. 10 No. 2 (entire piece),\nand the first movement from Schubert Piano Sonata D.664\n(cut before development).\nWe prepared five different performances MIDI per\npiece: a human performance from Yamaha e-competition,\na direct export from MusicXML score to MIDI by a notation program (MuseScore), each of rendered performances\nfrom HAN-S and HAN-M, and Basis Mixer (BM). The\nresult exported from MuseScore had no tempo change but\nthe velocities of notes were changed by a simple rule-based\nconversion of dynamic markings in the score. BM is the\nonly publicly available model that does not require additional notation among previous expressive performance\nmodels [5]. It also achieved a highest score among other\ncomputational methods in previous research [26]. We included the BM model in the listening test and generated\nperformances with the same MusicXML file we used for\nour model 3 . Since the recording and playback in audio\nsystems can affect the quality of performance, we invited\nthe participants to our studio and played the prepared MIDI\nfiles with a Yamaha Disklavier piano. Each performance\nwas played once in a random order.\nThe result of evaluation on Schubert is presented in Figure 6 As expected, all participants gave highest scores in\n3 https://basismixer.cp.jku.at/static/app.html\nProceedings of the 20th ISMIR Conference, Delft, Netherlands, November 4-8, 2019\n912\n\fevery criteria for the human performance. Our proposed\nmodel, HAN-S and HAN-M, achieved higher scores in all\nseven criteria compared to other models. Two among five\nparticipants gave more than five out of seven points as the\nhuman confidence for the performance by HAN-S, and one\ngave five points to HAN-M. The t-test result showed that\nHAN-S and HAN-M showed statistically significant differences (p \u22640.05) compared to the score and the BM model\nin overall ratings of the performance of Schubert.\nThe positive comments on our models were: \u201cthe interpretation was interesting\u201d (Beethoven, HAN-M), \u201cfelt that\nthe flow of performance was humane\" (Beethoven, HANS), \u201cvoicing was too good so that it felt like performed\nby multiple performers\u201d (Chopin, HAN-S), \u201csounded\nlike a performance by human with strong characteristics\u201d (Chopin, HAN-S), \u201cvoicing was fine except some\nfaults\u201d (Schubert, HAN-M), and \u201csounded like machinegenerated performance with fine pedaling\u201d (Schubert,\nHAN-S) .\nThere were also negative comments criticizing our\nmodels, such as \u201cused too much pedal\u201d, \u201cpedal points\nwere unnatural\u201d, \u201clack of color\u201d, \u201ctoo short articulation\u201d,\n\u201csome tempo or dynamic changes were unnatural\u201d, \u201ctouch\nwas too light\u201d, and \u201cit did not seem that the performer\nwas listening to the performance\u201d. Although our models\nhad predicted the pedal usage, the pedaling was often too\ndeep and \u201cdirty\u201d or too shallow. The result showed that the\nnote-level pedal embedding needs improvement.\nThe responses of our participants for performances by\nBM, which is a data-driven model based on RNN, were\nnegative regardless of the piece. The comments from the\nparticipants said that \u201calthough there was a clear intention to express phrasing, it was unnatural and sounded like\na mechanical interpretation\u201d (Schubert), \u201cinaccurate and\nlimping rhythm\u201d (Beethoven and Schubert),and \u201cthe temporal gaps at measure boundary were unnatural\u201d (Chopin\nand Schubert). Unlike the Score MIDI, the performance by\nBM included clear change in tempo for phrasing. However,\nmost of the participants gave almost the same level of negative response to its phrasing quality compared to the Score\nMIDI. This shows how difficult it is to model phrasing of\nthe music.\nThe results were also largely differed by the characteristics of the piece. For example, Schubert\u2019s Sonata has a\nsong-like melody with arpeggio accompaniments. Hence,\nit was important to model the natural phrasing, e.g., subtle\nchange of tempo and velocity according to the melody. On\nthe other hand, the fast chromatic scale in Chopin\u2019s Etude\ndemands a stable tempo. Therefore, Score MIDI received\nsix out of seven points for overall quality from three participants because the performance was in perfectly constant\ntempo with strict following of dynamic markings. The flexibility of tempo generated by our model was not favored by\nthe participants in case of Chopin\u2019s Etude.\nIn summary, the results of listening test shows that our\nmodels have achieved more natural expressions compared\nto the other models, especially in a piece with song-like\nmelodies. Modeling the pedal usage and a human-like sta-\nFigure 7. a) Local tempo changes and b) Dynamics change\nin different performances of Schubert\u2019s Piano Sonata\nble tempo are issues to further investigate.\n5.3 Case Study: Comparison in Tempo and Dynamics\nThe quality of phrasing can be also observed from examples. Figure 7-a) compares local tempo changes in difference performances of Schubert\u2019s Sonata. The local tempo\nis represented with inter-onset-interval (IOI) which is computed by dividing seconds into quarter-note. BM has an evident peak at around the 10th note, which was exaggerated\nthan any other human pianists. In terms of Pearson correlation, HAN-S and HAN-M have a strong positive correlation with the pianists (0.7<r<1.0) while the BM model has\na less positive correlation (0.3<r<0.5).\nFigure 7-b) compares dynamics changes of melody\nnotes in different performances of the same piece. The dynamics is represented with MIDI note velocity. Increasing\nand decreasing timings of HAN-M and HAN-S are generally similar to pianists. For example, decrescendo starts at\nnote sequence 40 which follows crescendo, then pp starts\nat 45 and comes back to mf at 48. Both HAN-M and HANS show similar downward and upward curves with pianists\nwhile the BM model shows just slight upward curve. These\ntrend can be proved by correlation coefficients among pianists and generated models. HAN-S and HAN-M have\nsignificant positive correlation with pianists (0.3<r<0.7)\nwhile BM has almost no correlation (r<0.1).\n6. CONCLUSIONS\nWe introduced a hierarchical RNN-based system for modeling expressive piano performance and a dataset for\ntraining the model. Our listening test demonstrated that\nour model achieved more human-like musical expression\ncompared to the previous model [5]. The source code\nand dataset are available in https://github.com/\njdasam/virtuosoNet.\nProceedings of the 20th ISMIR Conference, Delft, Netherlands, November 4-8, 2019\n913\n\f7. ACKNOWLEDGEMENT\nThis research was funded by Samsung Research Funding\nCenter under the project number SRFC-IT1702-12.\n8. REFERENCES\n[1] Samuel R Bowman, Luke Vilnis, Oriol Vinyals, Andrew M Dai, Rafal Jozefowicz, and Samy Bengio. Generating sentences from a continuous space. In Proc.\nof the 20th Conf. on Computational Natural Language\nLearning, 2016.\n[2] Sergio Canazza, Giovanni De Poli, and Antonio Rod\u00e0.\nCaro 2.0: an interactive system for expressive music\nrendering. Advances in Human-Computer Interaction,\n2015:2, 2015.\n[3] Carlos Eduardo Cancino-Chac\u00f3n, Thassilo Gadermaier, Gerhard Widmer, and Maarten Grachten. An\nevaluation of linear and non-linear models of expressive dynamics in classical piano and symphonic music.\nMachine Learning, 106(6):887\u2013909, Jun 2017.\n[4] Carlos Eduardo Cancino-Chac\u00f3n, Maarten Grachten,\nWerner Goebl, and Gerhard Widmer. Computational\nmodels of expressive music performance: A comprehensive and critical review. Frontiers in Digital Humanities, 5:25, 2018.\n[5] Carlos\nEduardo\nCancino\nChac\u00f3n\nand\nMaarten\nGrachten. The basis mixer: a computational romantic\npianist. In Late-Breaking Demos of the 17th International Society for Music Information Retrieval Conf.\n(ISMIR), 2016.\n[6] Junyoung Chung, Sungjin Ahn, and Yoshua Bengio.\nHierarchical multiscale recurrent neural networks. In\nProc. of the International Conf. on Learning Representations (ICLR), 2017.\n[7] Sebastian\nFlossmann,\nWerner\nGoebl,\nMaarten\nGrachten, Bernhard Niedermayer, and Gerhard Widmer. The magaloff project: An interim report. Journal\nof New Music Research, 39(4):363\u2013377, 2010.\n[8] Anders Friberg, Roberto Bresin, and Johan Sundberg.\nOverview of the kth rule system for musical performance. Advances in Cognitive Psychology, 2(23):145\u2013161, 2006.\n[9] Jon Gillick, Adam Roberts, Jesse Engel, Douglas Eck,\nand David Bamman. Learning to groove with inverse\nsequence transformations. In Proc. the 36th International Conf. on Machine Learning (ICML), volume 97,\npages 2269\u20132279, 2019.\n[10] Bruno Gingras, Marcus T Pearce, Meghan Goodchild, Roger T Dean, Geraint Wiggins, and Stephen\nMcAdams. Linking melodic expectation to expressive\nperformance timing and perceived musical tension.\nJournal of Experimental Psychology: Human Perception and Performance, 42(4):594, 2016.\n[11] Sergio Giraldo and Rafael Ramirez. A machine learning approach to ornamentation modeling and synthesis in jazz guitar. Journal of Mathematics and Music,\n10(2):107\u2013126, 2016.\n[12] Curtis Hawthorne, Andrew Stasyuk, Adam Roberts,\nIan Simon, Cheng-Zhi Anna Huang, Sander Dieleman,\nErich Elsen, Jesse Engel, and Douglas Eck. Enabling\nfactorized piano music modeling and generation with\nthe MAESTRO dataset. In Proc. of the International\nConf. on Learning Representations (ICLR), 2019.\n[13] Cheng-Zhi Anna Huang, Ashish Vaswani, Jakob\nUszkoreit,\nIan Simon,\nCurtis Hawthorne, Noam\nShazeer, Andrew M. Dai, Matthew D. Hoffman, Monica Dinculescu, and Douglas Eck. Music transformer.\nIn Proc. of the International Conf. on Learning Representations (ICLR), 2019.\n[14] Dasaem Jeong, Taegyun Kwon, Yoojin Kim, and Juhan\nNam. Graph neural network for music score data\nand modeling expressive piano performance. In Proc.\nthe 36th International Conf. on Machine Learning\n(ICML), volume 97, pages 3060\u20133070, 2019.\n[15] Dasaem Jeong, Taegyun Kwon, Yoojin Kim, and Juhan\nNam. Score and performance features for rendering expressive music performances. In Proc. of Music Encoding Conf., 2019.\n[16] Tero Karras, Timo Aila, Samuli Laine, and Jaakko\nLehtinen. Progressive growing of GANs for improved\nquality, stability, and variation. In International Conf.\non Learning Representations (ICLR), 2018.\n[17] Tae Hun Kim, Satoru Fukayama, Takuya Nishimoto,\nand Shigeki Sagayama. Statistical approach to automatic expressive rendition of polyphonic piano music. In Alexis Kirke and Eduardo R. Miranda, editors, Guide to Computing for Expressive Music Performance, pages 145\u2013179. London, 2013.\n[18] Diederik P Kingma and Jimmy Ba.\nAdam: A\nmethod for stochastic optimization. arXiv preprint\narXiv:1412.6980, 2014.\n[19] Diederik P Kingma and Max Welling. Auto-encoding\nvariational bayes. arXiv preprint arXiv:1312.6114,\n2013.\n[20] Stanislas Lauly. Mod\u00e9lisation de l\u2019interpr\u00e9tation des\npianistes & applications d\u2019auto-encodeurs sur des\nmod\u00e8les temporels. Master\u2019s thesis, University of\nMontr\u00e9al, 2010.\n[21] Akira Maezawa. Deep piano performance rendering\nwith conditional VAE. In Late-Breaking Demos of the\n19th International Society for Music Information Retrieval Conf. (ISMIR), 2018.\n[22] Iman Malik and Carl Henrik Ek. Neural translation of\nmusical style. CoRR, abs/1708.03535, 2017.\nProceedings of the 20th ISMIR Conference, Delft, Netherlands, November 4-8, 2019\n914\n\f[23] Eita Nakamura, Kazuyoshi Yoshii, and Haruhiro\nKatayose. Performance error detection and postprocessing for fast and accurate symbolic music alignment. In Proc. of 18th International Society for Music\nInformation Retrieval Conf. (ISMIR), 2017.\n[24] Sageev Oore, Ian Simon, Sander Dieleman, Douglas\nEck, and Karen Simonyan. This time with feeling:\nlearning expressive musical performance. Neural Computing and Applications, Nov 2018.\n[25] Adam Roberts, Jesse Engel, Colin Raffel, Curtis\nHawthorne, and Douglas Eck. A hierarchical latent\nvector model for learning long-term structure in music.\nIn Proc. of the 35th International Conf. on Machine\nLearning (ICML), pages 4364\u20134373, 2018.\n[26] Emery Schubert, Sergio Canazza, Giovanni De Poli,\nand Antonio Rod\u00e0. Algorithms can mimic human piano performance: the deep blues of music. Journal of\nNew Music Research, 46(2):175\u2013186, 2017.\n[27] Kihyuk Sohn, Honglak Lee, and Xinchen Yan. Learning structured output representation using deep conditional generative models. In Advances in Neural Information Processing Systems (NIPS), pages 3483\u20133491,\n2015.\n[28] Ashish Vaswani, Noam Shazeer, Niki Parmar, Jakob\nUszkoreit, Llion Jones, Aidan N Gomez, \u0141ukasz\nKaiser, and Illia Polosukhin. Attention is all you need.\nIn Advances in Neural Information Processing Systems\n(NIPS), pages 5998\u20136008, 2017.\n[29] Gerhard Widmer, Sebastian Flossmann, and Maarten\nGrachten. YQX plays chopin. AI magazine, 30(3):35,\n2009.\n[30] Zichao Yang, Diyi Yang, Chris Dyer, Xiaodong He,\nAlex Smola, and Eduard Hovy. Hierarchical attention\nnetworks for document classification. In Proc. of the\n2016 Conf. of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies, pages 1480\u20131489, 2016.\nProceedings of the 20th ISMIR Conference, Delft, Netherlands, November 4-8, 2019\n915\n\f", "text_mmd": null}, "BIBREF355": {"title": "Computer-generated music for tabletop role-playing games. In Proceedings of the AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment", "authors": [{"first": "Lucas", "middle": [], "last": "Ferreira", "suffix": ""}, {"first": "Levi", "middle": [], "last": "Lelis", "suffix": ""}, {"first": "Jim", "middle": [], "last": "Whitehead", "suffix": ""}], "venue": "AAAI Conference on Artificial Intelligence and Interactive Digital Entertainment", "volume": "16", "issue": "", "pages": "59--65", "text_pymu": "Computer-Generated Music for Tabletop Role-Playing Games\nLucas N. Ferreira,1 Levi H. S. Lelis,2 Jim Whitehead1\n1Department of Computational Media, University of California, Santa Cruz, USA\n2Department of Computing Science, Alberta Machine Intelligence Institute (Amii), University of Alberta, Canada\nlferreira@ucsc.edu, levi.lelis@ualberta.ca, ejw@soe.ucsc.edu\nAbstract\nIn this paper we present Bardo Composer, a system to generate background music for tabletop role-playing games.\nBardo Composer uses a speech recognition system to translate player speech into text, which is classified according to a\nmodel of emotion. Bardo Composer then uses Stochastic BiObjective Beam Search, a variant of Stochastic Beam Search\nthat we introduce in this paper, with a neural model to generate musical pieces conveying the desired emotion. We performed a user study with 116 participants to evaluate whether\npeople are able to correctly identify the emotion conveyed\nin the pieces generated by the system. In our study we used\npieces generated for Call of the Wild, a Dungeons and Dragons campaign available on YouTube. Our results show that\nhuman subjects could correctly identify the emotion of the\ngenerated music pieces as accurately as they were able to\nidentify the emotion of pieces written by humans.\nIntroduction\nIn this paper we introduce Bardo Composer, or Composer\nfor short, a system for generating musical pieces that match\nthe emotion of stories told in tabletop role-playing games\n(TRPGs). For example, if the players are fighting a dragon,\nComposer should generate a piece matching such an epic\nmoment of the story. TRPG players often manually choose\nsongs to play as background music to enhance their experience (Bergstr\u00a8om and Bj\u00a8ork 2014). Our goal is to develop\nan intelligent system that augments the players\u2019 experience\nwith soundtracks that match the story being told in the game.\nImportantly, the system should allow players to concentrate\non the role-playing part of the game, and not on the disruptive task of selecting the next music piece to be played.\nThe object of our research is Dungeons and Dragons (D&D),\na TRPG where players interpret characters of a story conducted by a special player called the dungeon master.\nPadovani, Ferreira, and Lelis (2017; 2019) introduced\nBardo, a system that automatically selects the background\nmusic of a D&D session based on the story being told by\nthe players. This paper builds upon their system. Bardo uses\na speech recognition system to transcribe voice into text,\nCopyright c\u20dd 2020, Association for the Advancement of Artificial\nIntelligence (www.aaai.org). All rights reserved.\nwhich is then classified into an emotion. Bardo then selects\na song of the classified emotion from a library of labeled\nsongs. In this work we extend Bardo to include a neural\nmodel for generating musical pieces conveying the emotions\ndetected in the game story, instead of selecting a song from a\nlabeled library\u2014thus the name Bardo Composer. We expect\nthat by generating pieces we can capture the exact emotional\ntone of the story, while methods that select from a set of precomposed pieces have a more limited \u201cemotional palette\u201d.\nLanguage models (LMs) are able to generate coherent\nmusic pieces (Ferreira and Whitehead 2019). However, it\nis still challenging to generate music with a given emotion. For that we introduce Stochastic Bi-Objective Beam\nSearch (SBBS), a variant of Stochastic Beam Search (Poole\nand Mackworth 2010) to guide the generative process while\nmaximizing the probability given by a LM jointly with the\nprobability of pieces matching an emotion. The emotion in\nthe story is detected by a BERT model (Devlin et al. 2018)\nand is given as input to SBBS, which uses a GPT-2 model\n(Radford et al. 2019) to classify the emotion of the generated pieces.\nWe evaluated Composer on the Call of the Wild (CotW)\ndataset (Padovani, Ferreira, and Lelis 2017), which is a campaign of D&D available on YouTube. Since our primary goal\nis to generate music pieces conveying the current emotion\nof the game\u2019s story, we used Composer to generate pieces of\nparts of CotW that featured a transition in the story\u2019s emotion. Then, in a user study with 116 participants, we evaluated whether people correctly perceive the intended emotions in pieces generated by Composer. We also measured\nif the participants were able to distinguish the emotion of\nhuman-composed pieces by using Bardo\u2019s original system as\na baseline. Our results show that the participants were able\nto identify the emotions in generated pieces as accurately\nas they were able to identify emotions in human-composed\npieces. This is an important result towards the goal of a fullyautomated music composition system for TRPGs.\nRelated Work\nOur work is mostly related to machine learning models that\ngenerate music with a given emotion. For example, Monteith, Martinez, and Ventura (2010) trained Hidden Markov\narXiv:2008.07009v1  [cs.SD]  16 Aug 2020\n\fmodels to generate music from a corpus labeled according\nto a categorical model of emotion. These models are trained\nfor each emotion to generate melodies and underlying harmonies. Ferreira and Whitehead (2019) used a genetic algorithm to fine-tune a pre-trained LSTM, controlling the\nLSTM to generate either positive or negative pieces. Our\nwork differs from Monteith, Martinez, and Ventura\u2019s because we train a single LM that is controlled to generate music with different emotions. It is also different from (Ferreira\nand Whitehead 2019) once we control the LM at sampling\ntime and not at training time.\nOur work is also related to rule-based systems that map\nmusical features to a given emotion (Williams et al. 2015b).\nFor example, Williams et al. (2015a) generate soundtracks\nfor video games using a rule-based system to transform\npre-generated melodies, matching the emotion of annotated\ngame scenes. Davis and Mohammad (2014) follow a similar approach in TransPose, a system that generates piano\nmelodies for novels. Our work differs from these rule-based\nsystems because we learn mappings from musical features\nto emotion directly from data.\nOur work is also related to neural models that generate\ntext with a given characteristic. For example, CTRL (Keskar\net al. 2019) is a Transformer LM trained to generate text\nconditioned on special tokens that inform the LM about the\ncharacteristics of the text to be generated (e.g., style). Our\nwork differs from CTRL because we control the LM with a\nsearch procedure and not with an extra input to the LM. Conditioning the LM requires a large amount of labeled data,\nwhich is expensive in our domain.\nThe Plug and Play LM (Dathathri et al. 2019) combines a\npre-trained LM with a small attribute classifier to guide text\ngeneration. Although both Composer and the Plug and Play\nLM control the generation procedure at sampling time, we\nuse search as a means of generation control while Plug and\nPlay LM uses a classifier to alter the structure of the model.\nVijayakumar\net\nal.\n(2018)\nand\nKool,\nHoof,\nand\nWelling (2019) proposed variations of Beam search to solve\nthe problem of generating repetitive sentences. Our work\ndiffers from both these works because our variation of Beam\nsearch optimizes for two independent objectives.\nBackground\nSymbolic Music Composition Symbolic music is typically\ngenerated by sampling from a LM that computes the likelihood of the next musical symbols (e.g., note) in a piece.\nTypically, the LM is defined as a neural network and the\nsymbols are extracted from MIDI or piano roll representations of music (Briot, Hadjeres, and Pachet 2017). Let\nx = [x0, \u00b7 \u00b7 \u00b7 , xt\u22122, xt\u22121] be the first t symbols of a piece\nand P(xt|x0, \u00b7 \u00b7 \u00b7 , xt\u22122, xt\u22121) be the probability of the next\nsymbol being xt, according to a trained LM. One can sample\nthe next symbol of the sequence according to the probability\ndistribution P (Briot, Hadjeres, and Pachet 2017). We denote the trained language model as L and L(x) is a function\nthat returns the next symbol given a sequence x. To generate\na piece with L, one provides as input a sequence of symbols\nx = [x0, x1, \u00b7 \u00b7 \u00b7 , xt] to bias the generation process. This in-\nAlgorithm 1 Bardo Composer\nRequire: Speech recognition system S, Text emotion classifier Es, Music emotion classifier Em, LM L, speech\nsignal v, previously composed symbols x, beam size b,\nnumber of symbols k\nEnsure: Music piece x\n1: s, l \u2190 S(v)\n2: v, a \u2190 Es(s)\n3: y \u2190 SBBS(L, Em, x, v, a, b, k, l) # see Algorithm 2\n4: return x \u222a y\nput sequence is fed into L which computes L(x) = xt+1.\nNext, xt+1 is concatenated with x and the process repeats\nuntil a special end-of-piece symbol is found or a given number of symbols are generated.\nBardo Padovani, Ferreira, and Lelis (2017; 2019) presented\nBardo, a system to select background music for tabletop\ngames. Bardo classifies sentences produced by a speech\nrecognition system into one of the four story emotions:\nHappy, Calm, Agitated, and Suspenseful. Bardo then selects\na song from a library of songs corresponding to the classified\nemotion. The selected song is then played as background\nmusic at the game table. In this paper we use Padovani et\nal.\u2019s dataset to train an emotion classifier for the story being\ntold at a game session. Their dataset includes 9 episodes of\nCotW, which contains 5,892 sentences and 45,247 words, resulting in 4 hours, 39 minutes, and 24 seconds of gameplay.\nThere are 2,005 Agitated, 2,493 Suspenseful, 38 Happy, and\n1,356 Calm sentences in the dataset.\nValence-Arousal Model of Emotion We use a twodimensional emotion model that generalizes the emotion\nmodel used in Bardo. We consider the dimensions of valence\nand arousal, denoted by a pair (v, a), where v \u2208 [0, 1] and\na \u2208 [0, 1] (Russell 1980). Valence measures sentiment and\nthus v = 0 means a negative input and v = 1 means a positive input. Arousal measures the energy of the input and thus\na = 0 means that the input has low energy whereas a = 1\nmeans that the input has high energy. We use this model for\nclassifying both the emotion of the player\u2019s speeches and the\nemotion of the generated music.\nBardo Composer: System Description\nA general overview of Composer is shown in Algorithm 1.\nIt receives as input a speech recognition system S, an emotion classifier for text Es, an emotion classifier for music\nEm, a LM for symbolic music generation L, a speech signal v with the last sentences spoken by the players, and a\nsequence x of musical symbols composed in previous calls\nto Composer. The algorithm also receives parameters b and\nk, which are used in the search procedure described in Algorithm 2. Composer returns a symbolic piece that tries to\nmatch the emotion in the players\u2019 speeches.\nComposer starts by converting the speech signal v into\ntext s with S (line 1). In addition to text, S returns the duration of the signal v in seconds, this is stored in l. Then,\nComposer classifies the emotion of s in terms of valence\n\fv and arousal a and it invokes our Stochastic Bi-Objective\nBeam Search (SBBS) to generate a sequence of symbols y\nthat matches the desired length l and emotion with arousal a\nand valence v. SBBS receives as input the models L and Em,\nthe current sequence x, the desired emotion values v and a,\nSBBS\u2019s parameter values b and k, which are explained below, and the desired length l of the piece to be generated.\nIn the first call to Composer, the sequence x is initialized\nwith the the symbols of the first 4 timesteps of a random\nhuman-composed piece with the emotion v, a, as returned\nby Es. Every time there is a transition from one emotion\nto another, we reinitialize the sequence x using the same\nprocess. This is used to bias the generative process and to\nemphasize emotion transitions.\nTo be used in real-time, Composer is invoked with the\nmost recently captured speech signal v and returns a composed piece of music. While the most recent piece is being\nplayed at the game table, Composer receives another signal\nv and composes the next excerpt. One also needs to define\nthe length of the signal v. In our implementation, similar to\nPadovani et al. (2017), we use YouTube\u2019s subtitle system as\nthe speech recognition system S. Therefore, signals v are\nlong enough to form a subtitle.\nClassifying the Story\u2019s Emotion\nIn order to have a common model of emotion between stories and music, we use a mapping from Bardo\u2019s four emotion\nmodel to the valence-arousal model. Namely, we have Suspenseful mapping to low valence and arousal (v = 0, a =\n0); Agitated to low valence and high arousal (v = 0, a = 1);\nCalm to high valence and low arousal (v = 1, a = 0); and\nHappy to high valence and arousal (v = 1, a = 1).\nFor example, in the context of the game Dungeons and\nDragons, the sentence \u201cRoll initiative\u201d is normally said at\nthe beginning of battles and it can be considered (v = 0, a =\n1), once a battle is a negative (dangerous) moment with high\nenergy. \u201cRoll initiative\u201d is normally classified as Agitated in\nPadovani et al.\u2019s dataset. This mapping allows us to use the\nvalence-arousal model with the labeled CotW dataset.\nThe valence-arousal mapping is based on the model used\nto annotate the VGMIDI dataset. When human subjects annotated that dataset, they used a continuous valence/arousal\nmodel with labels defining a fixed set of discrete basic emotions (e.g. happy or sad) (Ferreira and Whitehead 2019).\nGiven the limited amount of TRPG stories labeled according to emotion (there are only 5,892 sentences in the\nCotW dataset), we use a transfer learning approach to classify the sentences (Radford et al. 2018). We fine-tune a highcapacity BERT architecture with the CotW dataset (Devlin\net al. 2018). We use BERT because it outperforms several\nother transformers across different NLP tasks (Devlin et al.\n2018). Although in Algorithm 1 we depict the classifier for\nstory emotions as a single Es model, in our implementation\nwe treat valence and arousal independently, thus we finetune a pre-trained BERT for each dimension.\nClassifying the Music\u2019s Emotion\nAs was the case with the TRPG stories, given the limited\namount of MIDI pieces labeled according to emotion, we\nalso apply a transfer learning approach to classify emotion\nin music (Em). However, different than the Es model where\nwe fine-tune a BERT architecture, for Em we fine-tune a\nGPT-2 architecture (Radford et al. 2019). We use GPT-2\nfor Em because it is better suited for sequence generation\nthan BERT. Similarly to Es, model Em also treats valence\nand arousal independently. Thus, we fine-tune a pre-trained\nGPT-2 for each of these dimensions.\nTo the best of our knowledge, in the symbolic music domain, there are no publicly available high-capacity LM pretrained with large (general) datasets. Typically, models in\nthis domain are trained with relatively small and specific\ndatasets. For example, the MAESTRO dataset (Hawthorne\net al. 2019), the Bach Chorales (Hadjeres, Pachet, and\nNielsen 2017) and the VGMIDI (Ferreira and Whitehead\n2019) dataset. We pre-train a general high-capacity GPT-2\narchitecture as a language model (Radford et al. 2019) using a new dataset we created called ADL (Augmented Design Lab) Piano MIDI dataset 1.\nThe ADL Piano MIDI dataset is based on the Lakh MIDI\ndataset (Raffel 2016), which, to the best of our knowledge,\nis the largest MIDI dataset publicly available. The Lakh\nMIDI dataset contains a collection of 45,129 unique MIDI\nfiles that have been matched to entries in the Million Song\ndataset (Bertin-Mahieux et al. 2011). Among these files,\nthere are many versions of the same piece. We kept only\none version of each piece. Given that the datasets for emotion classification in music are limited to piano only, we extracted from the Lakh MIDI dataset only the tracks with instruments from the \u201cpiano family\u201d(MIDI program numbers\n1-8 in the dataset). This process generated a total of 9,021\nunique piano MIDI files. These files are mainly Rock and\nClassical pieces, so to increase the genre diversity (e.g. Jazz,\nBlues, and Latin) of the dataset, we included an additional\n2,065 files scraped from public sources on the Internet2. All\nfiles in the final collection were de-duped according to their\nMD5 checksum. The final dataset has 11,086 pieces.\nAfter pre-training the high-capacity GPT-2 model, we\nfine-tune two independent models (one for valence and\none for arousal) with an extended version of the VGMIDI\ndataset (Ferreira and Whitehead 2019). We extended the\nVGMIDI dataset from 95 to 200 labeled pieces using the\nsame annotation method of the original dataset. All the 200\npieces are piano arrangements of video game soundtracks\nlabeled according to the valence-arousal model of emotion.\nEncoding\nWe encode a MIDI file by parsing all notes from\nthe NOTE ON and NOTE OFF events in the MIDI. We define\na note as a set z = (zp, zs, zd, zv), where {zp \u2208 Z|0 \u2264\nzp < 128} is the pitch number, {zs \u2208 Z|zs \u2265 0} is the note\nstarting time in timesteps, {zd \u2208 Z|0 \u2264 zd \u2264 56} is note\nduration in timesteps and {zv \u2208 Z|0 \u2264 zv < 128} is the\nnote velocity. Given a MIDI NOTE ON event, we parse a note\nz by retrieving the starting time zs (in seconds), the pitch\nnumber zp and the velocity zv from that event. To calculate\nthe note duration zd, we find the correspondent NOTE OFF\nevent of the given NOTE ON and retrieve the NOTE OFF end\n1https://github.com/lucasnfe/adl-piano-midi\n2https://bushgrafts.com/midi/ and http://midkar.com/jazz/\n\fAlgorithm 2 Stochastic Bi-Objective Beam Search\nRequire: Music emotion classifier Em, LM L, previously\ncomposed symbols x, valence and arousal values v and\na, number k of symbols to consider, beam size b, length\nl in seconds of the generated piece.\nEnsure: Sequence of symbols of l seconds.\n1: B \u2190 [x], j \u2190 0\n2: while l(y[t : t + j]) < l, \u2200y \u2208 B do\n3:\nC \u2190 {}\n4:\nfor all m \u2208 B do\n5:\nCm \u2190 {m \u222a s|s \u2208 V }\n6:\nCm \u2190 k elements y from Cm with largest pL(y)\n7:\nC \u2190 C \u222a Ci\n8:\nB \u2190 b sequences y sampled from C proportionally\nto pL(y)(1 \u2212 |v \u2212 Em,v(y)|)(1 \u2212 |a \u2212 Em,a(y)|)\n9:\nj \u2190 j + 1\n10: return m \u2208 B such that pL(m) = maxy\u2208B pL(y) and\nl(y[t : t + j]) \u2265 l\ntime ze (in seconds). We discretize zs and ze to compute the\nnote duration zd = t \u00b7 ze \u2212 t \u00b7 zs in timesteps, where t is a\nparameter defining the sampling frequency of the timesteps.\nWe derive a sequence x = {z1\nv, z1\nd, z1\np, \u00b7 \u00b7 \u00b7 , zn\nv , zn\nd , zn\np } of\ntokens for a given MIDI file by (a) parsing all notes zi from\nthe file, (b) sorting them by starting time zj\ns and (c) concatenating their velocity zj\nv, duration zj\nd and pitch zj\np. We add\ntwo special tokens TS and END in the sequence x, to mark\nthe end of a timestep and the end of a piece, respectively.\nThis encoding yields a vocabulary V of size |V | = 314.\nStochastic Bi-Objective Beam Search\nNext, we describe how one can use a LM and a music emotion classifier to bias the process of music generation to\nmatch a particular emotion (line 3 of Algorithm 1). For that\nwe introduce Stochastic Bi-Objective Beam Search (SBBS),\na search algorithm guided by the LM L and the music emotion classifiers, denoted as Em,v and Em,a, for valence and\narousal. The goal of SBBS is to allow for the generation of\npieces that sound \u201cgood\u201d (i.e., have high probability value\naccording to the trained LM), but that also match the current\nemotion of the story being told by the players.\nWe call SBBS \u201cstochastic\u201d because it samples from a distribution instead of greedily selecting the best sequences of\nsymbols, as a regular beam search does. The stochasticity of\nSBBS allows it to generate a large variety of musical pieces\nfor the same values of v and a. We also call it \u201cbi-objective\u201d\nbecause it optimizes for realism and emotion.\nThe pseudocode of SBBS is shown in Algorithm 2.\nIn the pseudocode we use letters x, y and m to denote sequences of musical symbols. Function pL(y) =\n\ufffd\nyt\u2208y P(yt|y0, \u00b7 \u00b7 \u00b7 , yt\u22121) is the probability of sequence y\naccording to the LM L; a high value of pL(y) means that y\nis recognized as a piece of \u201cgood quality\u201d by L. We denote\nas l(y) the duration in seconds of piece y. Finally, we write\nx[i : j] for j \u2265 i to denote the subsequence of x starting at\nindex i and finishing at index j.\nSBBS initializes the beam structure B with the sequence\nx passed as input (line 1). SBBS also initializes variable j\nfor counting the number of symbols added by the search.\nSBBS keeps in memory at most b sequences and, while all\nsequences are shorter than the desired duration l (line 2),\nit adds a symbol to each sequence (lines 3\u20139). SBBS then\ngenerates all sequences by adding one symbol from vocabulary V to each sequence m from B (line 5); these extended\nsequences, known as the children of m, are stored in Cm.\nThe operations performed in lines 6 and 8 attempt to ensure the generation of good pieces that convey the desired\nemotion. In line 6, SBBS selects the k sequences with largest\npL-value among the children of m. This is because some of\nthe children with low pL-value could be attractive from the\nperspective of the desired emotion and, although the resulting piece could convey the desired emotion, the piece would\nbe of low quality according to the LM. The best k children of\neach sequence in the beam are added to set C (line 7). Then,\nin line 8, SBBS samples the sequences that will form the\nbeam of the next iteration. Sampling occurs proportionally\nto the values of pL(y)(1\u2212|v\u2212Em,v(y)|)(1\u2212|a\u2212Em,a(y)|),\nfor sequences y in C. A sequence y has higher chance of being selected if L attributes a high probability value to y and\nif the music emotion model classifies the values of valence\nand arousal of y to be similar to the desired emotion. When\nat least one of the sequences is longer than the desired duration of the piece, SBBS returns the sequence with largest\npL-value that satisfies the duration constraint (line 10).\nEmpirical Evaluation\nOur empirical evaluation is divided into two parts. First, we\nevaluate the accuracy of the models used for story and music\nemotion classification. We are interested in comparing the\nfine-tuned BERT model for story emotion classification with\nthe simpler Na\u00a8\u0131ve Bayes approach of Padovani, Ferreira, and\nLelis (2017). We are also interested in comparing the finetuned GPT-2 model for music emotion classification with\nthe simpler LSTM of Ferreira and Whitehead (2019). In the\nsecond part of our experiments we evaluate with a user study\nwhether human subjects can recognize different emotions in\npieces generated by Composer for the CotW campaign.\nEmotion Classifiers\nStory Emotion\nThe story emotion classifier we use with\nComposer is a pair of BERT models, one for valence and\none for arousal. For both models, we use the pre-trained\nBERTBASE of Devlin et al. (2018), which has 12 layers,\n768 units per layer, and 12 attention heads. BERTBASE was\npre-trained using both the BooksCorpus (800M words) (Zhu\net al. 2015) and the English Wikipedia (2,500M words).\nWe independently fine-tune these two BERT models\nas valence and arousal classifiers using the CotW dataset\n(Padovani, Ferreira, and Lelis 2017). Fine-tuning consists\nof adding a classification head on top the pre-trained model\nand training all the parameters (including the pre-trained\nones) of the resulting model end-to-end. All these parameters were fine-tuned with an Adam optimizer (Kingma and\nBa 2014) with learning rate of 3e-5 for 10 epochs. We used\nmini-batches of size 32 and dropout of 0.5.\n\fAlg.\nEpisodes\nAvg.\n1\n2\n3\n4\n5\n6\n7\n8\n9\nNB\n73 88 91 85 94 81 41 74 94\n80\nBERT\n89 92 96 88 97 81 66 83 96\n87\nTable 1: Valence accuracy in % of Na\u00a8\u0131ve Bayes (NB) and\nBERT for story emotion classification.\nThe CotW dataset is divided into 9 episodes, thus we evaluate the accuracy of each BERT classifier using a leave-oneout strategy. For each episode e, we leave e out for testing\nand train in the remaining episodes. For example, when testing on episode 1, we use episodes 2-8 for training. Every\nsentence is encoded using a WordPiece embedding (Wu et\nal. 2016) with a 30,000 token vocabulary.\nWe compare the fine-tuned BERT classifiers with a Na\u00a8\u0131ve\nBayes (NB) approach (baseline), chosen because it is the\nmethod underlying the original Bardo system. NB encodes\nsequences using a traditional bag-of-words with tfidf approach. Table 1 shows the accuracy of the valence classification of both these methods per episode. The best accuracy\nfor a given episode is highlighted in bold. The BERT classifier outperforms NB in all the episodes, having an average\naccuracy 7% higher. For valence classification, the hardest\nepisode for both the models is episode 7, where BERT had\nthe best performance improvement when compared to NB.\nThe story told in episode 7 of CotW is different from all\nother episodes. While the other episodes are full of battles\nand ability checks, episode 7 is mostly the players talking\nwith non-player characters. Therefore, what is learned in the\nother episodes does not generalize well to episode 7. The improvement in accuracy of the BERT model in that episode\nis likely due to the model\u2019s pre-training. Episodes 5 and 9\nwere equally easy for both methods because they are similar to one another. The system trained in one of these two\nepisodes generalizes well to the other.\nTable 2 shows the accuracy of arousal classification of\nboth NB and BERT. The best accuracy for a given episode is\nhighlighted in bold. Again BERT outperforms NB in all the\nepisodes, having an average accuracy 5% higher. In contrast\nwith the valence results, here there is no episode in which\nthe BERT model substantially outperforms NB.\nAlg.\nEpisodes\nAvg.\n1\n2\n3\n4\n5\n6\n7\n8\n9\nNB\n82 88 75 79 82 76 98 86 84\n83\nBERT\n86 90 77 86 89 88 99 90 88\n88\nTable 2: Arousal accuracy in % of Na\u00a8\u0131ve Bayes (NB) and\nBERT for story emotion classification.\nMusic Emotion\nThe music emotion classifier is a pair of\nGPT-2 models, one for valence and one for arousal. We first\npre-trained a GPT-2 LM with our ADL Piano MIDI dataset.\nWe augmented each piece p of this dataset by (a) transpos-\nAlgorithm\nValence\nArousal\nBaseline LSTM\n69\n67\nFine-tuned LSTM\n74\n79\nBaseline GPT-2\n70\n76\nFine-tuned GPT-2\n80\n82\nTable 3: Accuracy in % of both the GPT-2 and LSTM models for music emotion classification.\ning p to every key, (b) increasing and decreasing p\u2019s tempo\nby 10% and (c) increasing and decreasing the velocity of\nall notes in p by 10% (Oore et al. 2017). Thus, each piece\ngenerated 12 \u00b7 3 \u00b7 3 = 108 different examples.\nThe pre-trained GPT-2 LM has 4 layers (transformer\nblocks), context size of 1024 tokens, 512 embedding units,\n1024 hidden units, and 8 attention heads. We then fine-tuned\nthe GPT-2 LM independently using the VGMIDI dataset,\nfor valence and for arousal. Similarly to BERT, fine-tuning\na GPT-2 architecture consists of adding an extra classification head on top of the pre-trained model and training all\nparameters end-to-end. Similar to the story emotion classifiers, we fine-tuned the GPT-2 classifiers for 10 epochs using\nan Adam optimizer with learning rate 3e-5. Different from\nthe story emotion classifiers, we used mini-batches of size\n16 (due to GPU memory constrains) and dropout of 0.25.\nThe VGMIDI dataset is defined with a train and test splits of\n160 and 40 pieces, respectively. We augmented the dataset\nby slicing each piece into 2, 4, 8 and 16 parts of equal length\nand emotion. Thus, each part of each slicing generated one\nextra example. This augmentation is intended to help the\nclassifier generalize for pieces with different lengths.\nWe compare the fine-tuned GPT-2 classifiers with LSTM\nmodels that were also pre-trained with the ADL Piano\nMidi dataset and fine-tuned with the VGMIDI dataset. We\nchose LSTMs because they are the state-of-the-art model in\nthe VGMIDI dataset (Ferreira and Whitehead 2019). The\nLSTMs have same size as the GPT-2 models (4 hidden\nlayers, 512 embedding units, 1024 hidden units) and were\npre-trained and fine-tuned with the same hyper-parameters.\nTable 3 shows the accuracy of both models for valence\nand arousal. We also report the performance of these models without pre-training (i.e., trained only on the VGMIDI\ndataset). We call these the baseline versions of the models.\nResults show that using transfer learning can substantially\nboost the performance of both models. The fine-tuned GPT2 is 10% more accurate in terms of valence and 8% in terms\nof arousal. The fine-tuned LSTM is 5% more accurate in\nterms of valence and 12% in terms of arousal. Finally, the\nfine-tuned GPT-2 outperformed the fine-tuned LSTM by 6%\nand 3% in terms of valence and arousal, respectively.\nUser Study\nIn our study we measure Composer\u2019s performance at generating music that matches the emotions of a story. We use\nComposer to generate a piece for a snippet composed of 8\ncontiguous sentences of each of the first 5 episodes of the\nCotW dataset. Each snippet has one emotion transition that\n\fMethod\nEpisodes\nAverage\ne1-p1\ne1-p2\ne2-p1\ne2-p2\ne3-p1\ne3-p2\ne4-p1\ne4-p2\ne5-p1\ne5-p2\nv\na\nv\na\nv\na\nv\na\nv\na\nv\na\nv\na\nv\na\nv\na\nv\na\nv\na\nva\nBaseline\n56\n65\n39 56 39 62 39\n79\n48\n60\n67\n53\n58 70\n63\n75 25\n36\n72\n58 51\n32\n34\nComposer\n62 60\n44 65 82 68 53\n68\n24\n55\n46\n43\n25 87\n37\n55 81\n86\n51\n67\n51 30\n34\nTable 4: The percentage of participants that correctly identified the valence and arousal (v and a, respectively) intended by the\nmethods for the pieces parts (p1 and p2).\nhappens in between sentences. The sentences are 5.18 seconds long on average. To test Composer\u2019s ability to generate\nmusic pieces with emotion changes, we asked human subjects to listen to the 5 generated pieces and evaluate the transitions of emotion in each generated piece.3\nThe user study was performed via Amazon Mechanical\nTurk and had an expected completion time of approximately\n10 minutes. A reward of USD $1 was given to each participant who completed the study. In the first section of the\nstudy, the participants were presented an illustrated description of the valence-arousal model of emotion and listened to\n4 examples of pieces from the VGMIDI dataset labeled with\nthe valence-arousal model. Each piece had a different emotion: low valence and arousal, low valence and high arousal,\nhigh valence and low arousal, high valence and arousal.\nIn the second section of the study, participants were asked\nto listen to the 5 generated pieces (one per episode). After\nlistening to each piece, participants had to answer 2 questions: (a) \u201cWhat emotion do you perceive in the 1st part of\nthe piece?\u201d and (b) \u201cWhat emotion do you perceive in the\n2nd part of the piece?\u201d To answer these two questions, participants selected one of the four emotions: low valence and\narousal, low valence and high arousal, high valence and low\narousal, high valence and arousal. Subjects were allowed to\nplay the pieces as many times as they wanted before answering the questions. The final section of the study was\na demographics questionnaire including ethnicity, first language, age, gender, and experience as a musician. To answer\nthe experience as a musician, we used a 1-to-5 Likert scale\nwhere 1 means \u201cI\u2019ve never studied music theory or practice\u201d\nand 5 means \u201cI have an undergraduate degree in music\u201d.\nWe compare Composer with a baseline method that selects a random piece from the VGMIDI dataset whenever\nthere is a transition of emotion. The selected piece has the\nsame emotion of the sentence (as given by the story emotion classifier). To compare these two methods, we used a\nbetween-subject strategy where Group A of 58 participants\nevaluated the 5 pieces generated by Composer and another\nGroup B of 58 participants evaluated the 5 pieces from the\nbaseline. We used this strategy to avoid possible learning\neffects where subjects could learn emotion transitions from\none method and apply the same evaluation directly to the\nother method. The average age of groups A and B are 34.96\nand 36.98 years, respectively. In Group A, 69.5% of participants are male and 30.5% are female. In Group B, 67.2%\n3Generated pieces can be downloaded from the following link:\nhttps://github.com/lucasnfe/bardo-composer\nare male and 32.8% are female. The average musicianship\nof the groups A and B are 2.77 and 2.46, respectively.\nTable 4 shows the results of the user study. We consider\nboth parts (p1 and p2 in the table) of each episode as an independent piece. The table presents the percentage of participants that correctly identified the pieces\u2019 valence and\narousal (\u201cv\u201d and \u201ca\u201d in the table, respectively), as intended\nby the methods. For example, 87% of the participants correctly identified the arousal value that Composer intended\nthe generated piece for part p1 of episode 4 (e4-p1) to have.\nWe refer to the percentage of participants that are able to\nidentify the approach\u2019s intended emotion as the approach\u2019s\naccuracy. We also present the approaches\u2019 average accuracy\nacross all pieces (\u201cAverage\u201d in the table) in terms of valence,\narousal, and jointly for valence and arousal (\u201cva\u201d in the table). The \u201cva\u201d-value of 34 for Composer means that 34%\nof the participants correctly identified the system\u2019s intended\nvalues for valence and arousal across all pieces generated.\nComposer outperformed the Baseline in e1-p2, e2-p1, and\ne5-p1. Baseline outperformed Composer e3-p1, e3-p2 and\ne4-p2. In the other four parts, one method performed better\nfor valence whereas the other method performance better for\narousal. Overall, the average results show that both systems\nperformed very similarly. Both of them had an average accuracy on the combined dimensions equal to 34%. The difference between these two methods and a system that selects\npieces at random (expected accuracy of 25%) is significant\naccording to a Binomial test (p = 0.02). These results show\nthat the participants were able to identify the emotions in the\ngenerated pieces as accurately as they were able to identify\nthe emotions in human-composed pieces. This is an important result towards the development of a fully automated system for music composition for story-based tabletop games.\nConclusions\nThis paper presented Bardo Composer, a system that automatically composes music for tabletop role-playing games.\nThe system processes sequences from speech and generates\npieces one sentence after the other. The emotion of the sentence is classified using a fine-tuned BERT. This emotion\nis given as input to a Stochastic Bi-Objective Beam Search\nalgorithm that tries to generate a piece that matches the emotion. We evaluated Composer with a user study and results\nshowed that human subjects correctly identified the emotion\nof the generated music pieces as accurately as they were able\nto identify the emotion of pieces composed by humans.\n\fReferences\n[Bergstr\u00a8om and Bj\u00a8ork 2014] Bergstr\u00a8om, K., and Bj\u00a8ork, S.\n2014. The case for computer-augmented games. Transactions of the Digital Games Research Association 1(3).\n[Bertin-Mahieux et al. 2011] Bertin-Mahieux,\nT.;\nEllis,\nD. P.; Whitman, B.; and Lamere, P. 2011. The million song\ndataset. 12th International Society for Music Information\nRetrieval Conference.\n[Briot, Hadjeres, and Pachet 2017] Briot, J.-P.; Hadjeres, G.;\nand Pachet, F. 2017. Deep learning techniques for music\ngeneration-a survey. arXiv preprint arXiv:1709.01620.\n[Dathathri et al. 2019] Dathathri, S.; Madotto, A.; Lan, J.;\nHung, J.; Frank, E.; Molino, P.; Yosinski, J.; and Liu,\nR.\n2019.\nPlug and play language models: a simple\napproach to controlled text generation.\narXiv preprint\narXiv:1912.02164.\n[Davis and Mohammad 2014] Davis, H., and Mohammad,\nS. M. 2014. Generating music from literature. Proceedings of the 3rd Workshop on Computational Linguistics for\nLiterature (CLfL) 1\u201310.\n[Devlin et al. 2018] Devlin, J.; Chang, M.-W.; Lee, K.; and\nToutanova, K. 2018. Bert: Pre-training of deep bidirectional\ntransformers for language understanding.\narXiv preprint\narXiv:1810.04805.\n[Ferreira and Whitehead 2019] Ferreira, L. N., and Whitehead, J. 2019. Learning to generate music with sentiment.\nIn Proceedings of the International Society for Music Information Retrieval Conference, ISMIR\u201919.\n[Hadjeres, Pachet, and Nielsen 2017] Hadjeres, G.; Pachet,\nF.; and Nielsen, F. 2017. Deepbach: a steerable model for\nbach chorales generation. In International Conference on\nMachine Learning, 1362\u20131371.\n[Hawthorne et al. 2019] Hawthorne,\nC.;\nStasyuk,\nA.;\nRoberts, A.; Simon, I.; Huang, C.-Z. A.; Dieleman, S.;\nElsen, E.; Engel, J.; and Eck, D. 2019. Enabling factorized\npiano music modeling and generation with the MAESTRO dataset.\nIn International Conference on Learning\nRepresentations.\n[Keskar et al. 2019] Keskar, N. S.; McCann, B.; Varshney,\nL. R.; Xiong, C.; and Socher, R.\n2019.\nCtrl: A conditional transformer language model for controllable generation. arXiv preprint arXiv:1909.05858.\n[Kingma and Ba 2014] Kingma, D., and Ba, J. 2014. Adam:\nA method for stochastic optimization. International Conference on Learning Representations.\n[Kool, Hoof, and Welling 2019] Kool, W.; Hoof, H. V.; and\nWelling, M.\n2019.\nStochastic beams and where to find\nthem: The Gumbel-top-k trick for sampling sequences without replacement. In Chaudhuri, K., and Salakhutdinov, R.,\neds., Proceedings of the 36th International Conference on\nMachine Learning, volume 97 of Proceedings of Machine\nLearning Research, 3499\u20133508.\n[Monteith, Martinez, and Ventura 2010] Monteith, K.; Martinez, T. R.; and Ventura, D. 2010. Automatic generation\nof music for inducing emotive response. In International\nConference on Computational Creativity, 140\u2013149.\n[Oore et al. 2017] Oore, S.; Simon, I.; Dieleman, S.; and\nEck, D. 2017. Learning to create piano performances. In\nNIPS 2017 Workshop on Machine Learning for Creativity\nand Design.\n[Padovani, Ferreira, and Lelis 2017] Padovani, R.; Ferreira,\nL. N.; and Lelis, L. H. S. 2017. Bardo: Emotion-based music\nrecommendation for tabletop role-playing games. In Proceedings of the AAAI Conference on Artificial Intelligence\nand Interactive Digital Entertainment.\n[Padovani, Ferreira, and Lelis 2019] Padovani, R.; Ferreira,\nL. N.; and Lelis, L. H. S. 2019. Be inaccurate but dont\nbe indecisive: How error distribution can affect user experience. In Proceedings of the AAAI Conference on Artificial\nIntelligence, 2604\u20132611.\n[Poole and Mackworth 2010] Poole, D. L., and Mackworth,\nA. K. 2010. Artificial Intelligence: foundations of computational agents. Cambridge University Press.\n[Radford et al. 2018] Radford, A.; Narasimhan, K.; Salimans, T.; and Sutskever, I. 2018. Improving language understanding by generative pre-training. In Arxiv.\n[Radford et al. 2019] Radford, A.; Wu, J.; Child, R.; Luan,\nD.; Amodei, D.; and Sutskever, I. 2019. Language models\nare unsupervised multitask learners. OpenAI Blog 1(8):9.\n[Raffel 2016] Raffel, C.\n2016.\nLearning-based methods\nfor comparing sequences, with applications to audio-to-midi\nalignment and matching. Ph.D. Dissertation, Columbia University.\n[Russell 1980] Russell, J. A.\n1980.\nA circumplex model\nof affect.\nJournal of personality and social psychology\n39(6):1161.\n[Vijayakumar et al. 2018] Vijayakumar, A. K.; Cogswell,\nM.; Selvaraju, R. R.; Sun, Q.; Lee, S.; Crandall, D.; and Batra, D. 2018. Diverse beam search for improved description\nof complex scenes. In Thirty-Second AAAI Conference on\nArtificial Intelligence.\n[Williams et al. 2015a] Williams, D.; Kirke, A.; Eaton, J.;\nMiranda, E.; Daly, I.; Hallowell, J.; Roesch, E.; Hwang, F.;\nand Nasuto, S. J. 2015a. Dynamic game soundtrack generation in response to a continuously varying emotional trajectory. In 56th International Conference: Audio for Games.\nAudio Engineering Society.\n[Williams et al. 2015b] Williams, D.; Kirke, A.; Miranda,\nE. R.; Roesch, E.; Daly, I.; and Nasuto, S. 2015b. Investigating affect in algorithmic composition systems. Psychology\nof Music 43(6):831\u2013854.\n[Wu et al. 2016] Wu, Y.; Schuster, M.; Chen, Z.; Le, Q. V.;\nNorouzi, M.; Macherey, W.; Krikun, M.; Cao, Y.; Gao, Q.;\nMacherey, K.; et al. 2016. Google\u2019s neural machine translation system: Bridging the gap between human and machine\ntranslation. arXiv preprint arXiv:1609.08144.\n[Zhu et al. 2015] Zhu, Y.; Kiros, R.; Zemel, R.; Salakhutdinov, R.; Urtasun, R.; Torralba, A.; and Fidler, S.\n2015.\nAligning books and movies: Towards story-like visual explanations by watching movies and reading books. In Proceedings of the IEEE international conference on computer\nvision, 19\u201327.\n\f", "text_mmd": null}, "BIBREF356": {"title": "The million song dataset", "authors": [{"first": "Thierry", "middle": [], "last": "Bertin-Mahieux", "suffix": ""}, {"first": "Daniel", "middle": [], "last": "PW Ellis", "suffix": ""}, {"first": "Brian", "middle": [], "last": "Whitman", "suffix": ""}, {"first": "Paul", "middle": [], "last": "Lamere", "suffix": ""}], "venue": "ISMIR", "volume": "", "issue": "", "pages": "591--596", "text_pymu": "THE MILLION SONG DATASET\nThierry Bertin-Mahieux, Daniel P.W. Ellis\nColumbia University\nLabROSA, EE Dept.\n{thierry, dpwe}@ee.columbia.edu\nBrian Whitman, Paul Lamere\nThe Echo Nest\nSomerville, MA, USA\n{brian, paul}@echonest.com\nABSTRACT\nWe introduce the Million Song Dataset, a freely-available\ncollection of audio features and metadata for a million contemporary popular music tracks. We describe its creation\nprocess, its content, and its possible uses. Attractive features of the Million Song Database include the range of existing resources to which it is linked, and the fact that it is the\nlargest current research dataset in our field. As an illustration, we present year prediction as an example application,\na task that has, until now, been difficult to study owing to\nthe absence of a large set of suitable data. We show positive\nresults on year prediction, and discuss more generally the\nfuture development of the dataset.\n1. INTRODUCTION\n\u201cThere is no data like more data\u201d said Bob Mercer of IBM\nin 1985 [7], highlighting a problem common to many fields\nbased on statistical analysis. This problem is aggravated in\nMusic Information Retrieval (MIR) by the delicate question of licensing. Smaller datasets have ignored the issue\n(e.g. GZTAN [11]) while larger ones have resorted to solutions such as using songs released under Creative Commons\n(Magnatagatune [9]).\nThe Million Song Dataset (MSD) is our attempt to help\nresearchers by providing a large-scale dataset. The MSD\ncontains metadata and audio analysis for a million songs that\nwere legally available to The Echo Nest. The songs are representative of recent western commercial music. The main\npurposes of the dataset are:\n\u2022 to encourage research on algorithms that scale to commercial sizes;\n\u2022 to provide a reference dataset for evaluating research;\nPermission to make digital or hard copies of all or part of this work for\npersonal or classroom use is granted without fee provided that copies are\nnot made or distributed for profit or commercial advantage and that copies\nbear this notice and the full citation on the first page.\nc\u20dd 2011 International Society for Music Information Retrieval.\n\u2022 as a shortcut alternative to creating a large dataset\nwith The Echo Nest\u2019s API;\n\u2022 to help new researchers get started in the MIR field.\nSome have questioned the ability of conferences like ISMIR\nto transfer technologies into the commercial world, with\nscalability a common concern. Giving researchers a chance\nto apply their algorithms to a dataset of a million songs is a\nstep in the right direction.\n2. THE DATASET\n2.1 Why?\nThe idea for the Million Song Dataset arose a couple of\nyears ago while discussing ideas for a proposal to the US\nNational Science Foundation\u2019s GOALI (Grant Opportunities for Academic Liaison with Industry) program. We wanted\nan idea that would not be possible without academic-industrial\ncollaboration, and that would appeal to the NSF as contributing to scientific progress.\nOne of the long-standing criticisms of academic music\ninformation research from our colleagues in the commercial\nsphere is that the ideas and techniques we develop are simply not practical for real services, which must offer hundreds\nof thousands of tracks at a minimum. But, as academics,\nhow can we develop scalable algorithms without the largescale datasets to try them on? The idea of a \u201cmillion song\ndataset\u201d started as a flippant suggestion of what it would\ntake to solve this problem. But the idea stuck \u2013 not only in\nthe form of developing a very large, common dataset, but\neven in the specific scale of one million tracks.\nThere are a several possible reasons why the community\ndoes not already have a dataset of this scale:\n\u2022 We all already have our favorite, personal datasets of\nhundreds or thousands of tracks, and to a large extent\nwe are happy with the results we get from them.\n\u2022 Collecting the actual music for a dataset of more than\na few hundred CDs (i.e. the kind of thing you can do\nby asking all your colleagues to lend you their collections) becomes something of a challenge.\n\f\u2022 The well-known antagonistic stance of the recording\nindustry to the digital sharing of their data seems to\ndoom any effort to share large music collections.\n\u2022 It is simply a lot of work to manage all the details for\nthis amount of data.\nOn the other hand, there are some obvious advantages to\ncreating a large dataset:\n\u2022 A large dataset helps reveal problems with algorithm\nscaling that may not be so obvious or pressing when\ntested on small sets, but which are critical to realworld deployment.\n\u2022 Certain kinds of relatively-rare phenomena or patterns\nmay not be discernable in small datasets, but may lead\nto exciting, novel discoveries from large collections.\n\u2022 A large dataset can be relatively comprehensive, encompassing various more specialized subsets. By having all subsets within a single universe, we can have\nstandardized data fields, features, etc.\n\u2022 A single, multipurpose, freely-available dataset greatly\npromotes direct comparisons and interchange of ideas\nand results.\nA quick look at other sources in Table 1 confirms that\nthere have been many attempts at providing larger and more\ndiverse datasets. The MSD stands out as the largest currently available for researchers.\ndataset\n# songs / samples\naudio\nRWC\n465\nYes\nCAL500\n502\nNo\nGZTAN genre\n1, 000\nYes\nUSPOP\n8, 752\nNo\nSwat10K\n10, 870\nNo\nMagnatagatune\n25, 863\nYes\nOMRAS2\n50, 000?\nNo\nMusiCLEF\n200, 000\nYes\nMSD\n1, 000, 000\nNo\nTable 1. Size comparison with some other datasets.\n2.2 Creation\nThe core of the dataset comes from The Echo Nest API [5].\nThis online resource provides metadata and audio analysis\nfor millions of tracks and powers many music applications\non the web, smart phones, etc. We had unlimited access to\nthe API and used the python wrapper pyechonest 1 . We cap-\n1 http://code.google.com/p/pyechonest/\ntured most of the information provided, ranging from timbre analysis on a short time-scale, to global artist similarity. From a practical point of view, it took us 5 threads running non-stop for 10 days to gather the dataset. All the code\nwe used is available, which would allow data on additional\ntracks to be gathered in the same format. Some additional\ninformation was derived from a local musicbrainz server [2].\n2.3 Content\nThe MSD contains audio features and metadata for a million\ncontemporary popular music tracks. It contains:\n\u2022 280 GB of data\n\u2022 1, 000, 000 songs/files\n\u2022 44, 745 unique artists\n\u2022 7, 643 unique terms (Echo Nest tags)\n\u2022 2, 321 unique musicbrainz tags\n\u2022 43, 943 artists with at least one term\n\u2022 2, 201, 916 asymmetric similarity relationships\n\u2022 515, 576 dated tracks starting from 1922\nThe data is stored using HDF5 format 2 to efficiently\nhandle the heterogeneous types of information such as audio features in variable array lengths, names as strings, longitude/latitude, similar artists, etc. Each song is described\nby a single file, whose contents are listed in Table 2.\nThe main acoustic features are pitches, timbre and loudness, as defined by the Echo Nest Analyze API. The API\nprovides these for every \u201csegment\u201d, which are generally delimited by note onsets, or other discontinuities in the signal. The API also estimates the tatums, beats, bars (usually\ngroups of 3 or 4 beats) and sections. Figure 1 shows beataligned timbre and pitch vectors, which both consist of 12\nelements per segment. Peak loudness is also shown.\n0\n50\n100\n150\n200\n250\ntimbre\n0\n6\n12\nBeat-aligned features for Wolfmother - Cosmonaut (sample)\n0\n50\n100\n150\n200\n250\npitches\n0\n6\n12\n0\n50\n100\n150\n200\n250\n300\nloudness max\n-2\n-5\n-8\ndB\nFigure 1. Example of audio features (timbre, pitches and\nloudness max) for one song.\n2 http://www.hdfgroup.org/HDF5/\n\fanalysis sample rate\nartist 7digitalid\nartist familiarity\nartist hotttnesss\nartist id\nartist latitude\nartist location\nartist longitude\nartist mbid\nartist mbtags\nartist mbtags count\nartist name\nartist playmeid\nartist terms\nartist terms freq\nartist terms weight\naudio md5\nbars confidence\nbars start\nbeats confidence\nbeats start\ndanceability\nduration\nend of fade in\nenergy\nkey\nkey confidence\nloudness\nmode\nmode confidence\nnum songs\nrelease\nrelease 7digitalid\nsections confidence\nsections start\nsegments confidence\nsegments loudness max\nsegments loudness max time\nsegments loudness start\nsegments pitches\nsegments start\nsegments timbre\nsimilar artists\nsong hotttnesss\nsong id\nstart of fade out\ntatums confidence\ntatums start\ntempo\ntime signature\ntime signature confidence\ntitle\ntrack 7digitalid\ntrack id\nyear\nTable 2. List of the 55 fields provided in each per-song\nHDF5 file in the MSD.\nThe website [1] is a core component of the dataset. It\ncontains tutorials, code samples 3 , an FAQ, and the pointers\nto the actual data, generously hosted by Infochimps 4 .\n2.4 Links to other resources\nThe Echo Nest API can be used alongside the Million Song\nDataset since we provide all The Echo Nest identifiers (track,\nsong, album, artist) for each track. The API can give updated values for temporally-changing attributes (song hotttnesss, artist familiarity, ...) and also provides some data\nnot included in the MSD, such as links to album cover art,\nartist-provided audio urls (where available), etc.\nAnother very large dataset is the recently-released Yahoo Music Ratings Datasets 5 . Part of this links user ratings\nto 97, 954 artists; 15, 780 of these also appear in the MSD.\nFortunately, the overlap constitutes the more popular artists,\nand accounts for 91% of the ratings. The combination of the\ntwo datasets is, to our knowledge, the largest benchmark for\nevaluating content-based music recommendation.\nThe Echo Nest has partnered with 7digital 6 to provide\nthe 7digital identifier for all tracks in the MSD. A free 7dig-\n3 https://github.com/tb2332/MSongsDB\n4 http://www.infochimps.com/\n5 http://webscope.sandbox.yahoo.com/\n6 http://www.7digital.com\nital account lets you fetch 30 seconds samples of songs (up\nto some cap), which is enough for sanity checks, games, or\nuser experiments on tagging. It might be feasible to compute some additional audio features on these samples, but\nonly for a small portion of the dataset.\nTo support further linking to other sources of data, we\nprovide as many identifiers as available, including The Echo\nNest identifiers, the musicbrainz artist identifier, the 7digital and playme 7 identifiers, plus the artist, album and song\nnames. For instance, one can use MusiXmatch 8 to fetch\nlyrics for many of the songs. Their API takes Echo Nest\nidentifiers, and will also perform searches on artist and song\ntitle. We will return to musiXmatch in the next section.\n3. PROPOSED USAGE\nA wide range of MIR tasks could be performed or measured\non the MSD. Here, we give a somewhat random sample of\npossible uses based on the community\u2019s current interests,\nwhich serves to illustrate the breadth of data available in the\ndataset.\n3.1 Metadata analysis\nThe original intention of the dataset was to release a large\nvolume of audio features for machine learning algorithms.\nThat said, analyzing metadata from a million song is also\nextremely interesting. For instance, one could address questions like: Are all the \u201cgood\u201d artist names already taken?\nDo newer bands have to use longer names to be original?\nThis turns out to be false according to the MSD: The average length might even be reducing, although some recent\noutliers use uncommonly long names. The Figure 2 summarizes this. The least squared regression has parameters:\ngradient = \u22120.022 characters/year and intercept = 55.4 characters (the extrapolated length of a band name at year 0!).\n1920\n1940\n1960\n1980\n2000\n2020\nyear\n0\n50\n100\n150\n200\n250\nartist name length\nArtist name length per year\nartist name lengths\nleast squared regression\nFigure 2. Artist name length as a function of year.\n3.2 Artist recognition\nRecognizing the artist from the audio is a straightforward\ntask that provides a nice showcase of both audio features\nand machine learning. In the MSD, a reasonable target is\n7 http://www.playme.com\n8 http://www.musixmatch.com\n\fthe 18, 073 artists that have at least 20 songs in the dataset\n(in contrast to the 5 artists reported a decade ago in [12]).\nWe provide two standard training/test splits, the more difficult of which contains just 15 songs from each artist in the\ntraining set. This prevents the use of artist popularity. Our\nbenchmark k-NN algorithm has an accuracy of 4% (code\nprovided), which leaves plenty of room for improvement.\n3.3 Automatic music tagging\nAutomatic tagging [4] has been a core MIR tasks for the last\nfew years. The Echo Nest provides tags (called \u201cterms\u201d) at\nthe artist level, and we also retrieved the few terms provided\nby musicbrainz. A sample is shown in Table 3. We split all\nartists between train and test based on the 300 most popular\nterms from The Echo Nest. This makes it the largest available dataset for tagging evaluation, as compared to Magnatagatune [9], Swat10K [10] and the Last.FM corpus in [3].\nThat said, the MSD currently lacks any tags at the song,\nrather than the artist, level. We would welcome the contribution of such tags.\nAlthough less studied, the correlation between tags and\nmetadata could be of great interest in a commercial system. Certain \u201cgenre tags\u201d, such as \u201cdisco\u201d, usually apply\nto songs released in the 70s. There are also correlations between artist names and genres; you can probably guess the\nkind of music the band Disembowelment plays (if you are\nnot already a fan).\nartist\nEN terms\nmusicbrainz tags\nadult contemporary\nhard rock\nBon Jovi\narena rock\nglam metal\n80s\namerican\nteen pop\npop\nBritney Spears\nsoft rock\namerican\nfemale\ndance\nTable 3. Example of tags for two artists, as provided by The\nEcho Nest and musicbrainz.\n3.4 Recommendation\nMusic recommendation and music similarity are perhaps\nthe best-studied areas in MIR. One reason is the potential\ncommercial value of a working system. So far, contentbased system have fallen short at predicting user ratings\nwhen compared to collaborative filtering methods. One can\nargue that ratings are only one facet of recommendation\n(since listeners also value novelty and serendipity [6]), but\nthey are essential to a commercial system.\nThe Yahoo Music Ratings Datasets, mentioned above,\nopens the possibility of a large scale experiment on predicting ratings based on audio features with a clean ground\nRicky Martin\nWeezer\nEnrique Iglesias\nDeath Cab for Cutie\nChristina Aguilera\nThe Smashing Pumpkins\nShakira\nFoo Fighters\nJennifer Lopez\nGreen Day\nTable 4. Some similar artists according to The Echo Nest.\ntruth. This is unlikely to settle the debate on the merit of\ncontent-based music recommendation once and for all, but\nit should support the discussion with better numbers.\n3.5 Cover song recognition\nCover song recognition has generated many publications in\nthe past few years. One motivation behind this task is the\nbelief that finding covers relies on understanding something\ndeeper about the structure of a piece. We have partnered\nwith Second Hand Songs, a community-driven database of\ncover songs, to provide the SecondHandSong dataset 9 . It\ncontains 18, 196 cover songs grouped into 5, 854 works (or\ncliques). For comparison, the MIREX 2010 Cover Song\nevaluation used 869 queries. Since most of the work on\ncover recognition has used variants of the chroma features\nwhich are included in the MSD (pitches), it is now the largest\nevaluation set for this task.\n3.6 Lyrics\nIn partnership with musiXmatch (whose API was mentioned\nabove), we have released the musiXmatch dataset 10 , a collection of lyrics from 237, 662 tracks of the MSD. The lyrics\ncome in a bag-of-words format and are stemmed, partly for\ncopyright reasons. Through this dataset, the MSD links audio features, tags, artist similarity, etc., to lyrics.\nAs an\nexample, mood prediction from lyrics (a recently-popular\ntopic) could be investigated with this data.\n3.7 Limitations\nTo state the obvious, there are many tasks not suited for the\nMSD. Without access to the original audio, the scope for\nnovel acoustic representations is limited to those that can be\nderived from the Echo Nest features. Also, the dataset is\ncurrently lacking album and song-level metadata and tags.\nDiversity is another issue: there is little or no world, ethnic,\nand classical music.\n9 SecondHandSongs dataset, the official list of cover songs within\nthe Million Song Dataset,\navailable at:\nhttp://labrosa.ee.\ncolumbia.edu/millionsong/secondhand\n10 musiXmatch dataset, the official lyrics collection for the Million\nSong Dataset, available at: http://labrosa.ee.columbia.edu/\nmillionsong/musixmatch\n\fTasks that require very accurate time stamps can be problematic. Even if you have the audio for a song that appears\nin the MSD, there is little guarantee that the features will\nhave been computed on the same audio track.\nThis is a\ncommon problem when distributing audio features, originating from the numerous official releases of any given song as\nwell as the variety of ripping and encoding schemes in use.\nWe hope to address the problem in two ways. First, if you\nupload audio to The Echo Nest API, you will get a timeaccurate audio analysis that can be formatted to match the\nrest of the MSD (code provided). Secondly, we plan to provide a fingerprinter that can be use to resolve and align local\naudio with the MSD audio features.\n4. YEAR PREDICTION\nAs shown in the previous section, many tasks can be addressed using the MSD. We present year prediction as a case\nstudy for two reasons: (1) it has been little studied, and (2)\nit has practical applications in music recommendation.\nWe define year prediction as estimating the year in which\na song was released based on its audio features. (Although\nmetadata features such as artist name or similar artist tags\nwould certainly be informative, we leave this for future work).\nListeners often have particular affection for music from certain periods of their lives (such as high school), thus the\npredicted year could be a useful basis for recommendation.\nFurthermore, a successful model of the variation in music\naudio characteristics through the years could throw light on\nthe long-term evolution of popular music.\nIt is hard to find prior work specifically addressing year\nprediction. One reasons is surely the lack of a large music collection spanning both a wide range of genres (at least\nwithin western pop) and a long period of time. Note, however, that many music genres are more or less explicitly associated with specific years, so this problem is clearly related to genre recognition and automatic tagging [4].\n4.1 Data\nThe \u201cyear\u201d information was inferred by matching the MSD\nsongs against the musicbrainz database, which includes a\nyear-of-release field. This resulted in values for 515, 576\ntracks representing 28, 223 artists. Errors could creep into\nthis data from two main sources: incorrect matching, and\nincorrect information in musicbrainz. Informal inspection\nsuggests the data is mostly clean; instead, the main issue\nis the highly nonuniform distribution of data per year, as\nshown in Figure 3. A baseline, uniform prediction at the\nmode or mean year would give reasonable accuracy figures\nbecause of the narrow peak in the distribution around 2007.\nHowever, we have enough data to be able to show that even\nsmall improvements in average accuracy are statistically significant: With 2, 822 test artists and using a z-test with a\n95% confidence level, an improvement of 1.8 years is significant. Allowing some independence between the songs\nfrom a single artist reduces that number still more.\n25\n45\n65\n85\n05\n0\n5000\n10000\n15000\n20000\n25000\n30000\n35000\n40000\nnumber of songs per year\n25\n45\n65\n85\n05\n0\n500\n1000\n1500\n2000\n2500\nnumber of artists per year\nFigure 3. Distribution of MSD tracks for which release year\nis available, from 1922 to 2011. An artist\u2019s \u201cyear\u201d value is\nthe average of their songs.\nAgain, we define and publish a split between train and\ntest artists so future results can be directly comparable. The\nsplit is among artists and not songs in order to avoid problems such as the \u201cproducer effect\u201d. The features we use are\nthe average and covariance of the timbre vectors for each\nsong. No further processing is performed. Using only the\nnonredundant values from the covariance matrix gives us a\nfeature vector of 90 elements per track.\n4.2 Methods\nOur first benchmark method is k nearest neighbors (k-NN),\nwhich is easy to parallelize and requires only a single pass\nover the training set, given enough memory. Prediction can\nefficiently performed thanks to libraries such as ANN 11 .\nThe predicted year of a test item is the average year of the k\nnearest training songs.\nA more powerful algorithm, specifically designed for largescale learning, is Vowpal Wabbit [8] (VW). It performs regression by learning a linear transformation w of the features x using gradient descent, so that the predicted value \u02c6yi\nfor item i is:\n\u02c6yi =\n\ufffd\nj\nwjxi\nj\nYear values are linearly mapped onto [0, 1] using 1922 as 0\nand 2011 as 1. Once the data is cached, VW can do many\npasses over the training set in a few minutes. VW has many\nparameters; we performed an exhaustive set of experiments\nusing a range of parameters on a validation set. We report\nresults using the best parameters from this search according\nto the average difference measure. The final model is trained\non the whole training set.\n4.3 Evaluation and results\nTable 5 presents both average absolute difference and square\nroot of the average squared difference between the predicted\nrelease year and the actual year.\n11 http://www.cs.umd.edu/\u02dcmount/ANN/\n\fmethod\ndiff\nsq. diff\nconstant pred.\n8.13\n10.80\n1-NN\n9.81\n13.99\n50-NN\n7.58\n10.20\nvw\n6.14\n8.76\nTable 5. Results on year prediction on the test songs.\nThe benchmark is the \u201cconstant prediction\u201d method, where\nwe always predict the average release year from the training\nset (1998.4). With VW 12 we can make a significant improvement on this baseline.\n5. THE FUTURE OF THE DATASET\nTime will tell how useful the MSD proves to be, but here\nare our thoughts regarding what will become of this data.\nWe have assemble a dataset which we designed to be comprehensive and detailed enough to support a very wide range\nof music information research tasks for at least the near future. Our hope is that the Million Song Dataset becomes\nthe natural choice for researchers wanting to try out ideas\nand algorithms on data that is standardized, easily obtained,\nand relevant to both academia and industry. If we succeed,\nour field can be greatly strengthened through the use of a\ncommon, relevant dataset.\nBut for this to come true, we need lots of people to use\nthe data. Naturally, we want our investment in developing\nthe MSD to have as much positive impact as possible. Although the effort so far has been limited to the authors, we\nhope that it will become a true community effort as more\nand more researchers start using and supporting the MSD.\nOur vision is of many different individuals and groups developing and contributing additional data, all referenced to\nthe same underlying dataset. Sharing this augmented data\nwill further improve its usefulness, while preserving as far\nas possible the commonality and comparability of a single\ncollection.\n5.1 Visibility for MIR\nThe MSD has good potential to enhance the visibility of the\nMIR community in the wider research world. There have\nbeen numerous discussions and comments on how our field\nseems to take more that it gives back from other areas such\nas machine learning and vision. One reason could be the absence of a well-known common data set that could allow our\nresults to be reported in conferences not explicitly focused\non music and audio. We hope that the scale of the MSD will\nattract the interest of other fields, thus making MIR research\n12 The parameters to VW were \u2013passes 100 \u2013loss function squared -l 100\n\u2013initial t 100000 \u2013decay learning rate 0.707106781187.\na source of ideas and relevant practice. To that end, subsets\nof the dataset will be made available on the UCI Machine\nLearning Repository 13 . We consider such dissemination of\nMIR data essential to the future health of our field.\n6. ACKNOWLEDGEMENTS\nThis work is supported by NSF grant IIS-0713334 and by a gift\nfrom Google, Inc. Any opinions, findings and conclusions or recommendations expressed in this material are those of the authors\nand do not necessarily reect the views of the sponsors. TBM is\nsupported in part by a NSERC scholarship.\n7. REFERENCES\n[1] Million\nSong\nDataset,\nofficial\nwebsite\nby\nThierry\nBertin-Mahieux,\navailable at:\nhttp://labrosa.ee.\ncolumbia.edu/millionsong/.\n[2] Musicbrainz: a community music metadatabase, Feb. 2011.\nMusicBrainz is a project of The MetaBrainz Foundation,\nhttp://metabrainz.org/.\n[3] T. Bertin-Mahieux, D. Eck, F. Maillet, and P. Lamere. Autotagger: a model for predicting social tags from acoustic features\non large music databases. Journal of New Music Research, special issue: \u201dFrom genres to tags: Music Information Retrieval\nin the era of folksonomies.\u201d, 37(2), June 2008.\n[4] T. Bertin-Mahieux, D. Eck, and M. Mandel. Automatic tagging of audio: The state-of-the-art. In Wenwu Wang, editor,\nMachine Audition: Principles, Algorithms and Systems, pages\n334\u2013352. IGI Publishing, 2010.\n[5] The Echo Nest Analyze,\nAPI, http://developer.\nechonest.com.\n[6] J. L. Herlocker, J. A. Konstan, L. G. Terveen, and J. T. Riedl.\nEvaluating collaborative filtering recommender systems. ACM\nTrans. Inf. Syst., 22(1):5\u201353, 2004.\n[7] F.\nJelinek,\n2004.\nhttp://www.lrec-conf.org/\nlrec2004/doc/jelinek.pdf.\n[8] J. Langford, L. Li, and A. L. Strehl. Vowpal wabbit (fast online\nlearning), 2007. http://hunch.net/vw/.\n[9] E. Law and L. von Ahn. Input-agreement: a new mechanism\nfor collecting data using human computation games. In Proceedings of the 27th international conference on Human factors in computing systems, pages 1197\u20131206. ACM, 2009.\n[10] D. Tingle, Y.E. Kim, and D. Turnbull. Exploring automatic music annotation with acoustically-objective tags. In Proceedings\nof the international conference on Multimedia information retrieval, pages 55\u201362. ACM, 2010.\n[11] G. Tzanetakis and P. Cook. Musical genre classification of\naudio signals. IEEE Trans. on Speech and Audio Processing,\n10(5):293\u2013302, 2002.\n[12] B. Whitman, G. Flake, and S. Lawrence. Artist detection in\nmusic with minnowmatch. In Neural Networks for Signal Processing XI, 2001. Proceedings of the 2001 IEEE Signal Processing Society Workshop, pages 559\u2013568. IEEE, 2002.\n13 http://archive.ics.uci.edu/ml/\n\f", "text_mmd": null}, "BIBREF357": {"title": "A database linking piano and orchestral midi scores with application to automatic projective orchestration", "authors": [{"first": "L\u00e9opold", "middle": [], "last": "Crestel", "suffix": ""}, {"first": "Philippe", "middle": [], "last": "Esling", "suffix": ""}, {"first": "Lena", "middle": [], "last": "Heng", "suffix": ""}, {"first": "Stephen", "middle": [], "last": "McAdams", "suffix": ""}], "venue": "arXiv preprint", "volume": "", "issue": "", "pages": "", "text_pymu": "A DATABASE LINKING PIANO AND ORCHESTRAL MIDI SCORES WITH\nAPPLICATION TO AUTOMATIC PROJECTIVE ORCHESTRATION\nL\u00b4eopold Crestel1\nPhilippe Esling1\nLena Heng2\nStephen McAdams2\n1 Music Representations, IRCAM, Paris, France\n2 Schulich School of Music, McGill University, Montr\u00b4eal, Canada\nleopold.crestel@ircam.fr\nABSTRACT\nThis article introduces the Projective Orchestral Database\n(POD), a collection of MIDI scores composed of pairs\nlinking piano scores to their corresponding orchestrations.\nTo the best of our knowledge, this is the first database of\nits kind, which performs piano or orchestral prediction, but\nmore importantly which tries to learn the correlations between piano and orchestral scores. Hence, we also introduce the projective orchestration task, which consists in\nlearning how to perform the automatic orchestration of a\npiano score. We show how this task can be addressed using\nlearning methods and also provide methodological guidelines in order to properly use this database.\n1. INTRODUCTION\nOrchestration is the subtle art of writing musical pieces for\nthe orchestra by combining the properties of various instruments in order to achieve a particular musical idea [11,23].\nAmong the variety of writing techniques for orchestra, we\ndefine as projective orchestration [8] the technique which\nconsists in first writing a piano score and then orchestrating\nit (akin to a projection operation, as depicted in Figure 1).\nThis technique has been used by classic composers for centuries. One such example is the orchestration by Maurice\nRavel of Pictures at an Exhibition, a piano work written by\nModest Mussorgsky. This paper introduces the first dataset\nof musical scores dedicated to projective orchestrations. It\ncontains pairs of piano pieces associated with their orchestration written by famous composers. Hence, the purpose\nof this database is to offer a solid knowledge for studying\nthe correlations involved in the transformation from a piano to an orchestral score.\nThe remainder of this paper is organized as follows.\nFirst, the motivations for a scientific investigation of orchestration are exposed (section 2).\nBy reviewing the\nprevious attempts, we highlight the specific need for a\nc\u20dd L\u00b4eopold Crestel, Philippe Esling, Lena Heng, Stephen\nMcAdams. Licensed under a Creative Commons Attribution 4.0 International License (CC BY 4.0). Attribution: L\u00b4eopold Crestel, Philippe\nEsling, Lena Heng, Stephen McAdams. \u201cA database linking piano and\norchestral MIDI scores with application to automatic projective orchestration\u201d, 18th International Society for Music Information Retrieval Conference, Suzhou, China, 2017.\nPiano\nscore\nOrchestra\nscore\nOrchestration\nFigure 1. Projective orchestration of the first three bars\nof Modest Mussorgsky\u2019s piano piece Pictures at an Exhibition by Maurice Ravel. Piano notes are assigned to one\nor several instruments, possibly with doubling or harmonic\nenhancement.\nsymbolic database of piano and corresponding orchestral\nscores. In an attempt to fill this gap, we built the Projective\nOrchestral Database (POD) and detail its structure in section 3. In section 4, the automatic projective orchestration\ntask is proposed as an evaluation framework for automatic\norchestration systems. We report our experiment with a\nset of learning-based models derived from the Restricted\nBoltzmann Machine [26] and introduce their performance\nin the previously defined evaluation framework. Finally, in\nsection 5 we provide methodological guidelines and conclusions.\n2. A SCIENTIFIC INVESTIGATION OF\nORCHESTRATION\nOver the past centuries, several treatises have been written\nby renowned composers in an attempt to decipher some\nguiding rules in orchestration [11, 21, 23]. Even though\nthey present a remarkable set of examples, none of them\nbuilds a systemic set of rules towards a comprehensive theory of orchestration. The reason behind this lack lies in\nthe tremendous complexity that emerges from orchestral\nworks. A large number of possible sounds can be created\nby combining the pitch and intensity ranges of each instru-\narXiv:1810.08611v1  [cs.SD]  19 Oct 2018\n\fments in a symphonic orchestra. Furthermore, during a\nperformance, the sound produced by a mixture of instruments is also the result of highly non-linear acoustic effects. Finally, the way we perceive those sounds involves\ncomplex psychoacoustic phenomena [14,16,25]. It seems\nalmost impossible for a human mind to grasp in its entirety\nthe intertwined mechanisms of an orchestral rendering.\nHence, we believe that a thorough scientific investigation could help disentangle the multiple factors involved in\norchestral works. This could provide a first step towards\na greater understanding of this complex and widely uncharted discipline. Recently, major works have refined our\nunderstanding of the perceptual and cognitive mechanisms\nspecifically involved when listening to instrumental mixtures [15, 22, 25]. Orchids, an advanced tool for assisting\ncomposers in the search of a particular sonic goal has been\ndeveloped [8]. It relies on the multi-objective optimization of several spectro-temporal features such as those described in [20].\nHowever, few attempts have been made to tackle a scientific exploration of orchestration based on the study of\nmusical scores. Yet, symbolic representations implicitly\nconvey high-level information about the spectral knowledge composers have exploited for timbre manipulations.\nIn [6] a generative system for orchestral music is introduced. Given a certain style, the system is able to generate\na melodic line and its accompaniment by a full symphonic\norchestra. Their approach relies on a set of templates and\nhand-designed rules characteristic of different styles. [19]\nis a case study of how to automatically transfer the Ode\nto joy to different styles. Unfortunately, very few details\nare provided about the models used, but it is interesting to\nobserve that different models are used for different styles.\nAutomatic arrangement, which consists in reducing an orchestral score to a piano version that is can be played by\na two-hand pianist, has been tackled in [10] and [24]. The\nproposed systems rely on an automatic analysis of the orchestral score in order to split it into structuring elements.\nThen, each element is assigned a role which determines\nwhether it is played or discarded in the reduction. To the\nbest of our knowledge, the inverse problem of automatically orchestrating a piano score has never been tackled.\nHowever, we believe that unknown mechanisms of orchestration could be revealed by observing how composers perform projective orchestration, which essentially consists in\nhighlighting an existing harmonic, rhythmic and melodic\nstructure of a piano piece through a timbral structure.\nEven though symbolic data are generally regarded as\na more compact representation than a raw signal in the\ncomputer music field, the number of pitch combinations\nthat a symphonic orchestra can produce is extremely large.\nHence, the manipulation of symbolic data still remains\ncostly from a computational point of view. Even through\ncomputer analysis, an exhaustive investigation of all the\npossible combinations is not feasible. For that reason, the\napproaches found in the literature rely heavily on heuristics\nand hand-designed rules to limit the number of possible\nsolutions and decrease the complexity. However, the re-\ncent advents in machine learning have brought techniques\nthat can cope with the dimensionality involved with symbolic orchestral data.\nBesides, even if a wide range of\norchestrations exist for a given piano score, all of them\nwill share strong relations with the original piano score.\nTherefore, we make the assumption that projective orchestration might be a relatively simple and well-structured\ntransformation lying in a complex high-dimensional space.\nNeural networks have precisely demonstrated a spectacular ability for extracting a structured lower-dimensional\nmanifold from a high-dimensional entangled representation [13]. Hence, we believe that statistical tools are now\npowerful enough to lead a scientific investigation of projective orchestration based on symbolic data.\nThese statistical methods require an extensive amount\nof data, but there is no symbolic database dedicated to orchestration. This dataset is a first attempt to fill this gap\nby building a freely accessible symbolic database of piano\nscores and corresponding orchestrations.\n3. DATASET\n3.1 Structure of the Database\nThe database can be found on the companion website 1\nof this article, along with statistics and Python code for\nreproducibility.\n3.1.1 Organization\nThe Projective Orchestral Database (POD) contains 392\nMIDI files. Those files are grouped in pairs containing a\npiano score and its orchestral version. Each pair is stored\nin a folder indexed by a number. The files have been collected from several free-access databases [1] or created by\nprofessional orchestration teachers.\n3.1.2 Instrumentation\nAs the files gathered in the database have various origins,\ndifferent instrument names were found under a variety of\naliases and abbreviations. Hence, we provide a commaseparated value (CSV) file associated with each MIDI file\nin order to normalize the corresponding instrumentations.\nIn these files, the track names of the MIDI files are linked\nto a normalized instrument name.\n3.1.3 Metadata\nFor each folder, a CSV file with the name of the folder\ncontains the relative path from the database root directory,\nthe composer name and the piece name for the orchestral and piano works. A list of the composers present in\nthe database can be found in table 1. It is important to\nnote the imbalanced representativeness of composers in the\ndatabase. It can be problematic in the learning context we\ninvestigate, because a kind of stylistic consistency is a priori necessary in order to extract a coherent set of rules.\nPicking a subset of the database would be one solution,\nbut another possibility would be to add to the database this\nstylistic information and use it in a learning system.\n1 https://qsdfo.github.io/LOP/database\n\fComposer\nNumber of\npiano files\nPercentage\npiano frames\nNumber of\norchestra files\nPercentage\norchestra frames\nArcadelt. Jacob\n1\n0.07\nArresti. Floriano\n3\n0.57\nBach. Anna Magdalena\n3\n0.43\nBach. Johann Sebastian\n9\n4.57\n4\n0.81\nBanchieri. Adriano\n1\n0.32\nBeethoven. Ludwig Van\n1\n0.60\n38\n42.28\nBerlioz. Hector\n1\n0.14\nBrahms. Johannes\n3\n0.28\nBuxtehude. Dietrich\n1\n0.21\nByrd. William\n1\n0.13\nCharpentier. Marc-Antoine\n2\n0.38\nChopin. Frederic\n2\n0.44\nClarke. Jeremiah\n1\n0.23\nDebussy. Claude\n1\n0.59\n6\n0.90\nDvorak. Anton\n6\n2.42\nErlebach. Philipp Heinrich\n1\n0.10\nFaure. Gabriel\n1\n0.60\nFischer. Johann Caspar Ferdinand\n1\n0.10\nGluck. Christoph Willibald\n1\n1.61\nGrieg. Edvard\n1\n2.10\nGuerrero. Francisco\n1\n0.12\nHandel. George Frideric\n4\n1.00\n1\n0.75\nHaydn. Joseph\n6\n1.01\nKempff. Wilhelm\n1\n1.58\nLeontovych. Mykola\n2\n0.22\nLiszt. Franz\n34\n39.98\nMahler. Gustav\n1\n0.85\nMendelssohn. Felix\n2\n1.41\nMoussorgsky. Modest\n1\n0.04\nMozart. Wolfgang Amadeus\n1\n0.71\n8\n1.45\nOkashiro. Chitose\n3\n1.09\nPachelbel. Johann\n1\n0.15\nPraetorius. Michael\n2\n0.14\nPurcell. Henry\n1\n0.08\nRavel. Maurice\n6\n6.49\n8\n6.69\nRondeau. Michel\n2\n0.25\n1\n0.14\nSchonberg. Arnold\n1\n0.21\nSchumann. Robert\n1\n0.05\nShorter. Steve\n1\n0.26\nSmetana. Bedrich\n1\n0.61\nSoler. Antonio\n1\n0.54\nStrauss. Johann\n1\n0.04\nStrauss. Richard\n1\n0.22\nStravinsky. Igor\n4\n0.94\nTchaikovsky. Piotr Ilyich\n36\n20.08\nTelemann. Georg Philipp\n2\n1.04\nUnknown.\n107\n40.18\n28\n7.47\nVivaldi. Antonio\n4\n2.94\nWalther. Johann Gottfried\n1\n0.14\nWiberg. Steve\n1\n0.75\nZachow. Friedrich Wilhelm\n1\n0.32\n2\n0.23\nTable 1. This table describes the relative importance of the\ndifferent composers present in the database. For each composer, the number of piano (respectively orchestral) scores\nin the database are indicated in the second (respectively\nfourth) column. The total number of files is 184 x 2 = 392.\nAs the length of the files can vary significantly, a more\nsignificant indicator of a composer\u2019s representativeness in\nthe database is the ratio of the number of frames from its\nscores over the total number of frames in the database.\nFigure 2 highlights the activation ratio of each pitch in\nthe orchestration scores (\n#{pitch on}\n#{pitch on}+#{pitch off}, where # is\nthe cardinal of an ensemble) over the whole dataset. Note\nthat this activation ratio does not take the duration of notes\ninto consideration, but only their number of occurrences.\nThe pitch range of each instrument can be observed beneath the horizontal axis.\nTwo different kinds of imbalance can be observed in\nfigure 2. First, a given pitch is rarely played. Second,\nsome pitches are played more often compared with others.\nClass imbalance is known as being problematic for machine learning systems, and these two observations highlight how challenging the projective orchestration task is.\nVln. (40,101)\nFl. (38,101)\nTba. (21,66)\nBsn. (21,77)\nOrg. (35,88)\nOb. (54,94)\nPicc. (59,111) Horn (25,93)\nVc. (21,85) Tbn. (25,81)\nVla. (40,92)\nVoice (31,88)\nDb. (8,68)\nTpt. (42,92)\nClar. (35,98)\nHp. (20,107)\npitch\nFigure 2. Activation ratio per pitch in the whole orchestral score database. For one bin on the horizontal axis, the\nheight of the bar represents the number of notes played by\nthis instrument divided by the total number of frames in\nthe database. This value is computed for the event-level\naligned representations 4.2. The different instruments are\ncovered by the pitch axis, and one can observe the peaks\nthat their medium ranges form. The maximum value of the\nvertical axis (0.06), which is well below 1, indicates that\neach pitch is rarely played in the whole database.\nMore statistics about the whole database can be found on\nthe companion website.\n3.1.4 Integrity\nBoth the metadata and instrumentation CSV files have been\nautomatically generated but manually checked. We followed a conservative approach by automatically rejecting\nany score with the slightest ambiguity between a track\nname and a possible instrument (for instance bass can refer\nto double-bass or voice bass).\n3.1.5 Formats\nTo facilitate the research work, we provide pre-computed\npiano-roll representations such as the one displayed in\nFigure 3. In this case, all the MIDI files of piano (respectively orchestra) work have been transformed and concatenated into a unique two-dimensional matrix. The starting\nand ending time of each track is indicated in the metadata.pkl file. These matrices can be found in Lua/Torch\n(.t7), Matlab (.m), Python (.npy) and raw (.csv) data formats.\n3.1.6 Score Alignment\nTwo versions of the database are provided.\nThe first\nversion contains unmodified midi files.\nThe second\nversion contains MIDI files automatically aligned using the Needleman-Wunsch [18] algorithm as detailed in\n\fPitch\n&\n&\n&\n&\n?\n?\n?\nbb\nbb\nbb\nbb\nbb\nbb\nbb\n45\n45\n45\n45\n45\n45\n45\n46\n46\n46\n46\n46\n46\n46\n45\n45\n45\n45\n45\n45\n45\n46\n46\n46\n46\n46\n46\n46\nHorns 1.2.\nHorns 3.4.\nTrumpet 1 (C)\nTrumpets 2.3.\n(C)\nTrombones 1.2.\nBass Trombone\n(Trb.3)\nTuba\n\u0153- \u0153- \u0153- \u0153- \u0153 \u0153-\nf\n\u0153- \u0153 \u0153- \u0153- \u0153- \u0153- \u0153-\n\u0153\u0153- \u0153\u0153-\n\u0153\u0153-\n\u0153\u0153-\n\u0153\u0153-\n\u0153\u0153- \u0153\u0153-\n\u0153\u0153-\n\u0153\u0153-\n\u0153\u0153-\n\u0153- \u0153- \u0153- \u0153- \u0153 \u0153-\n\u0153\u0153- \u0153\u0153- \u0153\u0153-\n\u0153\u0153-\n\u0153\u0153-\n\u0153- \u0153- \u0153- \u0153\u0153-\n\u0153- \u0153- \u0153- \u0153\u0153-\nf\nf\nf\nf\nf\n\u0153\u0153-\n\u0153\u0153- \u0153\u0153-\n\u0153\u0153n- \u0153\n\u0153-\n\u0153\u0153-\n\u0153\u0153-\n\u0153\u0153- \u0153\u0153-\n\u0153\u0153- \u0153\u0153n-\n\u0153\u0153-\n\u0153- \u0153 \u0153- \u0153- \u0153- \u0153- \u0153-\n\u0153\u0153-\n\u0153\u0153- \u0153\u0153- \u0153\u0153n- \u0153\u0153- \u0153\u0153-\n\u0153- \u0153- \u0153- \u0153- \u0153n- \u0153-\n\u0153- \u0153- \u0153- \u0153- \u0153n- \u0153-\nTime\nPitch\nTrumpets\nTrombones\nHorns\nTuba\nOriginal \nscore\nPiano-roll\nrepresentation\nFigure 3. Piano-roll representation of orchestral scores.\nThe piano-roll pr is a matrix. A pitch p at time t played\nwith an intensity i is represented by pr(p, t) = i, where 0\nis a note off. This definition is extended to an orchestra by\nsimply concatenating the piano-rolls of every instrument\nalong the pitch dimension.\nSection 3.2.\n3.2 Automatic Alignment\nGiven the diverse origins of the MIDI files, a piano\nscore and its corresponding orchestration are almost never\naligned temporally. These misalignments are very problematic for learning or mining tasks, and in general for any\nprocessing which intends to take advantage of the joint\ninformation provided by the piano and orchestral scores.\nHence, we propose a method to automatically align two\nscores, and released its Python implementation on the\ncompanion website\n2 . More precisely, we consider the\npiano-roll representations (Figure 3) where the scores are\nrepresented as a sequence of vectors. By defining a distance between two vectors, the problem of aligning two\nscores can be cast as a univariate sequence-alignment problem.\n3.2.1 Needleman-Wunsch\nThe Needleman-Wunsch (NW) algorithm [18] is a dynamic\nprogramming technique, which finds the optimal alignment between two symbolic sequences by allowing the introduction of gaps (empty spaces) in the sequences. An\napplication of the NW algorithm to the automatic alignment of musical performances is introduced in [9].\nAs\npointed out in that article, NW is the most adapted technique for aligning two sequences with important structural\ndifferences like skipped parts, for instance.\nThe application of the NW algorithm relies solely on\nthe definition of a cost function, which allows the pairwise\n2 https://qsdfo.github.io/LOP/code\ncomparison of elements from the two sequences, and the\ncost of opening or extending a gap in one of the two sequences.\n3.2.2 Similarity Function\nTo measure the similarity between two chords, we propose\nthe following process:\n\u2022 discard intensities by representing notes being\nplayed as one and zero otherwise.\n\u2022 compute the pitch-class representation of the two\nvectors, which flattens all notes to a single octave\nvector (12 notes). In our case, we set the pitch-class\nto one if at least one note of the class is played. For\ninstance, we set the pitch-class of C to one if there is\nany note with pitch C played in the piano-roll vector.\nThis provides an extremely rough approximation of\nthe harmony, which proved to be sufficient for aligning two scores. After this step, the dimensions of\neach vector is 12.\n\u2022 if one of the vectors is only filled with zeros, it represents a silence, and the similarity is automatically\nset to zero (note that the score function can take negative values).\n\u2022 for two pitch-class vectors A and B, we define the\nscore as\nS(A, B) = C \u00d7\n\ufffd12\ni=1 \u03b4(Ai + Bi)\nmax(||A + B||1, 1)\n(1)\nwhere \u03b4 is defined as:\n\u03b4(x) =\n\uf8f1\n\uf8f2\n\uf8f3\n0\nif x = 0\n\u22121\nif x = 1\n1\nif x = 2\nC is a tunable parameter and ||x||1 = \ufffd\ni |xi| is the\nL1 norm.\nBased on the values recommended in [18] and our own\nexperimentations, we set C to 10. The gap-open parameter,\nwhich defines the cost of introducing a gap in one of the\ntwo sequences, is set to 3 and the gap-extend parameter,\nwhich defines the cost of extending a gap in one of the two\nsequences, is set to 1.\n4. AN APPLICATION : PROJECTIVE\nAUTOMATIC ORCHESTRATION\nIn this section, we introduce and formalize the automatic\nprojective orchestration task (Figure 1). In particular, we\npropose a system based on statistical learning and define\nan evaluation framework for using the POD database.\n4.1 Task Definition\n4.1.1 Orchestral Inference\nFor each orchestral piece, we define as O and P the aligned\nsequences of column vectors from the piano-roll of the orchestra and piano parts. We denote as T the length of the\naligned sequences O and P.\n\fThe objective of this task is to infer the present orchestral frame knowing both the recent past of the orchestra\nsequence and the present piano frame. Mathematically, it\nconsists in designing a function f where\n\u02c6O(t) = f[P(t), O(t \u2212 1), ..., O(t \u2212 N)]\n\u2200t \u2208 [N, ...T]\n(2)\nand N defines the order of the model.\n4.1.2 Evaluation Framework\nWe propose a quantitative evaluation framework based on a\none-step predictive task. As discussed in [5], we make the\nassumption that an accurate predictive model will be able\nto generate original acceptable works. Whereas evaluating\nthe generation of a complete musical score is subjective\nand difficult to quantify, a predictive framework provides\nus with a quantitative evaluation of the performance of a\nmodel. Indeed, many satisfying orchestrations can be created from the same piano score. However, the number of\nreasonable inferences of an orchestral frame given its context (as described in equation 2) is much more limited.\nAs suggested in [4,12], the accuracy measure [2] can be\nused to compare an inferred frame \u02c6O(t) drawn from (2) to\nthe ground-truth O(t) from the original file.\nAccuracy(t) = 100 .\nTP(t)\nTP(t) + FP(t) + FN(t)\n(3)\nwhere TP(t) (true positives) is the number of notes correctly predicted (note played in both \u02c6O(t) and O(t)).\nFP(t) (false positive) is the number of notes predicted that\nare not in the original sequence (note played in \u02c6O(t) but\nnot in O(t)). FN(t) (false negative) is the number of unreported notes (note absent in \u02c6O(t), but played in O(t)).\nWhen the quantization gets finer, we observed that a\nmodel which simply repeats the previous frame gradually obtains the best accuracy as displayed in Table ??.\nTo correct this bias, we recommend using an event-level\nevaluation framework where the comparisons between the\nground truth and the model\u2019s output is only performed for\ntime indices in Te defined as the set of indexes te such that\nO(te) \u0338= O(te \u2212 1)\nThe definition of event-level indices can be observed in\nFigure 4.\nIn the context of learning algorithms, splitting the\ndatabase between disjoint train and test subsets is highly\nrecommended [3, pg.32-33], and the performance of a\ngiven model is only assessed on the test subset. Finally,\nthe mean accuracy measure over the dataset is given by\n1\nK\n\ufffd\ns\u2208Dtest\n\ufffd\nte\u2208Te(s)\nAccuracy(te)\n(4)\nwhere Dtest defines the test subset, Te(s) the set of\nevent-time indexes for a given score s, and K\n=\n\ufffd\ns\u2208Dtest |Te(s)|.\n4.2 Proposed Model\nIn this section, we propose a learning-based approach to\ntackle the automatic orchestral inference task.\n4.2.1 Models\nWe present the results for two models called conditional Restricted Boltzmann Machine (cRBM) and Factored Gated cRBM (FGcRBM). The models we explored\nare defined in a probabilistic framework, where the vectors O(t) and P(t) are represented as binary random variables. The orchestral inference function is a neural network that expresses the conditional dependencies between\nthe different variables: the present orchestral frame O(t),\nthe present piano frame P(t) and the past orchestral frames\nO(t \u2212 1, ..., t \u2212 N). Hidden units are introduced to model\nthe co-activation of these variables.\nTheir number is a\nhyper-parameter with an order of magnitude of 1000. A\ntheoretical introduction to these models can be found in\n[26], whereas their application to projective orchestration\nis detailed in [7].\n4.2.2 Data Representation\nIn order to process the scores, we import them as pianoroll matrices (see Figure 3). Their extension to orchestral\nscores is obtained by concatenating the piano-rolls of each\ninstrument along the pitch dimension.\nThen, new events te \u2208 Te are extracted from both\npiano-rolls as described in Section 4.1. A consequence is\nthat the trained model apprehends the scores as a succession of events with no rhythmic structure. This is a simplification that considers the rhythmic structure of the projected orchestral score to be exactly the same as the one of\nthe original piano score. This is false in the general case,\nsince a composer can decide to add nonexistent events in\nan orchestration. However, this provides a reasonable approximation that is verified in a vast majority of cases.\nDuring the generation of an orchestral score given a piano\nscore, the next orchestral frame is predicted in the eventlevel framework, but inserted at the temporal location of\nthe corresponding piano frame as depicted in Figure 4.\nAutomatic alignment of the two piano-rolls is performed on the event-level representations, as described in\nSection 3.2.\nIn order to reduce the input dimensionality, we systematically remove any pitch which is never played in the\ntraining database for each instrument. With that simplification the dimension of the orchestral vector typically decreases from 3584 to 795 and the piano vector dimension\nfrom 128 to 89. Also, we follow the usual orchestral simplifications used when writing orchestral scores by grouping together all the instruments of a same section. For instance, the violin section, which might be composed by\nseveral instrumentalists, is written as a single part. Finally,\nthe velocity information is discarded, since we use binary\nunits that solely indicate if a note is on or off.\nEventually, we observed that an important proportion of\nthe frames are silences, which mathematically corresponds\nto a column vector filled with zeros in the piano-roll representation. A consequence of the over-representation of\nsilences is that a model trained on this database will lean\ntowards orchestrating with a silence any piano input, which\nis statistically the most relevant choice. Therefore, orches-\n\fFrame level\nEvent level\nPiano\nOrchestra\nPitch\nTime\nFigure 4. From a piano score, the generation of an orchestral score consists in extracting the event-level representation of the piano score, generating the sequence of\norchestral events, and then injecting them at the position\nof the event from the piano score. Note that the silence in\nthe fourth event of the piano score is not orchestrated by\nthe probabilistic model, but is automatically mapped to a\nsilence in the orchestral version.\ntration of silences in the piano score (P(t) = 0) are not\nused as training points. However, it is important to note\nthat they are not removed from the piano-rolls. Hence, silences could still appear in the past sequence of a training\npoint, since it is a valuable information regarding the structure of the piece. During generation time, the silences in\nthe piano score are automatically orchestrated with a silence in the orchestra score. Besides, silences are taken\ninto consideration when computing the accuracy.\n4.2.3 Results\nThe results of the cRBM and FGcRBM on the orchestral\ninference task are compared to two na\u00a8\u0131ve models. The first\nmodel is a random generation of the orchestral frames obtained by sampling a Bernoulli distribution of parameter\n0.5. The second model predicts an orchestral frame at time\nt by simply repeating the frame at time t \u2212 1. The results\nare summed up in Table ??.\n4.3 Discussion\nAs expected, the random model obtains very poor results.\nThe repeat model outperform all three other models, surprisingly even in the event-level framework. Indeed, we\nobserved that repeated notes still occur frequently in the\nevent-level framework. For instance, if between two successive events only one note out of five is modified, the\naccuracy of the repeat model on this frame will be equal to\n66%.\nIf the FGcRBM model outperforms the cRBM model\nin the frame-level framework, the cRBM is slightly better\nthan the FGcRBM model in the event-level framework.\nGenerations from both models can be listened to on the\ncompanion website 3 . Even though some fragments are\ncoherent regarding the piano score and the recent past orchestration, the results are mostly unsatisfying. Indeed, we\nobserved that the models learn an extremely high probability for every note to be off. Using regularization methods\nsuch as weight decay has not proven efficient. We believe\nthat this is due to the sparsity of the vectors O(t) we try to\ngenerate, and finding a more adapted data representation\nof the input will be a crucial step.\n5. CONCLUSION AND FUTURE WORK\nWe introduced the Projective Orchestral Database (POD),\na collection of MIDI files dedicated to the study of the relations between piano scores and corresponding orchestrations. We believe that the recent advent in machine learning and data mining has provided the proper tools to take\nadvantage of this important mass of information and investigate the correlations between a piano score and its orchestrations. We provide all MIDI files freely, along with\naligned and non-aligned pre-processed piano-roll representations on the website https://qsdfo.github.\nio/LOP/index.html.\nWe proposed a task called automatic orchestral inference. Given a piano score and a corresponding orchestration, it consists in trying to predict orchestral time frames,\nknowing the corresponding piano frame and the recent past\nof the orchestra. Then, we introduced an evaluation framework for this task based on a train and test split of the\ndatabase, and the definition of an accuracy measure. We\nfinally present the results of two models (the cRBM and\nFGcRBM) in this framework.\nWe hope that the POD will be useful for many researchers. Besides the projective orchestration task we defined in this article, the database can be used in several\nother applications, such as generating data for a sourceseparation model [17]. Even if small errors still persist, we\nthoroughly checked manually the database and guarantee\nits good quality. However, the number of files collected\nis still small with the aim of leading statistical investigations. Hence, we also hope that people will contribute to\nenlarge this database by sharing files and helping us gather\nthe missing information.\n6. REFERENCES\n[1] Imslp. http://imslp.org/wiki/Main_Page.\nAccessed : 2017-01-23.\n[2] Mert Bay, Andreas F Ehmann, and J Stephen Downie.\nEvaluation of multiple-f0 estimation and tracking systems. In ISMIR, pages 315\u2013320, 2009.\n[3] Christopher M Bishop. Pattern recognition and machine learning. springer, 2006.\n[4] Nicolas Boulanger-Lewandowski, Yoshua Bengio, and\nPascal Vincent. Modeling temporal dependencies in\n3 https://qsdfo.github.io/LOP/results\n\fhigh-dimensional sequences:\nApplication to polyphonic music generation and transcription. arXiv\npreprint arXiv:1206.6392, 2012.\n[5] Darrell Conklin and Ian H Witten. Multiple viewpoint\nsystems for music prediction. Journal of New Music\nResearch, 24(1):51\u201373, 1995.\n[6] J. Cookerly. Complete orchestration system, May 18\n2010. US Patent 7,718,883.\n[7] Leopold Crestel and Philippe Esling. Live orchestral\npiano, a system for real-time orchestral music generation. In Proceedings of the 14th Sound and Music Computing Conference, Aalto, Finland, July 2017.\n[8] Philippe Esling, Gr\u00b4egoire Carpentier, and Carlos Agon.\nDynamic musical orchestration using genetic algorithms and a spectro-temporal description of musical\ninstruments. Applications of Evolutionary Computation, pages 371\u2013380, 2010.\n[9] Maarten Grachten, Martin Gasser, Andreas Arzt, and\nGerhard Widmer. Automatic alignment of music performances with structural differences. In In Proceedings of 14th International Society for Music Information Retrieval Conference (ISMIR. Citeseer, 2013.\n[10] Jiun-Long Huang, Shih-Chuan Chiu, and Man-Kwan\nShan. Towards an automatic music arrangement framework using score reduction. ACM Transactions on\nMultimedia Computing, Communications, and Applications (TOMM), 8(1):8, 2012.\n[11] Charles Koechlin. Trait\u00b4e de l\u2019orchestration. \u00b4Editions\nMax Eschig, 1941.\n[12] Victor Lavrenko and Jeremy Pickens. Polyphonic music modeling with random fields. In Proceedings of the\neleventh ACM international conference on Multimedia,\npages 120\u2013129. ACM, 2003.\n[13] Yann LeCun, Yoshua Bengio, and Geoffrey Hinton.\nDeep learning. Nature, 521(7553):436\u2013444, 05 2015.\n[14] Sven-Amin Lembke and Stephen McAdams. Timbre\nblending of wind instruments: acoustics and perception. 2012.\n[15] Stephen McAdams. Timbre as a structuring force in\nmusic. In Proceedings of Meetings on Acoustics, volume 19, page 035050. Acoustical Society of America,\n2013.\n[16] Stephen McAdams and Bruno L Giordano. The perception of musical timbre. The Oxford handbook of\nmusic psychology, pages 72\u201380, 2009.\n[17] M. Miron, J. Janer, and E. G\u00b4omez. Generating data to\ntrain convolutional neural networks for classical music\nsource separation. In Proceedings of the 14th Sound\nand Music Computing Conference, pages 227\u2013233,\nAalto, Finland, 2017 2017.\n[18] Saul B. Needleman and Christian D. Wunsch. A general method applicable to the search for similarities in\nthe amino acid sequence of two proteins. Journal of\nMolecular Biology, 48(3):443 \u2013 453, 1970.\n[19] Franc\u00b8ois Pachet. A joyful ode to automatic orchestration. ACM Trans. Intell. Syst. Technol., 8(2):18:1\u2013\n18:13, October 2016.\n[20] Geoffroy Peeters, Bruno L Giordano, Patrick Susini,\nNicolas Misdariis, and Stephen McAdams. The timbre toolbox: Extracting audio descriptors from musical\nsignals. The Journal of the Acoustical Society of America, 130(5):2902\u20132916, 2011.\n[21] Walter Piston. Orchestration. New York:\nNorton,\n1955.\n[22] Daniel Pressnitzer, Stephen McAdams, Suzanne Winsberg, and Joshua Fineberg. Perception of musical\ntension for nontonal orchestral timbres and its relation to psychoacoustic roughness. Perception & psychophysics, 62(1):66\u201380, 2000.\n[23] Nikolay Rimsky-Korsakov. Principles of Orchestration. Russischer Musikverlag, 1873.\n[24] Hirofumi Takamori, Haruki Sato, Takayuki Nakatsuka,\nand Shigeo Morishima. Automatic arranging musical\nscore for piano using important musical elements. In\nProceedings of the 14th Sound and Music Computing\nConference, Aalto, Finland, July 2017.\n[25] Damien Tardieu and Stephen McAdams. Perception of\ndyads of impulsive and sustained instrument sounds.\nMusic Perception, 30(2):117\u2013128, 2012.\n[26] Graham W Taylor and Geoffrey E Hinton. Factored\nconditional restricted boltzmann machines for modeling motion style. In Proceedings of the 26th annual\ninternational conference on machine learning, pages\n1025\u20131032. ACM, 2009.\n\f", "text_mmd": null}, "BIBREF358": {"title": "Giantmidi-piano: A large-scale midi dataset for classical piano music", "authors": [{"first": "Qiuqiang", "middle": [], "last": "Kong", "suffix": ""}, {"first": "Bochen", "middle": [], "last": "Li", "suffix": ""}, {"first": "Jitong", "middle": [], "last": "Chen", "suffix": ""}, {"first": "Yuxuan", "middle": [], "last": "Wang", "suffix": ""}], "venue": "arXiv preprint", "volume": "", "issue": "", "pages": "", "text_pymu": "Anonymous (2022).\nGiantMIDI-Piano: A large-scale MIDI Dataset\nfor Classical Piano Music, Transactions of the International Society for Music Information Retrieval,\nV(N), pp. xx\u2013xx,\nDOI:\nhttps://doi.org/xx.xxxx/xxxx.xx\nARTICLE TYPE\nGiantMIDI-Piano: A large-scale MIDI Dataset for\nClassical Piano Music\nQiuqiang Kong*, Bochen Li*, Jitong Chen*, Yuxuan Wang*\nAbstract\nSymbolic music datasets are important for music information retrieval and musical analysis.\nHowever, there is a lack of large-scale symbolic datasets for classical piano music. In this article, we create a GiantMIDI-Piano (GP) dataset containing 38,700,838 transcribed notes and\n10,855 unique solo piano works composed by 2,786 composers. We extract the names of music\nworks and the names of composers from the International Music Score Library Project (IMSLP).\nWe search and download their corresponding audio recordings from the internet. We further\ncreate a curated subset containing 7,236 works composed by 1,787 composers by constraining the titles of downloaded audio recordings containing the surnames of composers. We apply a convolutional neural network to detect solo piano works. Then, we transcribe those solo\npiano recordings into Musical Instrument Digital Interface (MIDI) files using a high-resolution\npiano transcription system. Each transcribed MIDI file contains the onset, offset, pitch, and velocity attributes of piano notes and pedals. GiantMIDI-Piano includes 90% live performance\nMIDI files and 10% sequence input MIDI files. We analyse the statistics of GiantMIDI-Piano and\nshow pitch class, interval, trichord, and tetrachord frequencies of six composers from different\neras to show that GiantMIDI-Piano can be used for musical analysis. We evaluate the quality\nof GiantMIDI-Piano in terms of solo piano detection F1 scores, metadata accuracy, and transcription error rates. We release the source code for acquiring the GiantMIDI-Piano dataset at\nhttps://github.com/bytedance/GiantMIDI-Piano\nKeywords: GiantMIDI-Piano, dataset, piano transcription\n1. Introduction\nSymbolic music datasets are important for music information retrieval (MIR) and musical analysis.\nIn the\nWestern music tradition, musicians use musical notation to write music.\nThis notation includes pitches,\nrhythms, and chords of music. Musicologists used to\nanalyse music works by reading music notation. Recently, computers have been used to process and analyse large-scale data and have been widely used in MIR.\nHowever, there is a lack of large-scale symbolic music\ndatasets covering a wide range of solo piano works.\nOne difficulty of computer-based MIR is that musical notation such as staffs is not directly readable by\na computer. Therefore, converting music notation into\ncomputer-readable formats is important. Early works\nof converting music into symbolic representations can\nbe traced back to the 1900s, when piano rolls (Bryner,\n2002; Shi et al., 2019) were developed to record music that could be played on a musical instrument. Pi-\n*ByteDance\nano rolls are continuous rolls of paper with perforations punched into them. In 1981, Musical Instrument\nDigital Interface (MIDI) (Smith and Wood, 1981) was\nproposed as a technical standard to represent music\nand can be read by a computer. MIDI files use event\nmessages to specify the instructions of music, including pitch, onset, offset, and velocity of notes.\nMIDI\nfiles also carry rich information of music events such\nas sustain pedals. The MIDI format has been popular\nfor music production in recent years.\nIn this work, we focus on building a large-scale\nMIDI dataset for classical solo piano music.\nThere\nare several previous piano MIDI datasets including\nthe piano-midi.de (Krueger, 1996) dataset, the MAESTRO dataset (Hawthorne et al., 2019), the classical\narchives (Classical Archives, 2000) dataset, and the\nKunstderfuge dataset (Kunstderfuge, 2002). However,\nthose datasets are limited to hundreds of composers\nand hundreds of hours of unique works (Kunstderfuge,\n2002). MusicXML (Good et al., 2001) is another sym-\narXiv:2010.07061v3  [cs.IR]  21 Apr 2022\n\f2\nAnonymous: GiantMIDI-Piano: A large-scale MIDI Dataset for Classical Piano Music\nbolic format of music, while there are fewer MusicXML\ndatasets than MIDI datasets. Other machine-readable\nformats include the music encoding initiative (MEI)\n(Roland, 2002), Humdrum Sapp (2005), and LilyPond\n(Nienhuys and Nieuwenhuizen (2003)). Optical music recognition (OMR) (Rebelo et al., 2012; Bainbridge\nand Bell, 2001) is a technique to transcribe image\nscores into symbolic formats.\nHowever, the performance of OMR systems is limited to score qualities.\nIn this article, we collect and transcribe a largescale classical piano MIDI dataset called GiantMIDIPiano.\nTo our knowledge, GiantMIDI-Piano is the\nlargest piano MIDI dataset so far. GiantMIDI-Piano is\ncollected as follows: 1) We parse the names of composers and the names of music works from the International Music Score Library Project (IMSLP)1; 2) We\nsearch and download audio recordings of all matching\nmusic works from YouTube; 3) We build a solo piano\ndetection system to detect solo piano recordings; 4)\nWe transcribe solo piano recordings into MIDI files using a high-resolution piano transcription system (Kong\net al., 2021). In this article, we analyse the statistics\nof GiantMIDI-Piano, including the number of works,\ndurations of works, and nationalities of composers. In\naddition, we analyse the statistics of note, interval, and\nchord distribution of six composers from different eras\nto show that GiantMIDI-Piano can be used for musical\nanalysis.\n1.1\nApplications\nThe GiantMIDI-Piano dataset can be used in many\nresearch areas, including 1) Computer-based musical analysis (Volk et al., 2011; Meredith, 2016) such\nas using computers to analyse the structure, chords,\nand melody of music works. 2) Symbolic music generation (Yang et al., 2017; Hawthorne et al., 2019)\nsuch as generating symbolic music in symbolic format. 3) Computer-based music information retrieval\n(Casey et al., 2008; Choi et al., 2017) such as music\ntranscription and music tagging. 4) Expressive performance analysis (Cancino-Chac\u00f3n et al., 2018) such as\nanalysing the performance of different pianists.\nThis paper is organised as follows: Section 2 surveys piano MIDI datasets; Section 3 introduces the collection of the GiantMIDI-Piano dataset; Section 4 investigates the statistics of the GiantMIDI-Piano dataset;\nSection 5 evaluates the quality of the GiantMIDI-Piano\ndataset.\n2. Dataset Survey\nWe introduce several piano MIDI datasets as follows.\nThe Piano-midi.de dataset (Krueger, 1996) contains\nclassical solo piano works entered by a MIDI sequencer.\nPiano-midi.de contains 571 works composed by 26\ncomposers with a total duration of 36.7 hours till\nFeb. 2020. The classical archives collection (Classi-\n1https://imslp.org\nTable 1: Piano MIDI datasets. GP is the abbreviation\nfor GiantMIDI-Piano.\nDataset\nComposers\nWorks\nHours\nType\npiano-midi.de\n26\n571\n37\nSeq.\nClassical archives\n133\n856\n46\nSeq.\nKunstderfuge\n598\n-Seq.\nKerbScores\n-Seq.\nSUPRA\n111\n410\n-Perf.\nASAP\n16\n222\n-Perf.\nMAESTRO\n62\n529\n84\nPerf.\nMAPS\n-270\n19\nPerf.\nGiantMIDI-Piano\n2,786\n10,855\n1,237\n90% Perf.\nCurated GP\n1,787\n7,236\n875\n89% Perf.\ncal Archives, 2000) contains a large number of MIDI\nfiles of classical music, including both piano and nonpiano works.\nThere are 133 composers with a total\nduration of 46.3 hours of MIDI files in this dataset.\nThe KernScores dataset (Sapp, 2005) contains classical music with a Humdrum format and is obtained\nby an optical music recognition system.\nThe Kunstderfuge dataset (Kunstderfuge, 2002) contains solo piano and non-solo piano works of 598 composers. All of\nthe piano-midi.de, classical archives, and Kunstderfuge\ndatasets are entered using a MIDI sequencer and are\nnot played by pianists.\nThe MAPS dataset (Emiya et al., 2010) used MIDI\nfiles from Piano-midi.de to render real recordings by\nplaying back the MIDI files on a Yamaha Disklavier. The\nMAESTRO dataset (Hawthorne et al., 2019) contains\nover 200 hours of fine alignment MIDI files and audio\nrecordings. In MAESTRO, virtuoso pianists performed\non Yamaha Disklaviers with an integrated MIDI capture\nsystem. MAESTRO contains music works from 62 composers. There are several duplicated works in MAESTRO. For example, there are 11 versions of Scherzo\nNo. 2 in B-flat Minor, Op. 31 composed by Chopin.\nAll duplicated works are removed when calculating the\nnumber and duration of works.\nTable 1 shows the number of composers, the number of unique works, total durations, and data types of\ndifferent MIDI datasets. Data types include sequenced\n(Seq.) MIDI files input by MIDI sequencers and performed (Perf.) MIDI files played by pianists. There are\nother MIDI datasets including the Lakh dataset (Raffel, 2016), the Bach Doodle dataset (Huang et al.,\n2019), the Bach Chorales dataset (Conklin and Witten, 1995), the URMP dataset (Li et al., 2018),\nthe Bach10 dataset (Duan et al., 2010), the CrestMusePEDB dataset (Hashida et al., 2008), the SUPRA\ndataset (Shi et al., 2019), and the ASAP dataset (Foscarin et al., 2020).\n(Huang et al., 2018) collected\n10,000 hours of piano recordings for music generation,\nbut the dataset is not publicly available.\n\f3\nAnonymous: GiantMIDI-Piano: A large-scale MIDI Dataset for Classical Piano Music\n3. GiantMIDI-Piano Dataset\n3.1 Metadata from IMSLP\nTo begin with, we acquire the names of composers and\nthe names of music works by parsing the webpages of\nthe International Music Score Library Project (IMSLP,\n2006), the largest publicly available music library in\nthe world. In IMSLP, each composer has a webpage\ncontaining the list of their work names. We acquire\n143,701 music works composed by 18,067 composers\nby parsing those web pages.\nFor each composer, if\nthere exists a biography link on the composer page, we\naccess that biography link to search for their birth year,\ndeath year, and nationality. We set the birth year, death\nyear, and nationality to \u201cunknown\u201d if a composer does\nnot have such a biography link. We obtain the nationalities of 4,274 composers and births of 5,981 composers\nout of 18,067 composers by automatically parsing the\nbiography links.\nAs the automatically parsed meta information of\ncomposers from the internet is incomplete, we manually check the nationalities, births, and deaths for\n2,786 composers. We label 2,291 birth years, 2,254\ndeath years, and 2,115 nationalities by searching the\ninformation of composers on the internet. We label not\nfound birth years, death years, and nationalities as \u201cunknown\u201d. We create metadata files containing the information of composers and music works, respectively.\n3.2 Search Audio\nWe search audio recordings on YouTube by using a keyword of first name, surname, music work name from\nthe metadata. For each keyword, we select the first\nreturned result on YouTube.\nHowever, there can be\ncases where the returned YouTube title may not exactly match the keyword.\nFor example, for a keyword Fr\u00e9d\u00e9ric Chopin, Scherzo No.2 Op.31, the top returned result can be Chopin - Scherzo No. 2, Op. 31\n(Rubinstein). Although the keyword and the returned\nYouTube title are different, they indicate the same music work.\nWe denote the set of words in a searching keyword as X and the set of words in a returned\nYouTube title as Y .\nWe propose a modified Jaccard\nsimilarity (Niwattanakul et al., 2013) to evaluate how\nmuch a keyword and a returned result are matched.\nThe original Jaccard similarity is defined as J =\n|X \u2229Y |/(|X |\u222a|Y |). The drawback of this original Jaccard\nsimilarity is that the length of the searched YouTube title |Y | can be long, so that J will be small. This is often\nthe case because searched YouTube titles usually contain extra words such as the names of performers and\nthe dates of performances. Our aim is to define a metric where the denominator only depends on the searching keyword |X | and is independent of the length of the\nsearched YouTube title |Y |. We propose a modified Jaccard similarity (Niwattanakul et al., 2013) between X\nand Y as:\nJ = |X \u2229Y |/|X |.\n(1)\nHigher J indicates that X and Y have larger similarity,\nand lower J indicates that X and Y have less similarity.\nWe empirically set a similarity threshold to 0.6 to balance the precision and recall of searched results. If J\nis strictly larger than this threshold, then we say X are\nY are matched, and vice versa. In total, we retrieve\nand download 60,724 audio recordings out of 143,701\nmusic works.\n3.3\nSolo Piano Detection\nWe detect solo piano works from IMSLP to build the\nGiantMIDI-Piano dataset. Filtering music works with\nkeywords containing \u201cpiano\u201d may lead to incorrect results. For example, a \u201cPiano Concerto\u201d is an ensemble\nof piano and orchestra which is not solo piano. On the\nother hand, the keyword Chopin, Fr\u00e9d\u00e9ric, Nocturnes,\nOp.62 does not contain the word \u201cpiano\u201d, but it is indeed a solo piano. To address this problem, we train an\naudio-based solo piano detection system using a convolutional neural network (CNN) (Kong et al., 2020).\nThe piano detection system takes 1-second segments\nas input and extracts log mel spectrograms as input to\nthe CNN.\nThe CNN consists of four convolutional layers. Each\nconvolutional layer consists of a linear convolutional\noperation with a kernel size of 3 \u00d7 3, a batch normalization (Ioffe and Szegedy, 2015), and a ReLU nonlinearity (Glorot et al., 2011). The output of the CNN\npredicts the solo piano probability of a segment. Binary cross-entropy is used as a loss function to train\nthe CNN. We collect solo piano recordings as positive\nsamples and collect music and other sounds as negative\nsamples. In addition, the mixtures of piano and other\nsounds are also used as negative samples. In inference,\nwe average the predictions of all 1-second segments of\na recording to calculate its solo piano probability. We\nregard an audio recording as solo piano if the probability is strictly larger than 0.5 and vice versa. In total,\nwe obtain 10,855 solo pianos composed by 2,786 composers out of 60,724 downloaded audio recordings.\nThese 10,855 audio files are transcribed into MIDI files\nwhich constitute the full GiantMIDI-Piano dataset.\n3.4\nConstrain Composer Surnames\nAmong the detected 10,855 solo piano works, there\nare several music works composed by not well-known\ncomposers but are attached to famous composers. For\nexample, there are 273 searched music works assigned\nto Chopin, but only 102 of them are actually composed by Chopin, while other music works are composed by other composers. To alleviate this problem,\nwe create a curated subset by constraining the titles of\ndownloaded audio recordings containing the surnames\nof composers. After this constraint, we obtain a curated GiantMIDI-Piano dataset containing 7,236 music\nworks composed by 1,787 composers.\n\f4\nAnonymous: GiantMIDI-Piano: A large-scale MIDI Dataset for Classical Piano Music\nLiszt, Franz\nScarlatti, Domenico\nBach, Johann Sebastian\nSchubert, Franz\nChopin, Fr\u00e9d\u00e9ric\nCarbajo, V\u00edctor\nBeethoven, Ludwig van\nMozart, Wolfgang Amadeu\nSimpson, Daniel L\u00e9o\nScriabin, Aleksandr\nCzerny, Carl\nHandel, George Frideric\nRebikov, Vladimir\nHaydn, Joseph\nSatie, Erik\nChaminade, C\u00e9cile\nAlkan, Charles-Valentin\nLack, Th\u00e9odore\nTurina, Joaqu\u00edn\nRaff, Joachim\nZhang, Shuwen\nHummel, Johann Nepomuk\nHeller, Stephen\nTinel, Jef\nMedtner, Nikolay\nSchumann, Robert\nMoszkowski, Moritz\nJohnson, Charles Leslie\nScharwenka, Xaver\nJoplin, Scott\nTeilman, Christian\nMeyer-Helmund, Erik\nFaur\u00e9, Gabriel\nBalakirev, Mily\nGottschalk, Louis Morea\nGodard, Benjamin\nRavina, Jean Henri\nDebussy, Claude\nTchaikovsky, Pyotr\nProkofiev, Sergey\nPoulenc, Francis\nMendelssohn, Felix\nGrieg, Edvard\nWachs, Paul\nVilla-Lobos, Heitor\nRzewski, Frederic\nNazareth, Ernesto\nBrahms, Johannes\nRachmaninoff, Sergei\nHitz, Franz\nBusoni, Ferruccio\nVictoria, Tom\u00e1s Luis de\nScott, James\nScott, Cyril\nLange, Gustav\nGurlitt, Cornelius\nStanchinsky, Aleksey\nSch\u00fctt, Eduard\nKrzy anowski, Ignacy\nGr\u00fcnfeld, Alfred\nGodowsky, Leopold\nFerrari, Carlotta\nOrnstein, Leo\nLyapunov, Sergey\nHarrington, Jeffrey Mic\nAgnew, Roy\nGranados, Enrique\nDi Gesu, Massimo\nClementi, Muzio\nWieniawski, J\u00f3zef\nWeber, Carl Maria von\nRavel, Maurice\nMyaskovsky, Nikolay\nMourey, Colette\nMerino Mart\u00ednez, Aitor\nMarmontel, Antoine Fran\nLyadov, Anatoly\nHiller, Ferdinand\nGlinka, Mikhail\nGlazunov, Aleksandr\nCasella, Alfredo\nBlumenfeld, Felix\nBertini, Henri\nViolette, Andrew\nSt. Clair, Richard\nShirley, Nathan\nSchumann, Clara\nRowley, Alec\nNichifor, Serban\nMacchi, Claudio\nKuhlau, Friedrich\nHenselt, Adolf von\nHahn, Reynaldo\nCui, C\u00e9sar\nBortkiewicz, Sergei\nBendel, Franz\nBeach, Amy Marcy\nBart\u00f3k, B\u00e9la\nArensky, Anton\nAlb\u00e9niz, Isaac\n0\n25\n50\n75\n100\n125\n150\n175\n200\nNumber of works\n141\n140\n129\n96\n96\n77\n76\n72\n69\n67\n58\n57\n54\n54\n52\n45\n39\n38\n37\n37\n36\n36\n35\n34\n34\n33\n32\n32\n31\n31\n30\n30\n30\n30\n29\n28\n27\n27\n26\n26\n26\n24\n24\n23\n22\n22\n22\n22\n21\n21\n21\n20\n20\n20\n20\n20\n19\n19\n19\n19\n19\n19\n18\n18\n18\n18\n17\n17\n17\n16\n16\n16\n16\n16\n16\n16\n16\n16\n16\n16\n16\n16\n16\n15\n15\n15\n15\n15\n15\n15\n15\n15\n15\n15\n15\n15\n15\n15\n15\n15\n242\n228\n793\n703\n109\n81\n286\n613\n198\n83\n83\n224\n57\n557\n76\n115\n61\n45\n61\n73\n39\n86\n106\n73\n60\n116\n48\n39\n48\n35\n30\n31\n87\n46\n72\n51\n34\n87\n123\n72\n77\n119\n62\n27\n75\n48\n27\n104\n44\n21\n36\n129\n21\n33\n24\n23\n21\n20\n19\n32\n26\n389\n29\n29\n89\n18\n21\n26\n25\n21\n48\n51\n48\n43\n35\n16\n27\n40\n34\n81\n32\n19\n16\n58\n51\n26\n26\n37\n155\n57\n38\n20\n63\n33\n22\n17\n29\n47\n33\n23\nComplete works\nSolo piano works\nFigure 1: Number of solo piano works of the curated GP dataset. Top 100 are shown.\nLiszt, Franz\nBeethoven, Ludwig van\nSchubert, Franz\nBach, Johann Sebastian\nChopin, Fr\u00e9d\u00e9ric\nCarbajo, V\u00edctor\nCzerny, Carl\nSchumann, Robert\nRebikov, Vladimir\nMozart, Wolfgang Amadeu\nHaydn, Joseph\nRachmaninoff, Sergei\nMedtner, Nikolay\nSimpson, Daniel L\u00e9o\nScarlatti, Domenico\nAlkan, Charles-Valentin\nBrahms, Johannes\nScriabin, Aleksandr\nTchaikovsky, Pyotr\nRzewski, Frederic\nScharwenka, Xaver\nTurina, Joaqu\u00edn\nHummel, Johann Nepomuk\nProkofiev, Sergey\nGrieg, Edvard\nViolette, Andrew\nGodowsky, Leopold\nDebussy, Claude\nHeller, Stephen\nZhang, Shuwen\nSzymanowski, Karol\nBusoni, Ferruccio\nSatie, Erik\nMendelssohn, Felix\nClementi, Muzio\nMoszkowski, Moritz\nAlb\u00e9niz, Isaac\nFaur\u00e9, Gabriel\nLyapunov, Sergey\nWeber, Carl Maria von\nVilla-Lobos, Heitor\nGr\u00fcnfeld, Alfred\nBalakirev, Mily\nHindemith, Paul\nArensky, Anton\nDvo \u00e1k, Anton\u00edn\nBart\u00f3k, B\u00e9la\nRaff, Joachim\nVo \u00ed ek, Jan V\u00e1clav\nLack, Th\u00e9odore\nGranados, Enrique\nChaminade, C\u00e9cile\nGurlitt, Cornelius\nSuk, Josef\nKoechlin, Charles\nReger, Max\nWieniawski, J\u00f3zef\nSchmitt, Florent\nBlumenfeld, Felix\nM\u00e9reaux, Jean-Am\u00e9d\u00e9e Le\nGlazunov, Aleksandr\nSt. Clair, Richard\nMyaskovsky, Nikolay\nDupont, Gabriel\nBortkiewicz, Sergei\nSchumann, Clara\nPoulenc, Francis\nBertini, Henri\nStanchinsky, Aleksey\nHandel, George Frideric\nHahn, Reynaldo\nBeach, Amy Marcy\nS\u00e9verac, D\u00e9odat de\nGottschalk, Louis Morea\nRubinstein, Anton\nRavel, Maurice\nMeyer-Helmund, Erik\nCasella, Alfredo\nOrnstein, Leo\nCervantes, Ignacio\nFerrari, Carlotta\nNov\u00e1k, V\u00edt zslav\nMacDowell, Edward\nCui, C\u00e9sar\nSgambati, Giovanni\nJoplin, Scott\nDussek, Jan Ladislav\nMartin , Bohuslav\nWagner, Richard\nRavina, Jean Henri\nScott, Cyril\nTeilman, Christian\nSch\u00fctt, Eduard\nKosenko, Viktor\nHarrington, Jeffrey Mic\nFranck, C\u00e9sar\nMarmontel, Antoine Fran\nGodard, Benjamin\nBendel, Franz\nMourey, Colette\n0\n5\n10\n15\n20\n25\n30\nDuration (h)\n25\n21\n20\n17\n16\n14\n13\n11\n11\n11\n10\n10\n10\n9\n9\n9\n9\n9\n8\n7\n7\n6\n6\n6\n6\n6\n5\n5\n5\n5\n5\n5\n4\n4\n4\n4\n4\n4\n4\n4\n4\n4\n4\n4\n4\n4\n4\n4\n3\n3\n3\n3\n3\n3\n3\n3\n3\n3\n3\n3\n3\n3\n3\n3\n3\n3\n3\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n2\n40\n78\n87\n158\n19\n15\n19\n39\n12\n140\n143\n19\n17\n25\n16\n12\n36\n13\n53\n14\n14\n12\n21\n27\n15\n28\n6\n19\n39\n5\n12\n9\n8\n40\n6\n10\n5\n13\n9\n12\n19\n5\n8\n39\n10\n35\n15\n21\n4\n4\n5\n8\n3\n8\n7\n23\n4\n17\n4\n4\n23\n12\n18\n6\n6\n5\n10\n2\n3\n108\n8\n5\n3\n13\n25\n12\n2\n8\n4\n2\n36\n7\n5\n7\n5\n4\n9\n10\n6\n2\n3\n2\n2\n3\n12\n16\n2\n8\n2\n6\nComplete works\nSolo piano works\nFigure 2: Duration of solo piano works of the curated GP dataset. Top 100 are shown.\nUnknown\nGerman\nFrench\nAmerican\nBritish\nItalian\nRussian\nAustrian\nPolish\nSpanish\nBelgian\nNorwegian\nCzech\nSwedish\nHungarian\nBrazilian\nDutch\nDanish\nAustralian\nUkrainian\nCanadian\nFinnish\nMexican\nArgentine\nSwiss\nBohemian\nIrish\nPortuguese\nJapanese\nArmenian\nRomanian\nChinese\nCuban\nCroatian\nChilean\nVenezuelan\nFilipino\nUruguayan\nColombian\nBelarusian\nBulgarian\nAzerbaijani\nIndian\nIranian\nIcelandic\nTurkish\nPeruvian\nLithuanian\nEgyptian\nParaguayan\nLatvian\nGreek\nEcuadorean\nNigerian\nNationalities\n0\n100\n200\n300\n400\n500\nNumber of composers\n671\n364\n322\n267\n179\n169\n135\n90\n74\n66\n47\n32\n29\n28\n25\n25\n23\n22\n21\n16\n16\n15\n14\n13\n13\n12\n10\n9\n9\n7\n7\n6\n6\n5\n5\n4\n3\n3\n3\n2\n2\n2\n2\n2\n2\n1\n1\n1\n1\n1\n1\n1\n1\n1\nUnknown\nEuropean\nNorth American\nSouth American\nAsian\nAfican\nFigure 3: Number of composers with different nationalities of the full GP dataset.\n3.5 Piano Transcription\nWe transcribe all 10,855 solo piano recordings into\nMIDI files using an open-sourced high-resolution piano\ntranscription system2 (Kong et al., 2021), an improvement over the onsets and frames piano transcription\nsystem (Hawthorne et al., 2018, 2019) and other systems (Kim and Bello, 2019; Kwon et al., 2020). The piano transcription system is trained on the training subset of the MAESTRO dataset version 2.0.0 (Hawthorne\net al., 2019). The training and testing subset contain\n161.3 and 20.5 hours of aligned piano recordings and\nMIDI files, respectively. The piano transcription system\npredicts all of the pitch, onset, offset, and velocity at-\n2https://github.com/bytedance/piano_transcription\ntributes of notes. The transcribed results also include\nsustain pedals. For piano note transcription, our system consists of a frame-wise classification, an onset regression, an offset regression, and a velocity regression\nsub-module. Each sub-module is modeled by a convolutional recurrent neural network (CRNN) with eight\nconvolutional layers and two bi-directional gated recurrent units (GRU) layers. The output of each module has a dimension of 88, equivalent to the number of\nnotes on a modern piano.\nThe pedal transcription system has the same architecture as the note transcription system, except that\nthere is only one output after the CRNN sub-module\nindicating the onset or offset probabilities of pedals.\nIn inference, all piano recordings are converted into\nmono with a sampling rate of 16 kHz. We use a shorttime Fourier transform (STFT) with a Hann window\nsize 2048 and a hop size 160 to extract spectrograms,\nso there are 100 frames in a second. Then, mel filter\nbanks with 229 bins are used to extract log mel spectrogram as input feature (Hawthorne et al., 2019). The\ntranscription system outputs the predicted probabilities of pitch, onset, offset, and velocity. Finally, those\noutputs are post-processed into MIDI events.\n4. Statistics\nWe analyse the statistics of GiantMIDI-piano, including\nthe number and duration of music works composed by\n\f5\nAnonymous: GiantMIDI-Piano: A large-scale MIDI Dataset for Classical Piano Music\nA0A 0B0 C1C 1D1D 1E1 F1 F 1G1G 1A1A 1B1 C2C 2D2D 2E2 F2 F 2G2G 2A2A 2B2 C3C 3D3D 3E3 F3 F 3G3G 3A3A 3B3 C4C 4D4D 4E4 F4 F 4G4G 4A4A 4B4 C5C 5D5D 5E5 F5 F 5G5G 5A5A 5B5 C6C 6D6D 6E6 F6 F 6G6G 6A6A 6B6 C7C 7D7D 7E7 F7 F 7G7G 7A7A 7B7 C8\n0\n200,000\n400,000\n600,000\n800,000\n1,000,000\n1,200,000\nNumber of notes\nFigure 4: Note histogram of the curated GP dataset.\nA0A 0B0 C1C 1D1D 1E1 F1 F 1 G1G 1A1A 1B1 C2C 2D2D 2E2 F2 F 2 G2G 2A2A 2B2 C3C 3D3D 3E3 F3 F 3 G3G 3A3A 3B3 C4C 4D4D 4E4 F4 F 4 G4G 4A4A 4B4 C5C 5D5D 5E5 F5 F 5 G5G 5A5A 5B5 C6C 6D6D 6E6 F6 F 6 G6G 6A6A 6B6 C7C 7D7D 7E7 F7 F 7 G7G 7A7A 7B7 C8\n0\n10,000\n20,000\n30,000\nNumber of notes\nBach, Johann Sebastian\nA0A 0B0 C1C 1D1D 1E1 F1 F 1 G1G 1A1A 1B1 C2C 2D2D 2E2 F2 F 2 G2G 2A2A 2B2 C3C 3D3D 3E3 F3 F 3 G3G 3A3A 3B3 C4C 4D4D 4E4 F4 F 4 G4G 4A4A 4B4 C5C 5D5D 5E5 F5 F 5 G5G 5A5A 5B5 C6C 6D6D 6E6 F6 F 6 G6G 6A6A 6B6 C7C 7D7D 7E7 F7 F 7 G7G 7A7A 7B7 C8\n0\n10,000\n20,000\n30,000\nNumber of notes\nBeethoven, Ludwig van\nA0A 0B0 C1C 1D1D 1E1 F1 F 1 G1G 1A1A 1B1 C2C 2D2D 2E2 F2 F 2 G2G 2A2A 2B2 C3C 3D3D 3E3 F3 F 3 G3G 3A3A 3B3 C4C 4D4D 4E4 F4 F 4 G4G 4A4A 4B4 C5C 5D5D 5E5 F5 F 5 G5G 5A5A 5B5 C6C 6D6D 6E6 F6 F 6 G6G 6A6A 6B6 C7C 7D7D 7E7 F7 F 7 G7G 7A7A 7B7 C8\n0\n10,000\n20,000\n30,000\nNumber of notes\nLiszt, Franz\nFigure 5: Notes histogram of J.S. Bach, Beethoven, and Liszt of the curated GP dataset.\ndifferent composers, the nationality of composers, and\nthe distribution of notes by composers. Then, we investigate the statistics of six composers from different\neras by calculating their pitch class, interval, trichord,\nand tetrachord distributions. All of Fig. 1 to Fig. 11 except Fig. 3 are plotted with the statistics of the curated\nGiantMIDI-Piano dataset. Fig. 3 shows the manuallychecked nationalities of 2,786 composers in the full\nGiantMIDI-Piano dataset.\n4.1 The Number of Solo Piano Works\nFig. 1 shows the numbers of piano works composed\nby different composers sorted in descending order of\nthe curated GiantMIDI-Piano dataset. Fig. 1 shows the\nstatistics of top 100 composers out of 2,786 composers.\nBlue bars show the number of solo piano works. Pink\nbars show the number of complete works, including\nboth solo piano and non-solo piano works.\nFig.\n1\nshows that there are 141 solo piano works composed\nby Liszt, followed by 140 and 129 solo piano works\ncomposed by Scarlatti and J. S. Bach. Some composers,\nsuch as Chopin composed more solo piano works than\nnon-solo piano works. For example, there are 96 solo\npiano works out of 109 complete works composed by\nChopin in the curated GiantMIDI-Piano dataset. Fig. 1\nshows that the number of solo piano works of different\ncomposers has a long tail distribution.\n4.2 The Duration of Solo Piano Works\nFig. 2 shows the duration of solo piano works composed by different composers sorted in descending order of the curated GiantMIDI-Piano dataset. The duration of works composed by Liszt is the longest at 25\nhours, followed by Beethoven at 21 hours and Schu-\nbert at 20 hours.\nSome composers composed more\nnon-piano works than solo piano works. For example,\nthere are 108 hours of complete works composed by\nHandel in the dataset, while only 2 hours of them are\nplayed on a modern piano. The rank of composers in\nFig. 2 is different from Fig. 1, indicating that the average duration of solo piano works composed by different composers are different.\n4.3\nNationalities of Composers\nFig.\n3 shows the number of composers with different nationalities sorted in descending order of the full\nGiantMIDI-Piano dataset.\nThe nationality of 2,786\ncomposers are initially obtained from Wikipedia and\nare later manually checked3.\nFig.\n3 shows that\nthere are 671 composers with unknown nationality.\nThere are 364 German composers, followed by 322\nFrench composers and 267 American composers. We\ncolor-code the continent of nationalities from \u201cUnknown\u201d, \u201cEuropean\u201d, \u201cNorth American\u201d, \u201cSouth American\u201d, \u201cAsian\u201d, to \u201cAfrican\u201d. In GiantMIDI-Piano, the\nnationalities of most composers are European.\nThe\nnumbers of composers with nationalities from South\nAmerican, Asian, and African are fewer.\n4.4\nNote Histogram\nFig.\n4 shows the note histogram of the curated\nGiantMIDI-Piano dataset. There are 24,253,495 transcribed notes. The horizontal axis shows the scientific\npitch notations, which covers 88 notes on a modern\npiano from A0 to C8. Middle C is denoted as C4. We\n3There are debates on the nationality of some composers. We extract the nationality of composers from Wikipedia and do not discuss\nregion debates in this work.\n\f6\nAnonymous: GiantMIDI-Piano: A large-scale MIDI Dataset for Classical Piano Music\nHarrington, Jeffrey Mic\nCasella, Alfredo\nMourey, Colette\nFranck, C\u00e9sar\nWagner, Richard\nGodard, Benjamin\nSatie, Erik\nMyaskovsky, Nikolay\nBusoni, Ferruccio\nProkofiev, Sergey\nSchumann, Robert\nRubinstein, Anton\nBrahms, Johannes\nMendelssohn, Felix\nGrieg, Edvard\nFerrari, Carlotta\nGurlitt, Cornelius\nBart\u00f3k, B\u00e9la\nSgambati, Giovanni\nRzewski, Frederic\nScriabin, Aleksandr\nBeethoven, Ludwigvan\nBortkiewicz, Sergei\nTchaikovsky, Pyotr\nMedtner, Nikolay\nStanchinsky, Aleksey\nTeilman, Christian\nGodowsky, Leopold\nSchumann, Clara\nMacDowell, Edward\nBach, JohannSebastian\nCui, C\u00e9sar\nAlkan, Charles-Valentin\nRachmaninoff, Sergei\nScott, Cyril\nBalakirev, Mily\nDupont, Gabriel\nVo \u00ed ek, Jan V\u00e1clav\nM\u00e9reaux, Jean-Am\u00e9d\u00e9e Le\nOrnstein, Leo\nKosenko, Viktor\nWeber, Carl Maria von\nSimpson, Daniel L\u00e9o\nChopin, Fr\u00e9d\u00e9ric\nDvo \u00e1k, Anton\u00edn\nLyapunov, Sergey\nHahn, Reynaldo\nSchubert, Franz\nHindemith, Paul\nHandel, George Frideric\nFaur\u00e9, Gabriel\nPoulenc, Francis\nJoplin, Scott\nDebussy, Claude\nScharwenka, Xaver\nMarmontel, Antoine Fran\nGranados, Enrique\nVilla-Lobos, Heitor\nRavina, Jean Henri\nLack, Th\u00e9odore\nWieniawski, J\u00f3zef\nMozart, WolfgangAmadeu\nSuk, Josef\nHummel, Johann Nepomuk\nMeyer-Helmund, Erik\nMoszkowski, Moritz\nMartin , Bohuslav\nCervantes, Ignacio\nTurina, Joaqu\u00edn\nCarbajo, V\u00edctor\nSch\u00fctt, Eduard\nS\u00e9verac, D\u00e9odat de\nSzymanowski, Karol\nChaminade, C\u00e9cile\nHeller, Stephen\nKoechlin, Charles\nReger, Max\nDussek, Jan Ladislav\nRebikov, Vladimir\nArensky, Anton\nLiszt, Franz\nClementi, Muzio\nHaydn, Joseph\nBlumenfeld, Felix\nSchmitt, Florent\nNov\u00e1k, V\u00edt zslav\nBendel, Franz\nRavel, Maurice\nScarlatti, Domenico\nBeach, Amy Marcy\nAlb\u00e9niz, Isaac\nBertini, Henri\nGlazunov, Aleksandr\nViolette, Andrew\nZhang, Shuwen\nRaff, Joachim\nSt. Clair, Richard\nGr\u00fcnfeld, Alfred\nGottschalk, Louis Morea\nCzerny, Carl\nC3\nC4\nC5\nNote names\n59.66\n60.39\n60.71\n61.26\n61.36\n61.38\n61.51\n61.76\n61.82\n61.90\n61.91\n62.08\n62.23\n62.32\n62.36\n62.39\n62.42\n62.55\n62.64\n62.73\n62.98\n62.99\n63.25\n63.32\n63.45\n63.51\n63.52\n63.59\n63.65\n63.66\n63.69\n63.69\n63.72\n63.75\n63.78\n63.81\n63.82\n63.84\n63.86\n63.94\n63.95\n63.95\n64.00\n64.01\n64.10\n64.11\n64.12\n64.12\n64.12\n64.12\n64.16\n64.32\n64.36\n64.38\n64.38\n64.42\n64.48\n64.50\n64.55\n64.59\n64.61\n64.81\n64.83\n64.89\n64.91\n64.93\n64.94\n64.95\n64.98\n65.08\n65.14\n65.15\n65.24\n65.24\n65.35\n65.38\n65.39\n65.48\n65.49\n65.51\n65.69\n65.85\n65.93\n65.96\n66.06\n66.12\n66.14\n66.32\n66.37\n66.63\n66.70\n66.74\n66.89\n67.28\n67.39\n67.91\n68.09\n68.17\n68.40\n68.69\nFigure 6: Pitch distribution of top 100 composers of the curated GP dataset.\nGr\u00fcnfeld, Alfred\nM\u00e9reaux, Jean-Am\u00e9d\u00e9e Le\nMarmontel, Antoine Fran\nScharwenka, Xaver\nKoechlin, Charles\nLack, Th\u00e9odore\nCervantes, Ignacio\nSatie, Erik\nRebikov, Vladimir\nHandel, George Frideric\nRzewski, Frederic\nFerrari, Carlotta\nFaur\u00e9, Gabriel\nDupont, Gabriel\nMacDowell, Edward\nGrieg, Edvard\nBach, JohannSebastian\nSuk, Josef\nGranados, Enrique\nSgambati, Giovanni\nTurina, Joaqu\u00edn\nFranck, C\u00e9sar\nMyaskovsky, Nikolay\nHaydn, Joseph\nGurlitt, Cornelius\nRubinstein, Anton\nCui, C\u00e9sar\nBart\u00f3k, B\u00e9la\nHahn, Reynaldo\nMeyer-Helmund, Erik\nDebussy, Claude\nS\u00e9verac, D\u00e9odat de\nScott, Cyril\nMourey, Colette\nStanchinsky, Aleksey\nSt. Clair, Richard\nCarbajo, V\u00edctor\nBendel, Franz\nViolette, Andrew\nSchmitt, Florent\nScriabin, Aleksandr\nOrnstein, Leo\nWagner, Richard\nBeach, Amy Marcy\nNov\u00e1k, V\u00edt zslav\nSimpson, Daniel L\u00e9o\nHindemith, Paul\nMartin , Bohuslav\nBalakirev, Mily\nMozart, WolfgangAmadeu\nBrahms, Johannes\nProkofiev, Sergey\nScarlatti, Domenico\nGodowsky, Leopold\nWieniawski, J\u00f3zef\nAlb\u00e9niz, Isaac\nBeethoven, Ludwigvan\nTchaikovsky, Pyotr\nSchumann, Clara\nReger, Max\nRavel, Maurice\nBusoni, Ferruccio\nBortkiewicz, Sergei\nHeller, Stephen\nSzymanowski, Karol\nHummel, Johann Nepomuk\nTeilman, Christian\nChopin, Fr\u00e9d\u00e9ric\nGodard, Benjamin\nSchumann, Robert\nSch\u00fctt, Eduard\nClementi, Muzio\nCasella, Alfredo\nPoulenc, Francis\nBlumenfeld, Felix\nDvo \u00e1k, Anton\u00edn\nArensky, Anton\nSchubert, Franz\nChaminade, C\u00e9cile\nMoszkowski, Moritz\nLyapunov, Sergey\nRavina, Jean Henri\nVilla-Lobos, Heitor\nKosenko, Viktor\nDussek, Jan Ladislav\nMendelssohn, Felix\nGlazunov, Aleksandr\nHarrington, Jeffrey Mic\nMedtner, Nikolay\nGottschalk, Louis Morea\nRachmaninoff, Sergei\nWeber, Carl Maria von\nVo \u00ed ek, Jan V\u00e1clav\nJoplin, Scott\nLiszt, Franz\nZhang, Shuwen\nBertini, Henri\nRaff, Joachim\nAlkan, Charles-Valentin\nCzerny, Carl\n0\n5\n10\n15\n20\nNumber of notes per second\n4.77\n4.85\n5.39\n5.51\n6.14\n6.20\n6.53\n6.70\n7.00\n7.08\n7.39\n7.53\n7.55\n7.59\n7.64\n7.78\n7.91\n7.92\n7.93\n7.96\n8.05\n8.06\n8.13\n8.26\n8.29\n8.32\n8.33\n8.34\n8.34\n8.50\n8.53\n8.58\n8.65\n8.66\n8.72\n8.77\n8.80\n8.88\n8.90\n8.92\n8.94\n8.99\n9.00\n9.02\n9.08\n9.11\n9.16\n9.17\n9.20\n9.22\n9.23\n9.26\n9.35\n9.50\n9.52\n9.53\n9.56\n9.62\n9.69\n9.70\n9.80\n9.84\n9.92\n9.96\n9.97\n9.97\n9.98\n9.99\n9.99\n10.03\n10.07\n10.09\n10.11\n10.14\n10.35\n10.60\n10.64\n10.72\n10.79\n10.86\n10.91\n10.94\n10.94\n10.98\n11.14\n11.25\n11.36\n11.50\n11.54\n11.63\n11.66\n11.81\n11.84\n11.92\n11.94\n12.13\n12.35\n12.50\n14.16\n14.74\nFigure 7: The number of notes per second of top 100 composers of the curated GP dataset.\ndo not distinguish enharmonic notes, for example, a\nnote C\u266f/D\u266d is simply denoted as C\u266f.\nThe white and\nblack bars correspond to the white and black keys on a\nmodern piano, respectively. Fig. 4 shows that the note\nhistogram has a normal distribution. The most played\nnote is G4. There are more notes close to G4 and less\nnotes far from G4. The most played notes are within\nthe octave between C4 and C5. White keys are being\nplayed more often than black keys.\nFig.\n5 visualizes the note histogram of three\ncomposers from different eras, including J. S. Bach,\nBeethoven, and Liszt. The note range of J. S. Bach is\nmostly between C2 and C6 covering four octaves, which\nis consistent with the note range of a conventional\nharpsichord or organ. The note range of Beethoven\nis mostly between F1 and C7 covering five and a half\noctaves. The note range of Liszt is the widest, covering\nthe whole range of a modern piano.\n4.5 Pitch Distribution of Top 100 Composers\nFig. 6 shows the pitch distribution sorted in ascending order over the top 100 composers in Fig. 2 of the\ncurated GiantMIDI-Piano dataset. The average pitches\nof most composers are between C4 and C5, where C4\ncorresponds to a MIDI pitch value 60. The shades indicate the one standard deviation area of pitch distributions. Jeffrey Michael Harrington has the lowest average pitch value of C4. Carl Czerny has the highest\naverage pitch value of A4.\n4.6\nThe Number of Notes Per Second Distribution of\nTop 100 Composers\nFig.\n7 shows the number of notes per second distribution sorted in ascending order over the top 100\ncomposers in Fig. 2 of the curated GiantMIDI-Piano\ndataset. The number of notes per second is calculated\nby dividing all works notes number by all works duration of a composer. The average numbers of notes per\nsecond of most composers are between 5 and 10. The\nshades indicate the one standard deviation area of the\nnumber of notes per second distribution. Alfred Gr\u00fcnfeld has the smallest number of notes per second with\na value of 4.18. Carl Czerny has the largest number of\nnotes per second with a value of 13.61.\n4.7\nPitch Class Distribution\nWe\ndenote\nthe\nset\nof\npitch\nnames\nas\n{C,C\u266f,D,D\u266f,E,F,F\u266f,G,G\u266f,A,A\u266f,B}.\nThe notes from C\nto B are denoted as 0 to 11 (Forte, 1973), respectively.\nWe calculate the statistics of six composers from\ndifferent eras including J. S. Bach, Mozart, Beethoven,\nChopin, Liszt, and Debussy. Fig. 8 shows that J. S.\nBach used D, E, G, and A most in his solo piano works.\nMozart used C, D, F, and G most in his solo piano\nworks and used more A\u266f/B\u266d than other composers.\nBeethoven used more C, D, and G than other notes.\n\f7\nAnonymous: GiantMIDI-Piano: A large-scale MIDI Dataset for Classical Piano Music\nC C D D E F F G G A A B\n0.00\n0.05\n0.10\n0.15\nFrequency\nBach, Johann Sebastian\nC C D D E F F G G A A B\n0.00\n0.05\n0.10\n0.15\nFrequency\nMozart, Wolfgang Amadeus\nC C D D E F F G G A A B\n0.00\n0.05\n0.10\n0.15\nFrequency\nBeethoven, Ludwig van\nC C D D E F F G G A A B\n0.00\n0.05\n0.10\n0.15\nFrequency\nChopin, Fr\u00e9d\u00e9ric\nC C D D E F F G G A A B\n0.00\n0.05\n0.10\n0.15\nFrequency\nLiszt, Franz\nC C D D E F F G G A A B\n0.00\n0.05\n0.10\n0.15\nFrequency\nDebussy, Claude\nFigure 8: Pitch class distribution of six composers of\nthe curated GP dataset.\n-11\n-10\n-9\n-8\n-7\n-6\n-5\n-4\n-3\n-2\n-1\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n0.00\n0.05\n0.10\n0.15\nFrequency\nBach, Johann Sebastian\n-11\n-10\n-9\n-8\n-7\n-6\n-5\n-4\n-3\n-2\n-1\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n0.00\n0.05\n0.10\n0.15\nMozart, Wolfgang Amadeus\n-11\n-10\n-9\n-8\n-7\n-6\n-5\n-4\n-3\n-2\n-1\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n0.00\n0.05\n0.10\n0.15\nBeethoven, Ludwig van\n-11\n-10\n-9\n-8\n-7\n-6\n-5\n-4\n-3\n-2\n-1\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n0.00\n0.05\n0.10\n0.15\nFrequency\nChopin, Fr\u00e9d\u00e9ric\n-11\n-10\n-9\n-8\n-7\n-6\n-5\n-4\n-3\n-2\n-1\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n0.00\n0.05\n0.10\n0.15\nLiszt, Franz\n-11\n-10\n-9\n-8\n-7\n-6\n-5\n-4\n-3\n-2\n-1\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n0.00\n0.05\n0.10\n0.15\nDebussy, Claude\nFigure 9: Interval distribution of six composers of the\ncurated GP dataset.\nChopin used D\u266f/E\u266d and G\u266f/A\u266d most in his solo piano\nworks. Liszt and Debussy used all twelve pitch classes\nmore uniformly in their solo piano works than other\ncomposers. Liszt used E most, and Debussy used C\u266f/D\u266d\nmost. As expected, most of Baroque and classical solo\npiano works were in keys close to C, whereas Romantic\nand later composers explored distant keys and tended\nto use all twelve pitch classes more uniformly.\n4.8 Interval Distribution\nAn interval is the pitch difference between two notes.\nIntervals can be either melodic intervals or harmonic\nintervals. A harmonic interval is the pitch difference of\ntwo notes being played at the same time. A melodic\ninterval is the pitch difference between two successive notes. We consider both harmonic intervals and\nmelodic intervals as intervals. We calculate the distribution of intervals of six composers. Notes are represented as a list of events in a MIDI format. We calculate\nan interval as:\n\u2206 = yn \u2212 yn\u22121,\n(2)\nwhere yn is the MIDI pitch of a note and n is the index\nof the note.\nWe calculate ordered intervals including both positive intervals and negative intervals. For example, the\ninterval \u2206 for an upward progress from C4 to D4 is 2,\nand the interval \u2206 for a downward progress from C4\nto A3 is \u22123. We only consider intervals between -11\nto 11 (included) and discard the intervals outside this\nregion. For example, the value 11 indicates a major\nseventh interval. Fig. 9 shows the interval distribution\nof six composers. All composers used major second and\nminor third most in their works. The interval distribution is not symmetric to the origin. For example, J. S.\nFigure 10: Trichord distribution of six composers of\nthe curated GP dataset. Rel. frequency is the abbreviation for relative frequency.\nFigure 11: Tetrachord distribution of six composers of\nthe curated GP dataset.\nBach and Mozart used more downward major second\nthan the upward major second. In the works of J. S.\nBach, the dip in the interval 0 indicates that repeated\nnotes are less commonly used than non-repeated notes.\nOther composers used more repeated notes than J. S.\nBach. Major seventh and tritone are least used by all\ncomposers. Some Romantic and later composers, including Chopin, Liszt, and Debussy used all intervals\nmore uniformly than J. S. Bach from Baroque era.\n4.9\nTrichord Distribution\nWe adopt the set musical theory (Forte, 1973) to analyse the chord distribution in GiantMIDI-Piano. A trichord is a set of any three pitch-classes (Forte, 1973).\nSince GiantMIDI-Piano is transcribed from real recordings, notes of a chord are usually not played simultaneously. We consider notes within a window of 50 ms\nas a chord. The windows are non-overlapped. Each\nnote only belongs to one chord. For a special case of\na set of onsets at 0, 25, 50, 75, and 100 ms, our system first searches chords in a window starting from 0\nms and returns {0, 25, 50}. Then, the system searches\nchords in a window starting from 75 ms and returns\n{75, 100}.\nWe discard the pitch sets with more or\nless than three notes within a 50 ms window to ensure\nchords are trichords. The sliding window for counting pitch sets will ensure that there are no overlapped\nwhen counting trichords. A major triad can be written as {0,4,7}, where the interval between 0 and 4 is a\nmajor third, and the interval between 4 and 7 is a minor third. We transpose all chords to chords with lower\nnotes C. For example, a chord {2,6,9} is transposed into\n\f8\nAnonymous: GiantMIDI-Piano: A large-scale MIDI Dataset for Classical Piano Music\n0.00\n0.10\n0.20\n0.30\n0.40\n0.50\n0.60\n0.70\n0.80\n0.90\nThresholds\n0.0\n0.2\n0.4\n0.6\n0.8\n1.0\nScores\nPrecision\nRecall\nF1\nFigure 12: Precision, recall, and F1 score of solo piano\ndetection.\n{0,4,7}. We merge chords with the same prime form.\nFig.\n10 shows the trichord distribution of six composers.\nAll composers used major triad {0,4,7} most\nfollowed by minor triad {0,3,7} in their works. Liszt\nused more augmented triad {0,4,8} than other composers. Debussy used more {0,2,5}, {0,2,4} than other\ncomposers which distinguished him from other composers. Fig. 10 shows that composers from different\neras have different preferences for using trichords.\n4.10 Tetrachord Distribution\nA tetrachord is a set of any four pitch-classes (Forte,\n1973). Similar to trichord, we consider notes within\na window of 50 ms as a chord. We discard the pitch\nsets with more or less than four notes within a 50 ms\nwindow to ensure chords are tetrachords.\nA dominant seventh chord can be denoted as {0,4,7,10}. Fig.\n11 shows the tetrachord distribution of six composers.\nSeventh chords such as {0,2,6,9} are transposed to root\nposition seventh chords {0,4,7,10}. Fig. 11 shows that\nBach, Beethoven and Mozart, and Chopin used dominant seventh {0,4,7,10} most. Liszt used diminished\nseventh {0,3,6,9} most and Debussy used minor seventh\n{0,3,7,10} most. J. S. Bach used less dominant seventh\ncompared to the other five composers. The tetrachord\ndistribution of Debussy is different from other composers. Fig. 11 shows that composers from different\neras have different preferences for using tetrachords.\n5. Evaluation of GiantMIDI-Piano\n5.1 Solo Piano Evaluation\nWe evaluate the solo piano detection system as follows.\nWe manually label 200 randomly selected music works\nfrom 60,724 downloaded audio recordings. We calculate the precision, recall, and F1 scores of the solo piano detection system with different thresholds ranging\nfrom 0.1 to 0.9 and show results in Fig. 12. Horizontal\nand vertical axes show different thresholds and scores,\nrespectively. Fig. 12 shows that higher thresholds lead\nto higher precision but lower recall.\nWhen we set\nthe threshold to 0.5, the solo piano detection system\nachieves a precision, recall, and F1 score of 89.66%,\nTable 2: Accuracy of retrieved music works of six composers.\nJ. S. Bach\nMozart\nBeethoven\nChopin\nLiszt\nDebussy\nCorrect\n147\n85\n82\n102\n197\n29\nIncorrect\n102\n35\n70\n171\n22\n9\nAccuracy\n59%\n71%\n54%\n37%\n90%\n76%\nTable 3: Accuracy of retrieved music works of six composers after surname constraint.\nJ. S. Bach\nMozart\nBeethoven\nChopin\nLiszt\nDebussy\nCorrect\n129\n72\n76\n96\n141\n27\nIncorrect\n44\n16\n5\n21\n6\n3\nAccuracy\n75%\n82%\n94%\n82%\n96%\n90%\n86.67%, and 88.14%, respectively. In this work, we set\nthe threshold to 0.5 to balance the precision and recall\nfor solo piano detection.\n5.2\nMetadata Evaluation\nWe randomly select 200 solo piano works from the\nfull GiantMIDI-Piano dataset and manually check how\nmany audio recordings and metadata are matched.\nWe observe that 174 out of 200 solo piano works are\ncorrectly matched, leading to a metadata accuracy of\n87%. Most errors are caused by mismatched composer\nnames. For example, when the keyword X is Chartier,\nMathieu, Nocturne No.1 composed by Chartier, the retrieved YouTube title Y is Nocturne No. 1 composed by\nChopin. After surname constraint, 136 out of 140 solo\npiano works are correctly matched, leading to a precision of 97.14%. We also observe that there are 180 live\nperformances and 20 sequenced MIDI files out of 200\nsolo piano works.\nFurthermore, Table 2 shows the number of matched\nmusic works composed by six different composers. Correct indicates that the retrieved solo piano works are\nindeed composed by the composer. Incorrect indicates\nthat the retrieved music works are not composed by\nthe composer but are composed by someone else and\nare attached to the composer. Without surname constraint, Liszt achieves the highest match accuracy of\n90%, while Chopin achieves the lowest match accuracy of 37%. Table 3 shows that the match accuracy\nof Chopin increases from 37% to 82% after surname\nconstraint. The accuracy of other composers also increases. The curated GiantMIDI-Piano dataset contains\n7,236 MIDI files composed by 1,787 composers. We\nuse a youtube_title_contains_surname flag in the metadata file to indicate whether the surname is verified.\n5.3\nPiano Transcription Evaluation\nThe piano transcription system achieves a state-of-theart onset F1 score of 96.72%, onset and offset F1 score\nof 82.47%, and an onset, offset, and velocity F1 score\nof 80.92% on the test set of the MAESTRO dataset.\nThe sustain pedal transcription system achieves an onset F1 of 91.86%, and a sustain-pedal onset and off-\n\f9\nAnonymous: GiantMIDI-Piano: A large-scale MIDI Dataset for Classical Piano Music\nS\nD\nI\nER\n0.00\n0.05\n0.10\n0.15\n0.20\n0.25\n0.30\nMaestro\nS\nD\nI\nER\n0.00\n0.05\n0.10\n0.15\n0.20\n0.25\n0.30\nGiantMIDI-Piano\nS\nD\nI\nER\n0.00\n0.05\n0.10\n0.15\n0.20\n0.25\n0.30\nRelative difference\nFigure 13: From left to right: ER of 52 solo piano works in the MAESTRO dataset; ER of 52 solo piano works in\nthe GiantMIDI-Piano dataset; Relative ER between the MAESTRO and the GiantMIDI-Piano dataset.\nset F1 of 86.58%.\nThe piano transcription system\noutperforms the previous onsets and frames system\nHawthorne et al. (2018, 2019) with an onset F1 score\nof 94.80%.\nWe evaluate the quality of GiantMIDI-Piano on 52\nmusic works that appear in all of the GiantMIDI-Piano,\nthe MAESTRO, and the Kunsterfuge (Kunstderfuge,\n2002) datasets.\nLong music works such as Sonatas\nare split into movements. Repeated music sections are\nremoved. Evaluating GiantMIDI-Piano is a challenging problem because there are no aligned ground-truth\nMIDI files, so the metrics in (Hawthorne et al., 2018)\nare not usable.\nIn this work, we propose to use an\nalignment metric (Nakamura et al., 2017) called error\nrate (ER) to evaluate the quality of transcribed MIDI\nfiles.\nThis metric reflects the substitution, deletion,\nand insertion between a transcribed MIDI file and a\ntarget MIDI file.\nFor a solo piano work, we align a\ntranscribed MIDI file with its sequenced MIDI version\nusing a hidden Markov model (HMM) tool (Nakamura\net al., 2017), where the sequenced MIDI files are from\nthe Kunsterfuge (Kunstderfuge, 2002) dataset. The ER\nis defined as the summation of substitution, insertion,\nand deletion:\nER = S +D + I\nN\n,\n(3)\nwhere N is the number of reference notes, and S, I,\nand D are the number of substitution, insertion, and\ndeletion, respectively. Substitution indicates that some\nnotes are replacements of ground truth notes. Insertion indicates that extra notes are being played. Deletion indicates that some notes are missing. Lower ER\nindicates better transcription performance.\nThe ER of music works from GiantMIDI-Piano consists of three parts: 1) performance errors, 2) transcription errors, and 3) alignment errors:\nERG = eperformanceG +etranscriptionG +ealignmentG\n(4)\nwhere\nthe\nsubscript\nG\nis\nthe\nabbreviation\nfor\nGiantMIDI-Piano. The performance errors eperformanceG\nTable 4: Piano\ntranscription\nevaluation\non\nthe\nGiantMIDI-Piano dataset\nD\nI\nS\nER\nMaestro\n0.009\n0.024\n0.018\n0.061\nGiantMIDI-Piano\n0.015\n0.051\n0.069\n0.154\nRelative difference\n0.006\n0.026\n0.047\n0.094\ncome from that a pianist may accidentally miss or add\nnotes while performing (Repp, 1996). The transcription errors etranscriptionG come from piano transcription\nsystem errors. The alignment errors ealignmentG come\nfrom the sequence alignment algorithm (Nakamura\net al., 2017).\nAudio recordings and MIDI files are perfectly\naligned in the MAESTRO dataset, so there are no transcription errors. The ER can be written as:\nERM = eperformanceM +ealignmentM,\n(5)\nwhere the subscript M is the abbreviation for MAESTRO. For a same music work, we assume an approximation eperformanceG \u2248 eperformanceM despite the performance among pianists are different. Similarly, we assume an approximation ealignmentG \u2248 ealignmentM despite\nthe alignment errors are different.\nThose approximations are more accurate when the\nlevels of the two pianists are closer. Then, we propose\na relative error by subtracting (4) and (5):\nr = ERG \u2212ERM \u2248 etranscriptionG.\n(6)\nThe relative error r is a rough approximation of the\ntranscription errors etranscriptionG. A lower r value indicates better transcription quality.\nTable 4 shows the alignment performance.\nThe\nmedian alignment SM, DM, IM and ERM on the MAESTRO dataset are 0.009, 0.024, 0.021 and 0.061 respectively.\nThe median alignment SG, DG, IG and\nERG on the GiantMIDI-Piano dataset are 0.015, 0.051,\n\f10\nAnonymous: GiantMIDI-Piano: A large-scale MIDI Dataset for Classical Piano Music\n0.069 and 0.154 respectively. The relative error r between MAESTRO and GiantMIDI-Piano is 0.094. The\nfirst column of Fig.\n13 shows the box plot metrics\nof MAESTRO. Some outliers are omitted from the figures for better visualization. Some outliers are mostly\ncaused by different interpretations of trills and tremolos. The second column of Fig. 13 shows the box plot\nmetrics of GiantMIDI-Piano. In GiantMIDI-Piano, Keyboard Sonata in E-Flat Major, Hob. XVI/49 composed\nby Haydn achieves the lowest ER of 0.037, while Prelude and Fugue in A-flat major, BWV 862 composed by\nBach achieves the highest ER of 0.679 (outlier beyond\nthe plot range). This underperformance is due to the\npiano is not tuned to a standard pitch with A4 of 440\nHz. The third column of Fig. 13 shows the relative ER\nbetween MAESTRO and GiantMIDI-Piano. The relative\nmedian scores of S, D, I and ER are 0.006, 0.026, 0.047\nand 0.094 respectively. Fig. 13 also shows that there\nare fewer deletions than insertions.\n6. Conclusion\nWe collect and transcribe a large-scale GiantMIDIPiano dataset containing 38,700,838 transcribed piano notes from 10,855 unique classical piano works\ncomposed by 2,786 composers.\nThe total duration\nof GiantMIDI-Piano is 1,237 hours. The curated subset contains 24,253,495 piano notes from 7,236 works\ncomposed by 1,787 composers.\nGiantMIDI-Piano is\ntranscribed from YouTube audio recordings searched\nby meta-information from IMSLP.\nThe solo piano detection system used in GiantMIDIPiano achieves an F1 score of 88.14%, and the piano\ntranscription system achieves a relative error rate of\n0.094.\nThe limitations of GiantMIDI-Piano include:\n1) There are no pitch spellings to distinguish enharmonic notes.\n2) GiantMIDI-Piano does not provide\nbeats, time signatures, key signatures, and scores. 2)\nGiantMIDI-Piano does not disentangle the music score\nand the expressive performance of pianists.\nWe have released the source code for acquiring\nGiantMIDI-Piano. In the future, GiantMIDI-Piano can\nbe used in many research areas, including but not limited to musical analysis, music generation, music information retrieval, and expressive performance analysis.\n7. Acknowledgement\nWe thank all anonymous reviewers, editors, and copy\neditors for their substantial reviews of this manuscript.\nWe thank Prof. Xiaofeng Zhang for passing his composition knowledge to Qiuqiang Kong during his undergraduate study at the South China University of Technology.\nReferences\nBainbridge, D. and Bell, T. (2001). The challenge of\noptical music recognition. Computers and the Humanities, 35(2):95\u2013121.\nBryner, B. (2002). The piano roll: a valuable recording medium of the twentieth century. PhD thesis,\nDepartment of Music, University of Utah.\nCancino-Chac\u00f3n, C. E., Grachten, M., Goebl, W., and\nWidmer, G. (2018). Computational models of expressive music performance: A comprehensive and\ncritical review.\nFrontiers in Digital Humanities,\n5:25.\nCasey, M. A., Veltkamp, R., Goto, M., Leman, M.,\nRhodes, C., and Slaney, M. (2008).\nContentbased music information retrieval: Current directions and future challenges.\nProceedings of the\nIEEE, 96(4):668\u2013696.\nChoi, K., Fazekas, G., Cho, K., and Sandler, M. (2017).\nA tutorial on deep learning for music information\nretrieval. arXiv preprint arXiv:1709.04396.\nClassical Archives (2000).\nClassical Archives.\nwww.\nclassicalarchives.com.\nConklin, D. and Witten, I. H. (1995). Multiple viewpoint systems for music prediction. Journal of New\nMusic Research, 24(1):51\u201373.\nDuan, Z., Pardo, B., and Zhang, C. (2010).\nMultiple fundamental frequency estimation by modeling\nspectral peaks and non-peak regions. IEEE Transactions on Audio, Speech, and Language Processing,\n18(8):2121\u20132133.\nEmiya, V., Bertin, N., David, B., and Badeau, R. (2010).\nMaps-a piano database for multipitch estimation\nand automatic transcription of music. In Research\nReport, INRIA-00544155f.\nForte, A. (1973). The structure of atonal music, volume\n304. Yale University Press.\nFoscarin, F., Mcleod, A., Rigaux, P., Jacquemard, F.,\nand Sakai, M. (2020). ASAP: a dataset of aligned\nscores and performances for piano transcription.\nIn International Society for Music Information Retrieval (ISMIR).\nGlorot, X., Bordes, A., and Bengio, Y. (2011). Deep\nsparse rectifier neural networks. In Proceedings of\nthe Conference on Artificial Intelligence and Statistics, pages 315\u2013323.\nGood, M. et al. (2001). MusicXML: An internet-friendly\nformat for sheet music. In XML conference and expo,\npages 03\u201304. Citeseer.\nHashida, M., Matsui, T., and Katayose, H. (2008).\nA new music database describing deviation information of performance expressions.\nIn International Society for Music Information Retrieval (ISMIR), pages 489\u2013494.\nHawthorne, C., Elsen, E., Song, J., Roberts, A., Simon, I., Raffel, C., Engel, J., Oore, S., and Eck,\nD. (2018). Onsets and frames: Dual-objective piano transcription. In International Society for Music\nInformation Retrieval (ISMIR).\nHawthorne, C., Stasyuk, A., Roberts, A., Simon, I.,\nHuang, C. A., Dieleman, S., Elsen, E., Engel, J.,\nand Eck, D. (2019).\nEnabling factorized piano\n\f11\nAnonymous: GiantMIDI-Piano: A large-scale MIDI Dataset for Classical Piano Music\nmusic modeling and generation with the maestro\ndataset. International Conference on Learning Representations (ICLR).\nHuang, C.-Z. A., Hawthorne, C., Roberts, A., Dinculescu, M., Wexler, J., Hong, L., and Howcroft,\nJ. (2019). The Bach Doodle: Approachable music\ncomposition with machine learning at scale. In International Society for Music Information Retrieval\n(ISMIR).\nHuang, C.-Z. A., Vaswani, A., Uszkoreit, J., Simon, I.,\nHawthorne, C., Shazeer, N., Dai, A. M., Hoffman,\nM. D., Dinculescu, M., and Eck, D. (2018). Music transformer: Generating music with long-term\nstructure. In International Conference on Learning\nRepresentations (ICLR).\nIMSLP (2006).\nInternational Music Score Library\nProject. imslp.org.\nIoffe, S. and Szegedy, C. (2015). Batch normalization:\nAccelerating deep network training by reducing internal covariate shift. Proceedings of the International Conference on Machine Learning (ICML).\nKim, J. W. and Bello, J. P. (2019). Adversarial learning\nfor improved onsets and frames music transcription. In International Society for Music Information\nRetrieval (ISMIR).\nKong, Q., Cao, Y., Iqbal, T., Wang, Y., Wang, W.,\nand Plumbley, M. D. (2020). PANNs: Large-scale\npretrained audio neural networks for audio pattern recognition. IEEE/ACM Transactions on Audio,\nSpeech, and Language Processing, 28:2880\u20132894.\nKong, Q., Li, B., Song, X., Wan, Y., and Wang, Y.\n(2021). High-resolution piano transcription with\npedals by regressing onsets and offsets times.\nIEEE/ACM Transactions on Audio, Speech, and Language Processing, 29:3707\u20133717.\nKrueger, B. (1996). Classical Piano MIDI Page. http:\n//www.piano-midi.de.\nKunstderfuge (2002).\nKunstderfuge.\nhttp://www.\nkunstderfuge.com.\nKwon, T., Jeong, D., and Nam, J. (2020).\nPolyphonic piano transcription using autoregressive\nmulti-state note model. In International Society for\nMusic Information Retrieval (ISMIR).\nLi, B., Liu, X., Dinesh, K., Duan, Z., and Sharma, G.\n(2018). Creating a multitrack classical music performance dataset for multimodal music analysis:\nChallenges, insights, and applications. IEEE Transactions on Multimedia, 21(2):522\u2013535.\nMeredith, D. (2016).\nComputational music analysis,\nvolume 62. Springer.\nNakamura, E., Yoshii, K., and Katayose, H. (2017). Performance error detection and post-processing for\nfast and accurate symbolic music alignment. In International Society for Music Information Retrieval\n(ISMIR), pages 347\u2013353.\nNienhuys, H.-W. and Nieuwenhuizen, J. (2003). Lilypond, a system for automated music engraving. In\nProceedings of the XIV Colloquium on Musical Informatics, volume 1, pages 167\u2013171. Citeseer.\nNiwattanakul, S., Singthongchai, J., Naenudorn, E.,\nand Wanapu, S. (2013).\nUsing of Jaccard coefficient for keywords similarity.\nIn Proceedings of\nthe International MultiConference of Engineers and\nComputer Scientists (IMECS), pages 380\u2013384.\nRaffel, C. (2016).\nLearning-based methods for comparing sequences, with applications to audio-to-midi\nalignment and matching.\nPhD thesis, Columbia\nUniversity.\nRebelo, A., Fujinaga, I., Paszkiewicz, F., Marcal, A. R.,\nGuedes, C., and Cardoso, J. S. (2012). Optical music recognition: state-of-the-art and open issues.\nInternational Journal of Multimedia Information Retrieval, 1(3):173\u2013190.\nRepp, B. H. (1996). The art of inaccuracy: Why pianists\u2019 errors are difficult to hear. Music Perception,\n14(2):161\u2013183.\nRoland, P. (2002).\nThe music encoding initiative\n(MEI). In Proceedings of the First International Conference on Musical Applications Using XML, volume\n1060, pages 55\u201359.\nSapp, C. S. (2005). Online database of scores in the\nhumdrum file format. In International Society for\nMusic Information Retrieval (ISMIR), pages 664\u2013\n665.\nShi, Z., Sapp, C. S., Arul, K., McBride, J., and Smith III,\nJ. O. (2019). Supra: Digitizing the stanford university piano roll archive.\nIn International Society for Music Information Retrieval (ISMIR), pages\n517\u2013523.\nSmith, D. and Wood, C. (1981). The \u2018USI\u2019, or Universal\nSynthesizer Interface. In Audio Engineering Society\nConvention 70.\nVolk, A., Wiering, F., and K., P. K. (2011). Unfolding\nthe potential of computational musicology. In International Conference on Informatics and Semiotics\nin Organisations (ICISO), pages 137\u2013144.\nYang, L., Chou, S., and Yang, Y. (2017). MidiNet: A\nconvolutional generative adversarial network for\nsymbolic-domain music generation.\nIn International Society for Music Information Retrieval (ISMIR), pages 324\u2013331.\n\f", "text_mmd": null}}, "generated_section_text": {"gpt-3.5-turbo": {"text": "Datasets - MIDI\n\nMIDI (Musical Instrument Digital Interface) is a widely used format for representing music in a digital form. MIDI datasets have played a crucial role in advancing deep music generation research. In this section, we discuss several notable MIDI datasets that have been used for deep music generation tasks.\n\nThe KernScores dataset [REF0] contains classical music in a Humdrum format and is obtained through an optical music recognition system. It provides a valuable resource for studying classical music composition and analysis. Another dataset, Kunstderfuge [REF0], includes solo piano and non-solo piano works of 598 composers. The piano-midi.de, classical archives, and Kunstderfuge datasets are entered using a MIDI sequencer and are not played by pianists [REF0].\n\nThe MAPS dataset [REF0] utilizes MIDI files from Piano-midi.de to render real recordings by playing back the MIDI files on a Yamaha Disklavier. This dataset enables researchers to explore the relationship between MIDI representations and real piano performances. The MAESTRO dataset [REF0] contains over 200 hours of fine alignment MIDI files and audio recordings. It features virtuoso pianists performing on Yamaha Disklaviers with an integrated MIDI capture system. MAESTRO encompasses music works from 62 composers, providing a diverse and high-quality resource for deep music generation research [REF0].\n\nMIDI datasets offer various advantages for deep music generation tasks. They provide a structured representation of music, including information about pitch, duration, articulation marking, tempo, and more [REF6]. This rich set of features allows models to capture the nuances of musical expression. Additionally, MIDI datasets enable the exploration of multi-instrumental music generation by assigning notes to different instrument voices [REF3].\n\nHowever, MIDI datasets also have limitations. They often lack expressive performance features, such as absolute tempo, velocity, and articulation usage [REF6]. This can limit the ability of models to generate music with realistic and nuanced performances. Furthermore, MIDI datasets may not fully capture the intricacies of human performances, as they are often created through sequencers rather than being played by musicians [REF0].\n\nIn summary, MIDI datasets have been instrumental in advancing deep music generation research. They provide structured representations of music and enable the exploration of multi-instrumental music generation. However, they also have limitations in capturing expressive performance features. Future research should focus on addressing these limitations and developing more comprehensive and diverse MIDI datasets for deep music generation tasks.\n\n[REF0] Sapp, C. (2005). The KernScores dataset.\n[REF0] Kunstderfuge. (2002). The Kunstderfuge dataset.\n[REF0] Emiya, V., et al. (2010). The MAPS dataset.\n[REF0] Hawthorne, C., et al. (2019). The MAESTRO dataset.\n[REF3] Davis, B., & Mohammad, S. (Year). Title of the paper.\n[REF6] Author, A., & Author, B. (Year). Title of the paper.", "references_sent_to_gpt": [{"title": "Giantmidi-piano: A large-scale midi dataset for classical piano music", "bibref": "BIBREF358", "authors": [{"first": "Qiuqiang", "middle": [], "last": "Kong", "suffix": ""}, {"first": "Bochen", "middle": [], "last": "Li", "suffix": ""}, {"first": "Jitong", "middle": [], "last": "Chen", "suffix": ""}, {"first": "Yuxuan", "middle": [], "last": "Wang", "suffix": ""}], "chunk": "Giantmidi-piano: A large-scale midi dataset for classical piano music [SEP] The KernScores dataset (Sapp, 2005) contains classical music with a Humdrum format and is obtained\nby an optical music recognition system.\n The Kunstderfuge dataset (Kunstderfuge, 2002) contains solo piano and non-solo piano works of 598 composers. All of\nthe piano-midi.de, classical archives, and Kunstderfuge\ndatasets are entered using a MIDI sequencer and are\nnot played by pianists.\n The MAPS dataset (Emiya et al., 2010) used MIDI\nfiles from Piano-midi.de to render real recordings by\nplaying back the MIDI files on a Yamaha Disklavier. The\nMAESTRO dataset (Hawthorne et al., 2019) contains\nover 200 hours of fine alignment MIDI files and audio\nrecordings. In MAESTRO, virtuoso pianists performed\non Yamaha Disklaviers with an integrated MIDI capture\nsystem. MAESTRO contains music works from 62 composers."}, {"title": "Automatic melody harmonization with triad chords: A comparative study", "bibref": "BIBREF179", "authors": [{"first": "Yin-Cheng", "middle": [], "last": "Yeh", "suffix": ""}, {"first": "Wen-Yi", "middle": [], "last": "Hsiao", "suffix": ""}, {"first": "Satoru", "middle": [], "last": "Fukayama", "suffix": ""}, {"first": "Tetsuro", "middle": [], "last": "Kitahara", "suffix": ""}, {"first": "Benjamin", "middle": [], "last": "Genchel", "suffix": ""}, {"first": "", "middle": [], "last": "Hao-Min", "suffix": ""}, {"first": "Hao-Wen", "middle": [], "last": "Liu", "suffix": ""}, {"first": "Yian", "middle": [], "last": "Dong", "suffix": ""}, {"first": "Terence", "middle": [], "last": "Chen", "suffix": ""}, {"first": "Yi-Hsuan", "middle": [], "last": "Leong", "suffix": ""}, {"first": "", "middle": [], "last": "Yang", "suffix": ""}], "chunk": "Automatic melody harmonization with triad chords: A comparative study [SEP] The other chords all fall into the others category.\n We identify two potential benefits of adding chord functions to the target output.\n First, in contrast to the distribution of chord labels, the distribution of chord functions\nis relatively balanced, making it easier for the model to learn the chord functions.\n Second, as the chord functions and chord labels are interdependent, adding the chord\nfunctions as a target informs the model which chord labels share the same function and\nmay therefore be interchangeable. We hypothesize that this multi-task learning will\nhelp our model learn proper functional progression, which in turn will produce better\nharmonic phrasing relative to the melody. Specifically, the loss function is defined as:\nL\u2217\n=\nLchord + \u03b3Lfunction\n=\nH( \u02c6Ychord, Ychord) +"}, {"title": "The million song dataset", "bibref": "BIBREF356", "authors": [{"first": "Thierry", "middle": [], "last": "Bertin-Mahieux", "suffix": ""}, {"first": "Daniel", "middle": [], "last": "PW Ellis", "suffix": ""}, {"first": "Brian", "middle": [], "last": "Whitman", "suffix": ""}, {"first": "Paul", "middle": [], "last": "Lamere", "suffix": ""}], "chunk": "The million song dataset [SEP] The idea of a \u201cmillion song\ndataset\u201d started as a flippant suggestion of what it would\ntake to solve this problem. But the idea stuck \u2013 not only in\nthe form of developing a very large, common dataset, but\neven in the specific scale of one million tracks.\n There are a several possible reasons why the community\ndoes not already have a dataset of this scale:\n\u2022 We all already have our favorite, personal datasets of\nhundreds or thousands of tracks, and to a large extent\nwe are happy with the results we get from them.\n \u2022 Collecting the actual music for a dataset of more than\na few hundred CDs (i.e. the kind of thing you can do\nby asking all your colleagues to lend you their collections) becomes something of a challenge.\n\f \u2022 The well-known antagonistic stance of the recording\nindustry to the digital sharing of their data seems to\ndoom any effort to share large music collections.\n"}, {"title": "The nes music database: A multi-instrumental dataset with expressive performance attributes", "bibref": "BIBREF199", "authors": [{"first": "Chris", "middle": [], "last": "Donahue", "suffix": ""}, {"first": "Huanru", "middle": [], "last": "Henry Mao", "suffix": ""}, {"first": "Julian", "middle": [], "last": "Mcauley", "suffix": ""}], "chunk": "The nes music database: A multi-instrumental dataset with expressive performance attributes [SEP] This representation simplifies the probabilistic framework of the task, but it is problematic for music with multiple instruments (such as the music in NES-MDB). Resultant systems must provide an additional mechanism for\nassigning notes of a blended score to instrument voices,\nor otherwise render the music on polyphonic instruments\nsuch as the piano.\n 2.2 Separated composition\nGiven the shortcomings of the blended score , we might\nprefer models which operate on a separated score representation (Fig. 1b). A separated score S is a matrix of size\nV \u00d7 T, where V is the number of instrument voices, and\nS[v, t] = n, the note n played by voice v at timestep t. In\nother words, the format encodes a monophonic sequence\nfor each instrument voice. Statistical approaches to this\nrepresentation can explicitly model the relationships between various instrument voices by\nP(c) =\nT\n\ufffd\nt=1\nV\ufffd\nv=1\nP(Sv,t | Sv,\u02c6t\u0338=t, S\u02c6v\u0338=v,\u2200\u02c6t).\n"}, {"title": "Learning to generate music with sentiment", "bibref": "BIBREF306", "authors": [{"first": "Lucas", "middle": [], "last": "Ferreira", "suffix": ""}, {"first": "Jim", "middle": [], "last": "Whitehead", "suffix": ""}], "chunk": "Learning to generate music with sentiment [SEP] MODEL\n We propose a Deep Learning method for affective algorithmic composition that can be controlled to generate music\nwith a given sentiment. This method is based on the work\nof Radford et al. [13] which generates product reviews (in\ntextual form) with sentiment. Radford et al. [13] used a\nsingle-layer multiplicative long short-term memory (mLSTM) network [8] with 4096 units to process text as a sequence of UTF-8 encoded bytes (character-based language\nmodeling)."}, {"title": "Learning to generate music with sentiment", "bibref": "BIBREF306", "authors": [{"first": "Lucas", "middle": [], "last": "Ferreira", "suffix": ""}, {"first": "Jim", "middle": [], "last": "Whitehead", "suffix": ""}], "chunk": "Learning to generate music with sentiment [SEP] A second-order Markov\nmodel is used to learn melodies from a dataset and are\nthen transformed by a rule-based system to fit the annotated emotions in the graph. Davis and Mohammad [4]\nfollow a similar approach in TransPose, a system that composes piano melodies for novels. TransPose uses a lexiconbased approach to automatically detect emotions (categorical model) in novels and a rule-based technique to create\npiano melodies with these emotions.\n There are a few other approaches in the literature to\ncompose music with a given emotion. Scirea et al. [16]\nrecently presented a framework called MetaCompose designed to create background music for games in real-time.\n MetaCompose generates music by (i) randomly creating\na chord sequence from a pre-defined chord progression\ngraph, (ii) evolving a melody for this chord sequence using a genetic algorithm and (iii) producing an accompaniment for the melody/chord sequence combination."}, {"title": "Virtuosonet: A hierarchical rnn-based system for modeling expressive piano performance", "bibref": "BIBREF354", "authors": [{"first": "Dasaem", "middle": [], "last": "Jeong1", "suffix": ""}, {"first": "Taegyun", "middle": [], "last": "Kwon1", "suffix": ""}, {"first": "Yoojin", "middle": [], "last": "Kim1", "suffix": ""}, {"first": "Kyogu", "middle": [], "last": "Lee2", "suffix": ""}, {"first": "Juhan", "middle": [], "last": "Nam1", "suffix": ""}], "chunk": "Virtuosonet: A hierarchical rnn-based system for modeling expressive piano performance [SEP] The score features include pitch, duration, articulation marking, slur and beam\nstatus, tempo marking, dynamic markings, and so on. The\nperformance features include absolute tempo, velocity, onset deviation, articulation and pedal usages. All the features\nare encoded in the note-level so that each note had the same\ndimension of score features and performance features.\n 3.1.2 Hierarchical Attention Network\nRecent research has shown that a hierarchical approach can\nimprove the performance of RNN model in modeling sequential data [6, 30]. It was also demonstrated that the hierarchical approach has advantages in generating symbolic\nmusic data [25]. In this paper, we employ a hierarchical\nattention network (HAN) to predict a sequence of performance features from a sequence of score features.\n The HAN composes higher-level representations by\nsummarizing lower-level representations in pre-defined hierarchical boundaries using a weighted sum."}, {"title": "The nus sung and spoken lyrics corpus: A quantitative comparison of singing and speech", "bibref": "BIBREF316", "authors": [{"first": "Zhiyan", "middle": [], "last": "Duan", "suffix": ""}, {"first": "Haotian", "middle": [], "last": "Fang", "suffix": ""}, {"first": "Bo", "middle": [], "last": "Li", "suffix": ""}, {"first": "Khe", "middle": ["Chai"], "last": "Sim", "suffix": ""}, {"first": "Ye", "middle": [], "last": "Wang", "suffix": ""}], "chunk": "The nus sung and spoken lyrics corpus: A quantitative comparison of singing and speech [SEP] II. \n RELATED WORK \n\fA. \nSinging Voice Dataset \nSinging datasets of various sizes and annotated contents are \navailable for research purposes.   To the best of our knowledge, \nhowever, none has duration annotations at the phoneme level.  \n Mesaros and Virtanen conducted automatic recognition of \nsung lyrics using 49 singing clips, 19 of which are from male \nsingers and 30 from female singers [4].   Each clip is 20-30 \nseconds long, and the complete dataset amounts to \napproximately 30 minutes.   Although a total of 4770 phoneme \ninstances are present, the lyrics of each singing clip are \nmanually transcribed only at the word level, without any \nduration boundaries.  \n The MIR-1K dataset [6] is a larger dataset consisting of \n1000 clips from 110 unique Chinese songs as sung by 19 \namateur singers, 8 of whom female.  "}, {"title": "A database linking piano and orchestral midi scores with application to automatic projective orchestration", "bibref": "BIBREF357", "authors": [{"first": "L\u00e9opold", "middle": [], "last": "Crestel", "suffix": ""}, {"first": "Philippe", "middle": [], "last": "Esling", "suffix": ""}, {"first": "Lena", "middle": [], "last": "Heng", "suffix": ""}, {"first": "Stephen", "middle": [], "last": "McAdams", "suffix": ""}], "chunk": "A database linking piano and orchestral midi scores with application to automatic projective orchestration [SEP] As discussed in [5], we make the\nassumption that an accurate predictive model will be able\nto generate original acceptable works. Whereas evaluating\nthe generation of a complete musical score is subjective\nand difficult to quantify, a predictive framework provides\nus with a quantitative evaluation of the performance of a\nmodel. Indeed, many satisfying orchestrations can be created from the same piano score. However, the number of\nreasonable inferences of an orchestral frame given its context (as described in equation 2) is much more limited.\n As suggested in [4,12], the accuracy measure [2] can be\nused to compare an inferred frame \u02c6O(t) drawn from (2) to\nthe ground-truth O(t) from the original file.\n Accuracy(t) = 100 .\nTP(t)\nTP(t)"}, {"title": "Giantmidi-piano: A large-scale midi dataset for classical piano music", "bibref": "BIBREF358", "authors": [{"first": "Qiuqiang", "middle": [], "last": "Kong", "suffix": ""}, {"first": "Bochen", "middle": [], "last": "Li", "suffix": ""}, {"first": "Jitong", "middle": [], "last": "Chen", "suffix": ""}, {"first": "Yuxuan", "middle": [], "last": "Wang", "suffix": ""}], "chunk": "Giantmidi-piano: A large-scale midi dataset for classical piano music [SEP] Substitution indicates that some\nnotes are replacements of ground truth notes. Insertion indicates that extra notes are being played. Deletion indicates that some notes are missing. Lower ER\nindicates better transcription performance.\n The ER of music works from GiantMIDI-Piano consists of three parts: 1) performance errors, 2) transcription errors, and 3) alignment errors:\n ERG = eperformanceG +etranscriptionG +ealignmentG\n(4)\nwhere\nthe\nsubscript\nG\nis\nthe\nabbreviation\nfor\nGiantMIDI-Piano. The performance errors eperformanceG\nTable 4: Piano\ntranscription\nevaluation\non\nthe\nGiantMIDI-Piano dataset\nD\nI\nS\nER\nMaestro\n0.009\n0.024\n0.018\n0.061\nGiantMIDI-Piano\n0.015\n0.051\n0.069\n0.154\nRelative difference\n0.006\n0.026\n0.047\n0.094\ncome from that a pianist may accidentally miss or add\nnotes while performing (Repp, 1996)."}]}, "gpt-4-1106-preview": {"text": "In the realm of deep music generation, MIDI datasets play a crucial role as they provide the structured data necessary for training and evaluating generative models. One of the earliest datasets in this domain is the KernScores dataset, which contains classical music in Humdrum format, obtained through an optical music recognition system [REF0]. Another significant dataset is Kunstderfuge, which includes both solo and non-solo piano works from a wide range of composers, with the data entered using a MIDI sequencer rather than being performed by pianists [REF0].\n\nThe MAPS dataset takes a different approach by using MIDI files from Piano-midi.de to render real recordings on a Yamaha Disklavier, thereby providing a link between MIDI data and actual acoustic recordings [REF0]. This is further extended by the MAESTRO dataset, which contains over 200 hours of fine alignment MIDI files and audio recordings, performed by virtuoso pianists on Yamaha Disklaviers with an integrated MIDI capture system, offering a rich resource for both transcription and performance modeling [REF0].\n\nThe GiantMIDI-Piano dataset is another valuable resource, which includes a large collection of piano MIDI files. It is particularly useful for evaluating transcription performance, as it allows for the analysis of performance, transcription, and alignment errors [REF1]. This dataset can be instrumental in developing systems that can accurately transcribe piano music and understand the nuances of a pianist's performance.\n\nHowever, when dealing with music that involves multiple instruments, datasets like NES-MDB highlight the challenges of representing and generating polyphonic music, where systems must provide mechanisms for assigning notes to specific instrument voices [REF2]. This complexity necessitates the development of models that can handle separated score representations, where each instrument's voice is encoded as a monophonic sequence, allowing for explicit modeling of the relationships between different instrument voices [REF2].\n\nIn addition to the note-level information typically found in MIDI files, datasets can also include a variety of score and performance features, such as pitch, duration, articulation markings, and dynamic markings, which are essential for generating expressive music performances [REF3]. These features enable the development of sophisticated models, such as hierarchical attention networks, which can predict sequences of performance features from sequences of score features [REF3].\n\nThe challenge of creating large-scale datasets for music generation is not trivial, as evidenced by the \"million song dataset\" idea, which highlights the difficulties in collecting and sharing large music collections due to various logistical and legal challenges [REF5]. Despite these challenges, the creation of comprehensive datasets is crucial for advancing research in music information retrieval and generation.\n\nIn conclusion, MIDI datasets are indispensable for the development and evaluation of deep music generation systems. They provide the necessary data for training models to understand and generate music with various levels of complexity, from solo piano pieces to full orchestral scores. As the field progresses, the creation and refinement of these datasets will continue to be a critical area of research, enabling the development of more advanced and expressive music generation systems.", "references_sent_to_gpt": [{"title": "Giantmidi-piano: A large-scale midi dataset for classical piano music", "bibref": "BIBREF358", "authors": [{"first": "Qiuqiang", "middle": [], "last": "Kong", "suffix": ""}, {"first": "Bochen", "middle": [], "last": "Li", "suffix": ""}, {"first": "Jitong", "middle": [], "last": "Chen", "suffix": ""}, {"first": "Yuxuan", "middle": [], "last": "Wang", "suffix": ""}], "chunk": "Giantmidi-piano: A large-scale midi dataset for classical piano music [SEP] The KernScores dataset (Sapp, 2005) contains classical music with a Humdrum format and is obtained\nby an optical music recognition system.\n The Kunstderfuge dataset (Kunstderfuge, 2002) contains solo piano and non-solo piano works of 598 composers. All of\nthe piano-midi.de, classical archives, and Kunstderfuge\ndatasets are entered using a MIDI sequencer and are\nnot played by pianists.\n The MAPS dataset (Emiya et al., 2010) used MIDI\nfiles from Piano-midi.de to render real recordings by\nplaying back the MIDI files on a Yamaha Disklavier. The\nMAESTRO dataset (Hawthorne et al., 2019) contains\nover 200 hours of fine alignment MIDI files and audio\nrecordings. In MAESTRO, virtuoso pianists performed\non Yamaha Disklaviers with an integrated MIDI capture\nsystem. MAESTRO contains music works from 62 composers."}, {"title": "Giantmidi-piano: A large-scale midi dataset for classical piano music", "bibref": "BIBREF358", "authors": [{"first": "Qiuqiang", "middle": [], "last": "Kong", "suffix": ""}, {"first": "Bochen", "middle": [], "last": "Li", "suffix": ""}, {"first": "Jitong", "middle": [], "last": "Chen", "suffix": ""}, {"first": "Yuxuan", "middle": [], "last": "Wang", "suffix": ""}], "chunk": "Giantmidi-piano: A large-scale midi dataset for classical piano music [SEP] Substitution indicates that some\nnotes are replacements of ground truth notes. Insertion indicates that extra notes are being played. Deletion indicates that some notes are missing. Lower ER\nindicates better transcription performance.\n The ER of music works from GiantMIDI-Piano consists of three parts: 1) performance errors, 2) transcription errors, and 3) alignment errors:\n ERG = eperformanceG +etranscriptionG +ealignmentG\n(4)\nwhere\nthe\nsubscript\nG\nis\nthe\nabbreviation\nfor\nGiantMIDI-Piano. The performance errors eperformanceG\nTable 4: Piano\ntranscription\nevaluation\non\nthe\nGiantMIDI-Piano dataset\nD\nI\nS\nER\nMaestro\n0.009\n0.024\n0.018\n0.061\nGiantMIDI-Piano\n0.015\n0.051\n0.069\n0.154\nRelative difference\n0.006\n0.026\n0.047\n0.094\ncome from that a pianist may accidentally miss or add\nnotes while performing (Repp, 1996)."}, {"title": "The nes music database: A multi-instrumental dataset with expressive performance attributes", "bibref": "BIBREF199", "authors": [{"first": "Chris", "middle": [], "last": "Donahue", "suffix": ""}, {"first": "Huanru", "middle": [], "last": "Henry Mao", "suffix": ""}, {"first": "Julian", "middle": [], "last": "Mcauley", "suffix": ""}], "chunk": "The nes music database: A multi-instrumental dataset with expressive performance attributes [SEP] This representation simplifies the probabilistic framework of the task, but it is problematic for music with multiple instruments (such as the music in NES-MDB). Resultant systems must provide an additional mechanism for\nassigning notes of a blended score to instrument voices,\nor otherwise render the music on polyphonic instruments\nsuch as the piano.\n 2.2 Separated composition\nGiven the shortcomings of the blended score , we might\nprefer models which operate on a separated score representation (Fig. 1b). A separated score S is a matrix of size\nV \u00d7 T, where V is the number of instrument voices, and\nS[v, t] = n, the note n played by voice v at timestep t. In\nother words, the format encodes a monophonic sequence\nfor each instrument voice. Statistical approaches to this\nrepresentation can explicitly model the relationships between various instrument voices by\nP(c) =\nT\n\ufffd\nt=1\nV\ufffd\nv=1\nP(Sv,t | Sv,\u02c6t\u0338=t, S\u02c6v\u0338=v,\u2200\u02c6t).\n"}, {"title": "Virtuosonet: A hierarchical rnn-based system for modeling expressive piano performance", "bibref": "BIBREF354", "authors": [{"first": "Dasaem", "middle": [], "last": "Jeong1", "suffix": ""}, {"first": "Taegyun", "middle": [], "last": "Kwon1", "suffix": ""}, {"first": "Yoojin", "middle": [], "last": "Kim1", "suffix": ""}, {"first": "Kyogu", "middle": [], "last": "Lee2", "suffix": ""}, {"first": "Juhan", "middle": [], "last": "Nam1", "suffix": ""}], "chunk": "Virtuosonet: A hierarchical rnn-based system for modeling expressive piano performance [SEP] The score features include pitch, duration, articulation marking, slur and beam\nstatus, tempo marking, dynamic markings, and so on. The\nperformance features include absolute tempo, velocity, onset deviation, articulation and pedal usages. All the features\nare encoded in the note-level so that each note had the same\ndimension of score features and performance features.\n 3.1.2 Hierarchical Attention Network\nRecent research has shown that a hierarchical approach can\nimprove the performance of RNN model in modeling sequential data [6, 30]. It was also demonstrated that the hierarchical approach has advantages in generating symbolic\nmusic data [25]. In this paper, we employ a hierarchical\nattention network (HAN) to predict a sequence of performance features from a sequence of score features.\n The HAN composes higher-level representations by\nsummarizing lower-level representations in pre-defined hierarchical boundaries using a weighted sum."}, {"title": "Automatic melody harmonization with triad chords: A comparative study", "bibref": "BIBREF179", "authors": [{"first": "Yin-Cheng", "middle": [], "last": "Yeh", "suffix": ""}, {"first": "Wen-Yi", "middle": [], "last": "Hsiao", "suffix": ""}, {"first": "Satoru", "middle": [], "last": "Fukayama", "suffix": ""}, {"first": "Tetsuro", "middle": [], "last": "Kitahara", "suffix": ""}, {"first": "Benjamin", "middle": [], "last": "Genchel", "suffix": ""}, {"first": "", "middle": [], "last": "Hao-Min", "suffix": ""}, {"first": "Hao-Wen", "middle": [], "last": "Liu", "suffix": ""}, {"first": "Yian", "middle": [], "last": "Dong", "suffix": ""}, {"first": "Terence", "middle": [], "last": "Chen", "suffix": ""}, {"first": "Yi-Hsuan", "middle": [], "last": "Leong", "suffix": ""}, {"first": "", "middle": [], "last": "Yang", "suffix": ""}], "chunk": "Automatic melody harmonization with triad chords: A comparative study [SEP] The other chords all fall into the others category.\n We identify two potential benefits of adding chord functions to the target output.\n First, in contrast to the distribution of chord labels, the distribution of chord functions\nis relatively balanced, making it easier for the model to learn the chord functions.\n Second, as the chord functions and chord labels are interdependent, adding the chord\nfunctions as a target informs the model which chord labels share the same function and\nmay therefore be interchangeable. We hypothesize that this multi-task learning will\nhelp our model learn proper functional progression, which in turn will produce better\nharmonic phrasing relative to the melody. Specifically, the loss function is defined as:\nL\u2217\n=\nLchord + \u03b3Lfunction\n=\nH( \u02c6Ychord, Ychord) +"}, {"title": "The million song dataset", "bibref": "BIBREF356", "authors": [{"first": "Thierry", "middle": [], "last": "Bertin-Mahieux", "suffix": ""}, {"first": "Daniel", "middle": [], "last": "PW Ellis", "suffix": ""}, {"first": "Brian", "middle": [], "last": "Whitman", "suffix": ""}, {"first": "Paul", "middle": [], "last": "Lamere", "suffix": ""}], "chunk": "The million song dataset [SEP] The idea of a \u201cmillion song\ndataset\u201d started as a flippant suggestion of what it would\ntake to solve this problem. But the idea stuck \u2013 not only in\nthe form of developing a very large, common dataset, but\neven in the specific scale of one million tracks.\n There are a several possible reasons why the community\ndoes not already have a dataset of this scale:\n\u2022 We all already have our favorite, personal datasets of\nhundreds or thousands of tracks, and to a large extent\nwe are happy with the results we get from them.\n \u2022 Collecting the actual music for a dataset of more than\na few hundred CDs (i.e. the kind of thing you can do\nby asking all your colleagues to lend you their collections) becomes something of a challenge.\n\f \u2022 The well-known antagonistic stance of the recording\nindustry to the digital sharing of their data seems to\ndoom any effort to share large music collections.\n"}, {"title": "Learning to generate music with sentiment", "bibref": "BIBREF306", "authors": [{"first": "Lucas", "middle": [], "last": "Ferreira", "suffix": ""}, {"first": "Jim", "middle": [], "last": "Whitehead", "suffix": ""}], "chunk": "Learning to generate music with sentiment [SEP] A second-order Markov\nmodel is used to learn melodies from a dataset and are\nthen transformed by a rule-based system to fit the annotated emotions in the graph. Davis and Mohammad [4]\nfollow a similar approach in TransPose, a system that composes piano melodies for novels. TransPose uses a lexiconbased approach to automatically detect emotions (categorical model) in novels and a rule-based technique to create\npiano melodies with these emotions.\n There are a few other approaches in the literature to\ncompose music with a given emotion. Scirea et al. [16]\nrecently presented a framework called MetaCompose designed to create background music for games in real-time.\n MetaCompose generates music by (i) randomly creating\na chord sequence from a pre-defined chord progression\ngraph, (ii) evolving a melody for this chord sequence using a genetic algorithm and (iii) producing an accompaniment for the melody/chord sequence combination."}, {"title": "A database linking piano and orchestral midi scores with application to automatic projective orchestration", "bibref": "BIBREF357", "authors": [{"first": "L\u00e9opold", "middle": [], "last": "Crestel", "suffix": ""}, {"first": "Philippe", "middle": [], "last": "Esling", "suffix": ""}, {"first": "Lena", "middle": [], "last": "Heng", "suffix": ""}, {"first": "Stephen", "middle": [], "last": "McAdams", "suffix": ""}], "chunk": "A database linking piano and orchestral midi scores with application to automatic projective orchestration [SEP] As discussed in [5], we make the\nassumption that an accurate predictive model will be able\nto generate original acceptable works. Whereas evaluating\nthe generation of a complete musical score is subjective\nand difficult to quantify, a predictive framework provides\nus with a quantitative evaluation of the performance of a\nmodel. Indeed, many satisfying orchestrations can be created from the same piano score. However, the number of\nreasonable inferences of an orchestral frame given its context (as described in equation 2) is much more limited.\n As suggested in [4,12], the accuracy measure [2] can be\nused to compare an inferred frame \u02c6O(t) drawn from (2) to\nthe ground-truth O(t) from the original file.\n Accuracy(t) = 100 .\nTP(t)\nTP(t)"}, {"title": "The million song dataset", "bibref": "BIBREF356", "authors": [{"first": "Thierry", "middle": [], "last": "Bertin-Mahieux", "suffix": ""}, {"first": "Daniel", "middle": [], "last": "PW Ellis", "suffix": ""}, {"first": "Brian", "middle": [], "last": "Whitman", "suffix": ""}, {"first": "Paul", "middle": [], "last": "Lamere", "suffix": ""}], "chunk": "The million song dataset [SEP] With VW 12 we can make a significant improvement on this baseline.\n 5. THE FUTURE OF THE DATASET\nTime will tell how useful the MSD proves to be, but here\nare our thoughts regarding what will become of this data.\n We have assemble a dataset which we designed to be comprehensive and detailed enough to support a very wide range\nof music information research tasks for at least the near future. Our hope is that the Million Song Dataset becomes\nthe natural choice for researchers wanting to try out ideas\nand algorithms on data that is standardized, easily obtained,\nand relevant to both academia and industry. If we succeed,\nour field can be greatly strengthened through the use of a\ncommon, relevant dataset.\n But for this to come true, we need lots of people to use\nthe data."}, {"title": "Learning to generate music with sentiment", "bibref": "BIBREF306", "authors": [{"first": "Lucas", "middle": [], "last": "Ferreira", "suffix": ""}, {"first": "Jim", "middle": [], "last": "Whitehead", "suffix": ""}], "chunk": "Learning to generate music with sentiment [SEP] MODEL\n We propose a Deep Learning method for affective algorithmic composition that can be controlled to generate music\nwith a given sentiment. This method is based on the work\nof Radford et al. [13] which generates product reviews (in\ntextual form) with sentiment. Radford et al. [13] used a\nsingle-layer multiplicative long short-term memory (mLSTM) network [8] with 4096 units to process text as a sequence of UTF-8 encoded bytes (character-based language\nmodeling)."}]}, "gpt-3.5-turbo_5_chunks": {"text": "Datasets - MIDI\n\nMIDI datasets play a crucial role in training deep learning models for music generation tasks. The KernScores dataset, obtained through an optical music recognition system, contains classical music in a Humdrum format [REF0]. Another notable dataset is Kunstderfuge, which includes solo piano and non-solo piano works from a wide range of composers, all entered using a MIDI sequencer [REF0]. The MAPS dataset utilized MIDI files from Piano-midi.de to render real recordings on a Yamaha Disklavier, while the MAESTRO dataset features over 200 hours of fine alignment MIDI files and audio recordings performed by virtuoso pianists on Yamaha Disklaviers [REF0].\n\nThe idea of creating a large-scale dataset like the \"million song dataset\" has been discussed within the music generation community, highlighting the challenges of collecting and sharing such vast amounts of music data [REF2]. While existing datasets have been valuable for research, the potential benefits of larger, more diverse datasets are evident in enhancing the capabilities of deep learning models for music generation tasks.\n\nIn the context of deep music generation, the representation of MIDI data is crucial for model performance. The choice between a blended score and a separated composition representation can significantly impact the model's ability to generate music with multiple instruments effectively [REF3]. Models operating on a separated score representation, where each instrument voice is encoded as a monophonic sequence, offer advantages in explicitly modeling relationships between different instrument voices, enhancing the overall quality of generated music [REF3].\n\nDeep learning methods have been proposed for affective algorithmic composition, allowing for the generation of music with specific sentiments. Inspired by previous work on sentiment analysis in textual data, a deep learning approach based on a single-layer multiplicative long short-term memory (mLSTM) network has been utilized for music generation tasks, demonstrating the potential for controlling sentiment in generated music [REF4].", "references_sent_to_gpt": [{"title": "Giantmidi-piano: A large-scale midi dataset for classical piano music", "bibref": "BIBREF358", "authors": [{"first": "Qiuqiang", "middle": [], "last": "Kong", "suffix": ""}, {"first": "Bochen", "middle": [], "last": "Li", "suffix": ""}, {"first": "Jitong", "middle": [], "last": "Chen", "suffix": ""}, {"first": "Yuxuan", "middle": [], "last": "Wang", "suffix": ""}], "chunk": "Giantmidi-piano: A large-scale midi dataset for classical piano music [SEP] The KernScores dataset (Sapp, 2005) contains classical music with a Humdrum format and is obtained\nby an optical music recognition system.\n The Kunstderfuge dataset (Kunstderfuge, 2002) contains solo piano and non-solo piano works of 598 composers. All of\nthe piano-midi.de, classical archives, and Kunstderfuge\ndatasets are entered using a MIDI sequencer and are\nnot played by pianists.\n The MAPS dataset (Emiya et al., 2010) used MIDI\nfiles from Piano-midi.de to render real recordings by\nplaying back the MIDI files on a Yamaha Disklavier. The\nMAESTRO dataset (Hawthorne et al., 2019) contains\nover 200 hours of fine alignment MIDI files and audio\nrecordings. In MAESTRO, virtuoso pianists performed\non Yamaha Disklaviers with an integrated MIDI capture\nsystem. MAESTRO contains music works from 62 composers."}, {"title": "Automatic melody harmonization with triad chords: A comparative study", "bibref": "BIBREF179", "authors": [{"first": "Yin-Cheng", "middle": [], "last": "Yeh", "suffix": ""}, {"first": "Wen-Yi", "middle": [], "last": "Hsiao", "suffix": ""}, {"first": "Satoru", "middle": [], "last": "Fukayama", "suffix": ""}, {"first": "Tetsuro", "middle": [], "last": "Kitahara", "suffix": ""}, {"first": "Benjamin", "middle": [], "last": "Genchel", "suffix": ""}, {"first": "", "middle": [], "last": "Hao-Min", "suffix": ""}, {"first": "Hao-Wen", "middle": [], "last": "Liu", "suffix": ""}, {"first": "Yian", "middle": [], "last": "Dong", "suffix": ""}, {"first": "Terence", "middle": [], "last": "Chen", "suffix": ""}, {"first": "Yi-Hsuan", "middle": [], "last": "Leong", "suffix": ""}, {"first": "", "middle": [], "last": "Yang", "suffix": ""}], "chunk": "Automatic melody harmonization with triad chords: A comparative study [SEP] The other chords all fall into the others category.\n We identify two potential benefits of adding chord functions to the target output.\n First, in contrast to the distribution of chord labels, the distribution of chord functions\nis relatively balanced, making it easier for the model to learn the chord functions.\n Second, as the chord functions and chord labels are interdependent, adding the chord\nfunctions as a target informs the model which chord labels share the same function and\nmay therefore be interchangeable. We hypothesize that this multi-task learning will\nhelp our model learn proper functional progression, which in turn will produce better\nharmonic phrasing relative to the melody. Specifically, the loss function is defined as:\nL\u2217\n=\nLchord + \u03b3Lfunction\n=\nH( \u02c6Ychord, Ychord) +"}, {"title": "The million song dataset", "bibref": "BIBREF356", "authors": [{"first": "Thierry", "middle": [], "last": "Bertin-Mahieux", "suffix": ""}, {"first": "Daniel", "middle": [], "last": "PW Ellis", "suffix": ""}, {"first": "Brian", "middle": [], "last": "Whitman", "suffix": ""}, {"first": "Paul", "middle": [], "last": "Lamere", "suffix": ""}], "chunk": "The million song dataset [SEP] The idea of a \u201cmillion song\ndataset\u201d started as a flippant suggestion of what it would\ntake to solve this problem. But the idea stuck \u2013 not only in\nthe form of developing a very large, common dataset, but\neven in the specific scale of one million tracks.\n There are a several possible reasons why the community\ndoes not already have a dataset of this scale:\n\u2022 We all already have our favorite, personal datasets of\nhundreds or thousands of tracks, and to a large extent\nwe are happy with the results we get from them.\n \u2022 Collecting the actual music for a dataset of more than\na few hundred CDs (i.e. the kind of thing you can do\nby asking all your colleagues to lend you their collections) becomes something of a challenge.\n\f \u2022 The well-known antagonistic stance of the recording\nindustry to the digital sharing of their data seems to\ndoom any effort to share large music collections.\n"}, {"title": "The nes music database: A multi-instrumental dataset with expressive performance attributes", "bibref": "BIBREF199", "authors": [{"first": "Chris", "middle": [], "last": "Donahue", "suffix": ""}, {"first": "Huanru", "middle": [], "last": "Henry Mao", "suffix": ""}, {"first": "Julian", "middle": [], "last": "Mcauley", "suffix": ""}], "chunk": "The nes music database: A multi-instrumental dataset with expressive performance attributes [SEP] This representation simplifies the probabilistic framework of the task, but it is problematic for music with multiple instruments (such as the music in NES-MDB). Resultant systems must provide an additional mechanism for\nassigning notes of a blended score to instrument voices,\nor otherwise render the music on polyphonic instruments\nsuch as the piano.\n 2.2 Separated composition\nGiven the shortcomings of the blended score , we might\nprefer models which operate on a separated score representation (Fig. 1b). A separated score S is a matrix of size\nV \u00d7 T, where V is the number of instrument voices, and\nS[v, t] = n, the note n played by voice v at timestep t. In\nother words, the format encodes a monophonic sequence\nfor each instrument voice. Statistical approaches to this\nrepresentation can explicitly model the relationships between various instrument voices by\nP(c) =\nT\n\ufffd\nt=1\nV\ufffd\nv=1\nP(Sv,t | Sv,\u02c6t\u0338=t, S\u02c6v\u0338=v,\u2200\u02c6t).\n"}, {"title": "Learning to generate music with sentiment", "bibref": "BIBREF306", "authors": [{"first": "Lucas", "middle": [], "last": "Ferreira", "suffix": ""}, {"first": "Jim", "middle": [], "last": "Whitehead", "suffix": ""}], "chunk": "Learning to generate music with sentiment [SEP] MODEL\n We propose a Deep Learning method for affective algorithmic composition that can be controlled to generate music\nwith a given sentiment. This method is based on the work\nof Radford et al. [13] which generates product reviews (in\ntextual form) with sentiment. Radford et al. [13] used a\nsingle-layer multiplicative long short-term memory (mLSTM) network [8] with 4096 units to process text as a sequence of UTF-8 encoded bytes (character-based language\nmodeling)."}]}, "gpt-3.5-turbo_1_chunks": {"text": "MIDI datasets play a crucial role in deep music generation research, providing a structured and standardized format for representing musical information. Several prominent MIDI datasets have been utilized in the field. The KernScores dataset, for instance, consists of classical music in Humdrum format obtained through an optical music recognition system [REF0]. Another notable dataset is Kunstderfuge, which includes solo piano and non-solo piano works from a wide range of composers, all entered using a MIDI sequencer [REF0]. Additionally, the MAPS dataset leveraged MIDI files from Piano-midi.de to produce real recordings by playing back the MIDI files on a Yamaha Disklavier [REF0]. Furthermore, the MAESTRO dataset, comprising over 200 hours of meticulously aligned MIDI files and audio recordings, features performances by virtuoso pianists on Yamaha Disklaviers with an integrated MIDI capture system [REF0]. This dataset encompasses works from 62 different composers, adding diversity to the available musical content for research purposes.", "references_sent_to_gpt": [{"title": "Giantmidi-piano: A large-scale midi dataset for classical piano music", "bibref": "BIBREF358", "authors": [{"first": "Qiuqiang", "middle": [], "last": "Kong", "suffix": ""}, {"first": "Bochen", "middle": [], "last": "Li", "suffix": ""}, {"first": "Jitong", "middle": [], "last": "Chen", "suffix": ""}, {"first": "Yuxuan", "middle": [], "last": "Wang", "suffix": ""}], "chunk": "Giantmidi-piano: A large-scale midi dataset for classical piano music [SEP] The KernScores dataset (Sapp, 2005) contains classical music with a Humdrum format and is obtained\nby an optical music recognition system.\n The Kunstderfuge dataset (Kunstderfuge, 2002) contains solo piano and non-solo piano works of 598 composers. All of\nthe piano-midi.de, classical archives, and Kunstderfuge\ndatasets are entered using a MIDI sequencer and are\nnot played by pianists.\n The MAPS dataset (Emiya et al., 2010) used MIDI\nfiles from Piano-midi.de to render real recordings by\nplaying back the MIDI files on a Yamaha Disklavier. The\nMAESTRO dataset (Hawthorne et al., 2019) contains\nover 200 hours of fine alignment MIDI files and audio\nrecordings. In MAESTRO, virtuoso pianists performed\non Yamaha Disklaviers with an integrated MIDI capture\nsystem. MAESTRO contains music works from 62 composers."}]}, "gpt-4-1106-preview_1_chunks": {"text": "In the realm of deep music generation, MIDI datasets play a crucial role as they provide structured data that can be directly fed into generative models. Among the prominent datasets, the KernScores dataset stands out as a significant source of classical music in Humdrum format, which was derived using an optical music recognition system [REF0]. Although not originally in MIDI format, the data from KernScores can be converted and used for training deep learning models.\n\nAnother valuable resource is the Kunstderfuge dataset, which encompasses a vast collection of both solo piano and ensemble works from 598 composers [REF0]. This dataset, along with others like piano-midi.de and classical archives, is created using MIDI sequencers, ensuring a high level of precision in note timing and dynamics, albeit lacking the nuanced expression of live performances.\n\nFor applications requiring a closer approximation to actual piano performances, the MAPS dataset is a noteworthy contribution [REF0]. It consists of MIDI files from Piano-midi.de that have been used to produce real recordings by playing them back on a Yamaha Disklavier, thus capturing the acoustic sound of a piano being played by the MIDI instructions.\n\nA step further in this direction is the MAESTRO (MIDI and Audio Edited for Synchronous TRacks and Organization) dataset, which includes over 200 hours of paired MIDI and audio recordings [REF0]. The MIDI files in MAESTRO are the result of virtuoso pianists performing on Yamaha Disklaviers with integrated MIDI capture systems, offering a rich source of data that captures the subtleties and expressiveness of expert musicianship. The dataset spans works from 62 composers, providing a diverse range of styles and complexities for training and evaluating music generation systems.\n\nThese datasets are instrumental for various research purposes, from training deep neural networks to understand and generate complex musical compositions, to evaluating the performance of such models in tasks that require a nuanced understanding of music theory and performance. The availability of high-quality MIDI datasets like these is a cornerstone for advancing the state-of-the-art in deep music generation.", "references_sent_to_gpt": [{"title": "Giantmidi-piano: A large-scale midi dataset for classical piano music", "bibref": "BIBREF358", "authors": [{"first": "Qiuqiang", "middle": [], "last": "Kong", "suffix": ""}, {"first": "Bochen", "middle": [], "last": "Li", "suffix": ""}, {"first": "Jitong", "middle": [], "last": "Chen", "suffix": ""}, {"first": "Yuxuan", "middle": [], "last": "Wang", "suffix": ""}], "chunk": "Giantmidi-piano: A large-scale midi dataset for classical piano music [SEP] The KernScores dataset (Sapp, 2005) contains classical music with a Humdrum format and is obtained\nby an optical music recognition system.\n The Kunstderfuge dataset (Kunstderfuge, 2002) contains solo piano and non-solo piano works of 598 composers. All of\nthe piano-midi.de, classical archives, and Kunstderfuge\ndatasets are entered using a MIDI sequencer and are\nnot played by pianists.\n The MAPS dataset (Emiya et al., 2010) used MIDI\nfiles from Piano-midi.de to render real recordings by\nplaying back the MIDI files on a Yamaha Disklavier. The\nMAESTRO dataset (Hawthorne et al., 2019) contains\nover 200 hours of fine alignment MIDI files and audio\nrecordings. In MAESTRO, virtuoso pianists performed\non Yamaha Disklaviers with an integrated MIDI capture\nsystem. MAESTRO contains music works from 62 composers."}]}, "gpt-4-1106-preview_5_chunks": {"text": "MIDI datasets are crucial for training and evaluating deep music generation systems. They provide a structured representation of musical information that can be easily processed by algorithms. One of the earliest datasets in this domain is the KernScores dataset, which contains classical music in Humdrum format, derived from optical music recognition systems [REF0]. Another significant collection is the Kunstderfuge dataset, which includes both solo and non-solo piano works from a wide range of composers. Unlike KernScores, the MIDI files in Kunstderfuge, as well as those in the piano-midi.de and classical archives, are created using MIDI sequencers rather than being performed by pianists [REF0].\n\nThe MAPS dataset takes a different approach by using MIDI files from Piano-midi.de to generate real recordings on a Yamaha Disklavier, thus providing a link between MIDI data and actual acoustic recordings [REF0]. This is further advanced by the MAESTRO dataset, which contains over 200 hours of finely aligned MIDI and audio recordings from virtuoso pianists performing on Yamaha Disklaviers with integrated MIDI capture systems, offering a rich resource for both transcription tasks and performance modeling [REF0].\n\nWhen evaluating the performance of music generation systems, datasets like GiantMIDI-Piano are used to assess various error types, such as performance, transcription, and alignment errors. These errors reflect the discrepancies between the generated music and the ground truth, with lower error rates indicating better performance [REF1].\n\nHowever, MIDI datasets are not without their challenges. For instance, when dealing with music that involves multiple instruments, such as in the NES-MDB dataset, systems must be capable of assigning notes to the correct instrument voices, which can be a complex task [REF2]. This necessitates the development of models that can handle separated score representations, where each instrument's part is encoded as a monophonic sequence, allowing for explicit modeling of the relationships between different instrument voices [REF2].\n\nFurthermore, MIDI datasets can include a variety of features beyond just the notes themselves. These can encompass pitch, duration, articulation, dynamic markings, and performance features like tempo, velocity, and pedal usage, all of which are encoded at the note level [REF3]. Such detailed information enables the development of sophisticated models, such as Hierarchical Attention Networks (HANs), which can predict sequences of performance features from sequences of score features by summarizing lower-level representations into higher-level ones [REF3].\n\nLastly, the inclusion of chord functions in MIDI datasets can provide additional benefits for music generation models. By informing the model of the interdependencies between chord labels and their functions, it can facilitate the learning of proper functional progressions and improve harmonic phrasing in relation to the melody [REF4]. This multi-task learning approach, where the model is trained on both chord labels and functions, can lead to more musically coherent outputs [REF4].\n\nIn summary, MIDI datasets serve as a foundational element for deep music generation, offering a diverse range of data for training and evaluating models. The choice of dataset can significantly impact the performance and capabilities of the resulting systems, making it essential to select or create datasets that align with the specific goals of the research or application.", "references_sent_to_gpt": [{"title": "Giantmidi-piano: A large-scale midi dataset for classical piano music", "bibref": "BIBREF358", "authors": [{"first": "Qiuqiang", "middle": [], "last": "Kong", "suffix": ""}, {"first": "Bochen", "middle": [], "last": "Li", "suffix": ""}, {"first": "Jitong", "middle": [], "last": "Chen", "suffix": ""}, {"first": "Yuxuan", "middle": [], "last": "Wang", "suffix": ""}], "chunk": "Giantmidi-piano: A large-scale midi dataset for classical piano music [SEP] The KernScores dataset (Sapp, 2005) contains classical music with a Humdrum format and is obtained\nby an optical music recognition system.\n The Kunstderfuge dataset (Kunstderfuge, 2002) contains solo piano and non-solo piano works of 598 composers. All of\nthe piano-midi.de, classical archives, and Kunstderfuge\ndatasets are entered using a MIDI sequencer and are\nnot played by pianists.\n The MAPS dataset (Emiya et al., 2010) used MIDI\nfiles from Piano-midi.de to render real recordings by\nplaying back the MIDI files on a Yamaha Disklavier. The\nMAESTRO dataset (Hawthorne et al., 2019) contains\nover 200 hours of fine alignment MIDI files and audio\nrecordings. In MAESTRO, virtuoso pianists performed\non Yamaha Disklaviers with an integrated MIDI capture\nsystem. MAESTRO contains music works from 62 composers."}, {"title": "Giantmidi-piano: A large-scale midi dataset for classical piano music", "bibref": "BIBREF358", "authors": [{"first": "Qiuqiang", "middle": [], "last": "Kong", "suffix": ""}, {"first": "Bochen", "middle": [], "last": "Li", "suffix": ""}, {"first": "Jitong", "middle": [], "last": "Chen", "suffix": ""}, {"first": "Yuxuan", "middle": [], "last": "Wang", "suffix": ""}], "chunk": "Giantmidi-piano: A large-scale midi dataset for classical piano music [SEP] Substitution indicates that some\nnotes are replacements of ground truth notes. Insertion indicates that extra notes are being played. Deletion indicates that some notes are missing. Lower ER\nindicates better transcription performance.\n The ER of music works from GiantMIDI-Piano consists of three parts: 1) performance errors, 2) transcription errors, and 3) alignment errors:\n ERG = eperformanceG +etranscriptionG +ealignmentG\n(4)\nwhere\nthe\nsubscript\nG\nis\nthe\nabbreviation\nfor\nGiantMIDI-Piano. The performance errors eperformanceG\nTable 4: Piano\ntranscription\nevaluation\non\nthe\nGiantMIDI-Piano dataset\nD\nI\nS\nER\nMaestro\n0.009\n0.024\n0.018\n0.061\nGiantMIDI-Piano\n0.015\n0.051\n0.069\n0.154\nRelative difference\n0.006\n0.026\n0.047\n0.094\ncome from that a pianist may accidentally miss or add\nnotes while performing (Repp, 1996)."}, {"title": "The nes music database: A multi-instrumental dataset with expressive performance attributes", "bibref": "BIBREF199", "authors": [{"first": "Chris", "middle": [], "last": "Donahue", "suffix": ""}, {"first": "Huanru", "middle": [], "last": "Henry Mao", "suffix": ""}, {"first": "Julian", "middle": [], "last": "Mcauley", "suffix": ""}], "chunk": "The nes music database: A multi-instrumental dataset with expressive performance attributes [SEP] This representation simplifies the probabilistic framework of the task, but it is problematic for music with multiple instruments (such as the music in NES-MDB). Resultant systems must provide an additional mechanism for\nassigning notes of a blended score to instrument voices,\nor otherwise render the music on polyphonic instruments\nsuch as the piano.\n 2.2 Separated composition\nGiven the shortcomings of the blended score , we might\nprefer models which operate on a separated score representation (Fig. 1b). A separated score S is a matrix of size\nV \u00d7 T, where V is the number of instrument voices, and\nS[v, t] = n, the note n played by voice v at timestep t. In\nother words, the format encodes a monophonic sequence\nfor each instrument voice. Statistical approaches to this\nrepresentation can explicitly model the relationships between various instrument voices by\nP(c) =\nT\n\ufffd\nt=1\nV\ufffd\nv=1\nP(Sv,t | Sv,\u02c6t\u0338=t, S\u02c6v\u0338=v,\u2200\u02c6t).\n"}, {"title": "Virtuosonet: A hierarchical rnn-based system for modeling expressive piano performance", "bibref": "BIBREF354", "authors": [{"first": "Dasaem", "middle": [], "last": "Jeong1", "suffix": ""}, {"first": "Taegyun", "middle": [], "last": "Kwon1", "suffix": ""}, {"first": "Yoojin", "middle": [], "last": "Kim1", "suffix": ""}, {"first": "Kyogu", "middle": [], "last": "Lee2", "suffix": ""}, {"first": "Juhan", "middle": [], "last": "Nam1", "suffix": ""}], "chunk": "Virtuosonet: A hierarchical rnn-based system for modeling expressive piano performance [SEP] The score features include pitch, duration, articulation marking, slur and beam\nstatus, tempo marking, dynamic markings, and so on. The\nperformance features include absolute tempo, velocity, onset deviation, articulation and pedal usages. All the features\nare encoded in the note-level so that each note had the same\ndimension of score features and performance features.\n 3.1.2 Hierarchical Attention Network\nRecent research has shown that a hierarchical approach can\nimprove the performance of RNN model in modeling sequential data [6, 30]. It was also demonstrated that the hierarchical approach has advantages in generating symbolic\nmusic data [25]. In this paper, we employ a hierarchical\nattention network (HAN) to predict a sequence of performance features from a sequence of score features.\n The HAN composes higher-level representations by\nsummarizing lower-level representations in pre-defined hierarchical boundaries using a weighted sum."}, {"title": "Automatic melody harmonization with triad chords: A comparative study", "bibref": "BIBREF179", "authors": [{"first": "Yin-Cheng", "middle": [], "last": "Yeh", "suffix": ""}, {"first": "Wen-Yi", "middle": [], "last": "Hsiao", "suffix": ""}, {"first": "Satoru", "middle": [], "last": "Fukayama", "suffix": ""}, {"first": "Tetsuro", "middle": [], "last": "Kitahara", "suffix": ""}, {"first": "Benjamin", "middle": [], "last": "Genchel", "suffix": ""}, {"first": "", "middle": [], "last": "Hao-Min", "suffix": ""}, {"first": "Hao-Wen", "middle": [], "last": "Liu", "suffix": ""}, {"first": "Yian", "middle": [], "last": "Dong", "suffix": ""}, {"first": "Terence", "middle": [], "last": "Chen", "suffix": ""}, {"first": "Yi-Hsuan", "middle": [], "last": "Leong", "suffix": ""}, {"first": "", "middle": [], "last": "Yang", "suffix": ""}], "chunk": "Automatic melody harmonization with triad chords: A comparative study [SEP] The other chords all fall into the others category.\n We identify two potential benefits of adding chord functions to the target output.\n First, in contrast to the distribution of chord labels, the distribution of chord functions\nis relatively balanced, making it easier for the model to learn the chord functions.\n Second, as the chord functions and chord labels are interdependent, adding the chord\nfunctions as a target informs the model which chord labels share the same function and\nmay therefore be interchangeable. We hypothesize that this multi-task learning will\nhelp our model learn proper functional progression, which in turn will produce better\nharmonic phrasing relative to the melody. Specifically, the loss function is defined as:\nL\u2217\n=\nLchord + \u03b3Lfunction\n=\nH( \u02c6Ychord, Ychord) +"}]}}, "checklist": {"items": [{"number": 1, "text": "Does the text provide an explanation of what MIDI is?"}, {"number": 2, "text": "Does the text mention the MIDI file format and its characteristics?"}, {"number": 3, "text": "Does the text mention the pretty_midi Python toolkit and its functions?"}, {"number": 4, "text": "Does the text mention the Music21 toolkit and its functions?"}, {"number": 5, "text": "Does the text mention the J.S. Bach four-part chorus dataset?"}, {"number": 6, "text": "Does the text mention the VGMIDI dataset with sentiment notation?"}, {"number": 7, "text": "Does the text mention the Lakh MIDI Dataset and its different formats?"}, {"number": 8, "text": "Does the text mention other MIDI datasets available on the internet?"}, {"number": 9, "text": "Does the text mention the Projective Orchestral Database (POD)?"}, {"number": 10, "text": "Does the text mention the e-piano junior competition dataset?"}, {"number": 11, "text": "Does the text mention the ADL piano MIDI dataset?"}, {"number": 12, "text": "Does the text mention the GiantMIDI-Piano dataset?"}, {"number": 13, "text": "Does the text mention BitMidi and Classical Archives as sources of MIDI files?"}, {"number": 14, "text": "Does the text mention the largest MIDI dataset on the internet?"}, {"number": 15, "text": "Does the text mention other MIDI datasets available?"}]}, "evaluation": [{"item": 1, "contemplated": false}, {"item": 2, "contemplated": false}, {"item": 3, "contemplated": false}, {"item": 4, "contemplated": false}, {"item": 5, "contemplated": false}, {"item": 6, "contemplated": false}, {"item": 7, "contemplated": false}, {"item": 8, "contemplated": false}, {"item": 9, "contemplated": false}, {"item": 10, "contemplated": false}, {"item": 11, "contemplated": false}, {"item": 12, "contemplated": false}, {"item": 13, "contemplated": false}, {"item": 14, "contemplated": false}, {"item": 15, "contemplated": false}], "score_checkeval": 0.0}
